#+title: Design Patterns
#+author: Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides
#+date: 1994

* 1 Introduction

- Experienced designers evidently know something inexperienced ones don't. What is it?

  One thing expert designers know not to do is solve every problem from first principles.
  Rather, they reuse solutions that have worked for them in the past.
  When they find a good solution, they use it again and again.
  Such experience is part of what makes them experts.

- What is a design pattern?

  Christopher Alexander says, "Each pattern describes a problem which occurs over and
  over again in our environment, and then describes the core of the solution to that
  problem, in such a way that you can use this solution a million times over, without ever
  doing it the same way twice" [AIS+77, page x]

  - In this sense, the followings are all application domain-specific design pattern,
    where the application domain is programming language implementation.

    - closure (for lexical scope)
    - bidirectional type checking (reading inference rule as type checking algorithm)
    - normalization by evaluation (NbE) (partial evaluation)
    - elaboration during type checking (clear separation of roles)

    Are those design patterns clearly expressed in my OOD code?

- What are the four parts of a design pattern?

  1. The pattern name
  2. The problem
  3. The solution
  4. The consequences

- What is the "level of abstraction" of a design pattern?

  Point of view affects one's interpretation of what is and isn't a pattern.
  One person's pattern can be another person's primitive building block.

  - low level:
    such as linked lists, hash tables,
    and Kent Beck's book "implementation patterns"

  - high level:
    domain-specific designs for an entire application or subsystem.

  - mid level:
    descriptions of communicating objects and classes that are
    customized to solve a general design problem in a particular context.

* 2 A Case Study: Designing a Document Editor
