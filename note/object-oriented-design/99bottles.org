#+title: 99 bottles
#+author: Sandi Marts
#+date: 2021

* 1. Rediscovering Simplicity

** What kind of code should we write first?

Write Shameless Green code first.
- TDD will teach us how to do this.
- abstraction should be guided by new requirements, keep it simple when there is no new requirements
- new design with new abstraction should be achieved by refactoring

** How should we measure code quality? is it even possible?

ABC Metric -- Assignments, Branches and Conditions,
is a good quantitative measure of code quality.

** What questions can help us understand the cost and value of code?

Questions about cost and value of code:

1. How difficult was it to write? (past)
2. How hard is it to understand? (now)
3. How expensive will it be to change? (future)

Among the above (now) is the most import question.

Beside the above, domain questions is another important kind of questions.
- Which is about understanding.

* 2. Test Driving Shameless Green

** Why we wish to "getting green first"?

Getting green first, Shameless Green maximum understandability
but is generally unconcerned with changeability.

Because we'd better achieve understandability and changeability in steps.

** How to achieve understandability and changeability

To achieve understandability and changeability,
we, little by little, separate the things that change
from the things that remain the same.

Like reversing the distribution of multiplication over addition:

x * y + x * z => x * (y + z)

** Why we wish to delay abstraction?

Because we want to wait for more information.

Delay abstraction, wait for more information.

It's better to tolerate duplication
than to anticipate the wrong abstraction.

** What questions can help us understand the cost and value of making abstraction?

Ask the following questions, before making an abstraction:

1. Does the change I’m contemplating make the code harder to understand?
2. What is the future cost of doing nothing now?
3. When will the future arrive, or how soon will I get more information?

** During the search for Shameless Green, We should tolerate what kind of duplication?

When it isolates a new independent example,
for which the underlying abstraction is not clear yet.

** And, we should not tolerate what kind of duplication?

Those kind of duplication that blurs the responsibility.

** When should we jump over the small steps of TDD?

Never.

Because you do not always know what is actually right.

** What is Kent Beck's Triangulation? [三角测量法]

Targeting multiple tests in one implementation step.
Because you can not fake multiple tests.

** How should we design public API?

As method provider, we should think about message sender,
and help them to know as less as possible.

Bwtween sender and provider, to know is to depend.

** What is the first step in learning the art of testing?

The first step in learning the art of testing
 is to understand how to write tests that
confirm what your code does
without any knowledge of how your code does it.

* 3. Unearthing Concepts

** When a new requirement arrive, what we learned?

The arrival of a new requirement tells you two things:
- Exactly how the code should change
- The code need to be easy to change

** What is your licence to improve some (Shameless Green) code?

Someone has asked for a change.

** What is the "open" principle of SOLID?

O - Open-Closed

Objects should be open for extension, but closed for modification.

"open for extension" means extension not by editing the conditional,
but by merely adding code.

When faced with a new requirement,
first "open" the code for change,
then add the new code.

** If we do not know how to open the code, what should we do?

We should remove the easiest to fix and best understood code smell.

** How to find code smells?

Make a list of the things you dislike about your code.

** How to achieve good abstraction?

Use the "Flocking Rules":

1. Select the things that are most alike.
2. Find the smallest difference between them.
3. Make the simplest change that will remove that difference.

DRYing out sameness has some value, but DRYing out difference has more.

** Why "Flocking"?

Birds flock, fish school, and insects swarm.

A flock's behavior can appear so synchronized and complex
that it gives the impression of being centrally coordinated.
Nothing could be further from the truth.

The group's behavior is the result of a continuous series of
small decisions being made by each participating individual.
These decisions are guided by three simple rules.

1. Alignment - Steer towards the average heading of neighbors
2. Separation - Don't get too close to a neighbor
3. Cohesion - Steer towards the average position of the flock

Thus, complex behavior emerges from the repeated application of simple rules.
In the same way that the rules in this sidebar allow birds to flock,
the "Flocking Rules" for code allow abstractions to appear.

** What can we do when we are in the struggle for a name?

There are two pieces of information that can help in the struggle for a name.

One is a general rule and the other is the new requirement:

- The general rule is to name a thing one level of abstraction higher than the thing itself.
- While new requirement can provide new instance for the category we are trying to name.
  We should name the category using the language of the domain.

- Avdi Grimm:

  We can also use rows and columns in an imaginary spreadsheet,
  to write things down, to help find names for underlying concepts.

  This naming technique is called "what would the column header be?"

- Tom Stuart:

  To name a concept for which you have only a few examples,
  it can help to imagine other concrete things
  that might also fall into the same category.

* 4. Practicing Horizontal Refactoring

** Should we think far ahead for creating better abstraction?

You can use your common sense, but in general you should not.

When creating an abstraction,
first describe its responsibility as you understand it at this moment,
then choose a name which reflects that responsibility.

The effort you put into selecting good names right now
pays off by making it easier to recognize perfect names later.

You can learn something during these steps, do not jump.

** How to reducing the number of dependencies imposed upon message senders?

By requiring that receivers return trustworthy objects,
which is a generalization of the Liskov Substitution Principle.
