#+TITLE:  演繹法研究
#+TITLE:  an investigation of mathematical deduction
#+AUTHOR: 謝宇恆 / XIE Yuheng

* 形式體系

*** 知
    - 嘗試定義 知
      知者 了然未然之然也
      未者 將至之時 將適之境也
      所以了然其之然者 因也
      知者 人之所以生 生之所以靈也
      推演而證明 以顯理之確然
      確然之理 可以然未然者 真理也 真知也
      然則 推演之法亦衆 衆法之分亦疏
      或庸庸無用 或自相矛盾
    - 形式化方法 可以用來討論推演方法的性質
      即 推演 與推演方法之性質有關的證明
      在形式體系中
      我可以證明我的某種推演方法將不會產生矛盾
      這類的證明還是要靠推演
      此時所使用的推演規則一定要有強弱之分
      由弱向強層層遞進

*** 數學的發展

***** 無窮小演算 到 算數化的無窮小演算[數學分析]
      * 之所以要進行算數化
        在於
        直覺地無窮小演算中
        有關級數的運算會產生矛盾的結果
        利用 算數化方法 可以定義 無窮級數的收斂性
        將級數的運算限於收斂者 就避免了矛盾的結果

***** 邏輯 到 形式化的邏輯
      * 同數學分析的產生
        利用 形式化方法 可以定義 形式系統的一致性與完備性
        沒有一致性的推演規則所形成的邏輯系統自然有矛盾
        限制其使用即可
      * 注意
        後者與前者是相關的
        因爲 分析的算數化 是利用集論來完成的
        而集論如若不 形式化處理 則易有矛盾
      * 我想 即便是在形式化之後的機器輔助證明時代
        矛盾的結果還是可能出現
        只因機器本身亦有其所限
        人們對確然的追求必定無終

*** 集論 與 形式系統的例子

***** combinator logic
      * alphabet : I K S x ' ( ) =
      * grammar :
        * constant : I | K | S
        * variable : x | variable'
        * term : constant | variable | (term term)
        * formula : term = term
      * axiom :
        I p = p
        K p q = p
        S q p r = p r (q r)
      * rule :
        p = p
        p = q -> q = p
        p = q, q = r -> p = r
        p = q -> p r = q r
        p = q -> r p = r q

***** lambda calculus
      * alphabet : x ' ( ) λ =
      * grammar :
        * variable : x | variable'
        * term : variable | (term term) | (λ variable term term)
        * formula : term = term
      * axiom :
        (λ x M) N = M [in which x change to N]
      * rule :
        the same as combinator logic
        plus
        M = N -> (λ x M) = (λ x N)

***** minimal logic
      * alphabet : x a ' ( ) -> ,
      * grammar :
        * variable : x | variable'
        * atom : a | atom'
        * proposition : atom | (proposition -> proposition)
        * context : <empty> | context, variable : proposition
        * judgment : context -> proposition
      * rule :
        * intro
          x : A -> B
          ------------- x
          -> (A -> B)
        * elimi
          -> A
          -> (A -> B)
          -------------
          -> B

*** 圖釋 與 形式系統的例子

***** 圖釋的意義
      * 在圖論的解釋中可以直接獲得[初步的]幾何解釋
        每個命題[關於點集的謂詞]
        有可以能被表達爲[比如]有向圖中的幾何結構

***** 圖釋的方法
      * table for set based intro
        * grammar -- point generator
        * predicate
          | equality             | path           |
          | axiom about equality | initial path   |
          | rule about equality  | path generator |
          other -- other geometry pattern in graph
        * note that
          which is treated as grammar
          and which is treated as predicate
          can be changed freely
        * 注意
          不同形式系統的主要謂詞不同
          或者說
          不同形式系統所關心謂詞的類型不同

***** >< combinator logic
      ><><>< 例子在線性的文本中並不好寫

***** >< lambda calculus

***** >< minimal logic

*** 範疇論與形式體系 觀察數學對象的差異
    * 可體會到 不同數學對象[具體數學機構][抽象數學結構]
      之間的有趣差異
      [比如 範疇論 與 形式系統 之間]
      這種體會上的差異是心理學研究的範疇
      然而 我可以嘗試觀察 所體會到的差異的 來源
      1. 不同的運算律
         限制了對等式的變形方式
      2. 抽象 與 具體 之別
    * 比如 如果回到集論的視角
      並使用 數學結構 這個術語
      那麼 範疇論 是一個 抽象數學結構
      而 關於 形式體系 也可以創造一般理論
      即 以集合論爲基礎 利用公理 將形式體系定義爲抽象數學結構
      但是這種行爲將是相當迂腐的
      1. 對於 形式體系
         人們總是傾向於觀察 具體的形式體系
      2. 而對於 範疇論
         人們卻總是觀察 做爲抽象數學結構的 範疇論本身
    * 又比如
      範疇論 與 羣論 同樣被做爲公理化的抽象數學結構而研究
      羣論中有有限單羣分類定理
      然而 範疇論中這種分類定理的意義卻不大
      也許這種體會是因爲抽象數學結構之間的層次關係
      這種層次關係在 範疇論 與 羣論 之間很清楚
      [即 羣論 是 特殊的範疇論]
      但是
      1. CAT 做爲具體的 2-category
      2. formal system 以 category 爲語義
      這等等現象又模糊了 層次 這個詞的意義
    * 抽象的數學結構中沒有 "具體的" 計算
      但是當引入各種運算律之後
      卻又有對等式的變換
      [此類等式中 都是局部變元 這些局部變元在敘述的前面引入]

*** >< 用圖釋來 公理化 形式體系 爲抽象的數學結構

* 變化

*** 題解
    - 嘗試以 變化 這個詞爲核心
      來把各個理論聯繫起來
    - 以類型爲命題
      以程序爲證明
      就是發現
      兩種描述變化的語言之間的相似性
      [既然同爲描述變化的語言]
      同時
      它們的範疇論語義也是變化而得以相聯

*** 範疇論是研究變化的理論
    - x ::
         從範疇公理看
         範疇論是描述 狀態之變化 的理論
         每個 object 是一個狀態
         每個 arrow 是一個變化
    - k ::
         但是
         爲了捕捉 變化 這個觀念
         最知名的抽象概念不是範疇中的箭頭
         而是 函數
    - x ::
         沒錯
         啓發這些範疇公理的
         並不是位置或溫度隨時間而變化
         而是
         空間或結構之間的 同態與同構
         同態與同構 做爲函數 把一個結構轉化爲另一個結構
         後者離散而前者連續
    - k ::
         但是同態與同構可以被視爲是特殊的函數
         函數也可離散
    - x ::
         沒錯
         二者之間的側重點不同
         範疇論想要觀察的是
         離散變化之複合
         爲此目的
         必須 有別於 函數 而另立公理
         另外也可以說
         範疇論所觀察的是離散的函數複合
         而微積分所觀察的是連續的函數複合
         因爲複合就是變化的積累
         而積分就是連續變化的積累
    - k ::
         舉幾個例子吧
    - x ::
         數學結構之間的同構
         代表表達方式的變化
         也就是說
         用不同的語法去表達有像似結構的事物
         把這種像似性抽象出來就得到抽象的數學結構
         同態則代表了抽象的數學結構之間的序關係
         這個序所比較的是抽象結構的豐富程度
    - k ::
         那麼
         範疇論可以用來描述自身的離散變化
         並研究這種
         也就是範疇論就此而言是完備的
         即 範疇公理所定義的抽象數學結構
         能夠用來研究這個抽象的數學結構本身
    - x ::
         可以說範疇論之產生
         就是爲了觀察 抽象數學結構 或者 結構化的空間 之間的關係的
         而這種關係是一種特殊的變化
    - k ::
         在這裏所形成的認識下
         如何理解 程序與證明 之等價呢
    - x ::
         所謂等價
         其實是數學結構之間的同構
         既然是同構
         也就是表達同樣的抽象結構
         而使用了不同的語法
    - k ::
         那爲什麼會有語法的分歧
    - x ::
         因爲一種語法不夠用
         每種語法的特點和性質都不同
         這些差異是不被上面的同構所捕捉的
         首先
         發展證明所用的語法
         是爲了向朋友描述論證過程
         讓我們的朋友知道
         從論證的起始條件
         如何變化到最終結論
         然而
         發展編程所用的語法
         是爲了讓機器能夠執行算法
         我們用相當嚴格的形式語言來描述算法
         算法代表了 從計算的初始狀態 如何變化到最終狀態
         然後把我們的描述交給機器
         讓機器幫我們執行 具體的 枯燥的 狀態變化
    - k ::
         然而
         其同爲變化 這一點 爲範疇的公理所捕捉
         但是
         說此二者是同構的時候
         所說的一定比範疇公理更多
         多出來的是什麼呢
    - x ::
         當然是變化之間的關係
         需要一個函子來明確所說的同態的意思
         點如何生成
         箭頭是什麼
         等價關係的作用是什麼
    - k ::
         我們就用這種認識方式來執導我們今後對這個領域的學習吧
    - x ::
         當然如此
    -----------------------------------
    - x ::
         首先還是對範疇論中概念的複習
         人們經常需要例舉具體的範疇來說明問題
         而就舉例而言
         最豐富的例子來源於
         結構化的空間之間各種保持結構的映射
    - k ::
         具體範疇 這個術語的意義有時被限制地更狹隘
         如果放寬限制的話
         那麼 你所說的 棧語義 就是很有趣的範疇的例子
         而 證明論範疇 還有 類型論範疇
         是這類例子中兩個古典的例子

*** 證明與程序
    - 人所寫下的證明
      人所寫下的函數體[程序]
      都是對變化的記錄
    - 對變化的描述就是 inference 或 deduction
    - 就編程而言
      寫一個函數體的時候
      描述了如何把輸入的數據變化成輸出的數據
      或者把機器的一個狀態轉化爲另一個狀態
      然後
      我們給這個新寫好的函數一個類型
      用來總結所進行的變化
      可以發現
      這種總結 不是對函數的所有細節的重複敘述
      而是只提取了關於變化的大致信息
      利用這些信息[比如]我們能對寫下的函數做類型檢查
      - 函數 通過變化 參數棧 的狀態來進行計算
        類型系統 通過變化 類型棧 的狀態來進行編譯時期的類型檢查
    - 就數學證明而言
      首先我們有一些已知條件
      同時我們還知道能夠對些已知條件進行的各種變換
      我們去做這些變換
      最終得到某些結論
      這樣我們就得到一個定理
      記爲 (條件 -> 結論)
      我們給這個定理一個名字
      之後就可以使用這個定理了
      也就是說
      一個定理是對一系列變換的總結
      當我們再次想要實施這一系列變換的時候
      只要說使用這個定理就行了
    - 其實計算模型不只如此狹隘
      有很多方式去進行計算
      本質上很不同的程序語言
      正是被他們所想要捕捉的不同計算模型而區別的
      但是
      在這裏我只想類比到人們在實踐中所進行的數學推演
    - 當強調變化的時候
      可以發現
      我們所使用的是
      比形式主義的形式系統
      更具體而靈活的思維模型[表達方式]
      也許
      類似形式主義
      我也可以給我的思維範式以一個堂皇的意識形態性的名字
      實用主義 實踐主義 機械主義 等等

*** 推演規則 與 函數
    - inference rule 是對變化的描述
      inference rule 對應於 primitive-function
      證明 與 程序 都是對 primitive-function 之複合的記錄
    - 用推演規則來定義的函數 是 抽象的函數
      推演規則猶如抽象數學結構中的公理
      而具體的函數是對參數棧的操作
    - 公理也可以被理解爲謂詞的性質
      這些性質利用函數與函數之間的關係來敘述
    - 下面是一個推演規則
      t : (A -> B)
      -------------------
      t dup : (A -> B B)
      當有 polymorphic 時
      可以直接寫爲
      dup : (x -> x x)
      正如推演規則本身可以被視爲是抽象的公理
      polymorphic 也是一種抽象性
    - 推演規則 也可以被理解爲 高階函數
      並且易於使用 函數類型的分式記法

*** 用於計算函數 與 函數在命題[類型]中的形式出現
    - 當函數[比如謂詞]在命題[類型]中出現時
      他們根本不是用於做計算的函數本身
      比如
      1. add : (<number> <number> -> <number>)
      2. add : (x : <number> y : <number> -> (:x: :y: add))
         - 每個 函數 都自動成爲一個類型構造子[後綴表達式的]
           在生成類型構造子的同時
           我們可以描述這個類型構造子
           與其他類型構造子之間的關係
           比如
           用 add1 來把 add 定義爲遞歸函數
           add 本身做爲函數可以根本不是用 add1 遞歸定義的
           這種遞歸定義只描述 類型構造子之間的關係
      如何理解後者
      看來它給出的信息最多
      它是合理的定義嘛
      看似是不合理的
      因爲想要證明與 add 有關的定理
      必須用更基礎的函數遞歸定義 add
      根據遞歸定義的方式 我們才可以推演出 add 的性質
      1. 想要做爲一個實用的類型系統
         第一種定義就夠了
      2. 想要證明與 add 相關的定理
         就必須要使用第二種定義
         此時
         我們不想知道 add 是如何被進行的[不想知道其函數體的定義]
         而是想知道 add 的一般性質如何
         這些一般性質都是在 add 和別的 比如 succ sub mul 等等類型構造子之間的關係中表達出來的
         並且這種表達通常都會利用到等詞 或者類似等詞的二元關係[二元謂詞]
      是否實用的類型系統一定要和
      做爲機器輔助證明系統的類型系統相互分離呢
      這一點在實現類型系統時也能體會到
      比如 我需要用一個 argument-stack 還有一個 type-stack
      而不能混淆二者

*** 類型棧
    - 類型棧 用於實現 蟬語的類型系統
      這是以如下的方式完成的
      1. 首先 要知道
         每個函數都是對 參數棧 的操作
      2. 之後
         讓這個對 參數棧 的操作
         對應於一個對 類型棧 的操作 即可
         只要給兩個操作相同的名字 就能實現這種對應
      對 參數棧 的操作
      可以被視爲是 對 類型棧 的操作 的計算語義
    - 不同的 對應關係
      可能就代表了 具有不同特性的類型系統
    - 類型棧 用於實現 機器輔助證明系統
      此時
      對類型棧的操作
      並不必對應與某個對參數棧的操作
      即 計算語義 可能還沒有被找到

*** 不包含邏輯連詞的 推演規則的例子

***** 無向圖中的一筆劃
      - 點不是由語法生成的 而是有限列舉出來的 a b c d
      - 無向變
        (edge a b)
        (edge a c)
        (edge a d)
        (edge b c)
        也就是說 edge 這個基本的類型構造子的性質也是有限列舉出來的
      - 其無向性對應於一個 inference rule
        (edge x y)
        ---------- undirected
        (edge y x)
        或可記作
        undirected : ((edge x y) -> (edge y x))
      - 無向路
        (path x y)
        1. 這個類型構造子由 edge 用推演規則定義
           (edge x y)
           ---------- edge->path
           (path x y)
           這是說在偏序關係中 一個高於另一個
           因而而可以 pattern match
        2. 自反性
           <empty>
           ---------- reflexivity
           (path x x)
           或可記作
           reflexivity : (-> (path x x))
           這是一個可選規則
           爲了
        3. 傳遞性
           (path x y) (path y z)
           --------------------- transitivity
           (path x z)
           或可記作
           transitivity : ((path x y) (path y z) -> (path x z))
      - 可以以如下方式區分推演過程的兩種風格
        1. natural deduction
           之前出現的結論可以隨便用
           結論不斷積累
           [這對應於 給參數命名之後 使用函數作用來表達變換]
        2. linear logic
           每個命題都形如 (A -> B)
           在使用一個推演規則時
           條件會被消耗掉
           因此結論不會積累
           [這對應於 參數都不命名 放到棧裏 然後用函數複合來表達變換]
        後者可以用於給 一筆劃問題[hamiltonian path] 以計算模型
        即 邊不可重複走 這個性質 對應於對前提的消耗
      - 注意
        其實在 natural deduction 中
        引入 蘊含 的時候
        也要消耗掉一次假設
        但是這裏的消耗與 linear logic 看似又不同
      - inference rule 對應 primitive-function
        derived rule 對應 non-primitive-function
        前面說到 函數作用 與 函數複合 表達變換的方式不同 就體現在這裏
        比如 用函數作用 可以寫下它如下的 non-primitive-function
        (edge x y)
        ----------
        (path x x)
        用函數複合可以寫成
        edge->path dup undirected transitivity : ((edge x y) -> (path x x))
      - 子圖的一筆劃問題
        (edge x y) (at x)
        ----------------- move
        (at y)
        比如如下子圖 外加選取的一點
        (edge a b)
        (edge a c)
        (edge a d)
        (edge b c)
        (at a)
        ---------- x|swap|xxxx swap
        (edge a c)
        (edge a d)
        (edge b c)
        (edge a b)
        (at a)
        ---------- move
        (edge a c)
        (edge a d)
        (edge b c)
        (at b)
        ---------- move
        (edge a c)
        (edge a d)
        (at c)
        ---------- x|swap|xx
        (edge a d)
        (at c)
        (edge a c)
        ---------- undirected swap
        (edge a d)
        (edge c a)
        (at c)
        ---------- move
        (edge a d)
        (at a)
        ---------- move
        (edge a d)
        (at a)
        ---------- move
        (at d)
        這個證明證明了一筆劃的可能
        或可以寫成
        x|swap|xxxx swap
        move move
        x|swap|xx undirected swap
        move move move :
        ((edge a b)
         (edge a c)
         (edge a d)
         (edge b c)
         (at a)
         ->
         (at d))
      - 又比如說
        如果只想在圖重行走可以寫
        (edge x y) (at x)
        ----------------- walk
        (edge x y) (at y)

***** 奇偶數
      - 這次所討論的是自然數
        也就是最簡單的無窮圖
        無窮個點的成用 successor 來完成
        0 (s 0) (s (s 0)) (s (s (s 0)))
      - 這是用 inference rule 定義謂詞的另一個例子
        這個可能是世界上最簡單的非平凡謂詞之一了
      - 首先是 0
        <empty>
        --------
        (even 0)
      - 在下面兩個例子中
        注意 點生成子 是如何可以在推演規則中出現的
        [邏輯連詞 都是這類 點生成子]
      - (even x)
        -----------
        (odd (s x))
      - (odd x)
        -----------
        (even (s x))

***** king richard III
      - a kingdom for a horse -- richard
        這是 莎翁人物 在戰場上說 用我的王國換一匹馬
      - 點是
        richard kingdom
        謂詞是
        (x owns y)
        (horse x)
      - 用它們可以表達上面那句話
        [注意 richard 只換一次]
        ><><><
      - 論點是 ownership 只能用 linear logic 來建模

***** opportunity
      - opportunity dose not knock twice -- anonymous
      - 點是
        opportunity
        謂詞
        (knock x)
      - 說
        (knock opportunity)
        是上面那句話的模型
        因爲
        使用掉它的這次出現之後就沒有了

***** 支撐樹[spanning tree]
      - 用 inference rule 來表示找支撐樹的算法
      - 考慮狀態的變化就知道如何建模了
        前提 是有一個聯通圖
        結論 是它的支撐樹
        最好通過 給圖的點和邊染色 來找到這個支撐樹
        染色會覆蓋[消耗]之前的顏色
      - 這裏所需要的 推演規則 如下
        (node x t) (node y g) (edge x y g)
        ----------------------------------
        (node x t) (node y t) (edge x y t)
        當然還需要個初始點 才能開始算法
      - 可以利用尋找 不變性 的方法
        來觀察算法本身的性質
      - 有對資源的消耗 就有 linear logic
        之所以要強調這種消耗
        是爲了讓機器自動尋找證明的時候
        能夠很容易獲得某次搜索的 終止條件
        很多限制都是爲了這個 終止條件 而設的

***** >< 更多的例子
      - 還有 圖論中的 其他很多有趣的例子
        有可能以這種方式來使用推演規則來建立模型
        尋找這些模型也是有趣的事情

*** 包含邏輯連詞的 推演規則的例子

***** if wishes were horses, beggars would ride
      - 這裏 were 是虛擬語氣
      - 可以注意到
        這裏所使用的某些謂詞其實是類型
        所以 比如
        (wish x)
        也可以寫爲
        x : <wish>
        而類型時間的包含關係
        就可以用一個簡單的 inference rule 來表示
        (wish x)
        --------- wish->horse
        (horse x)
        或者表示爲
        wish->horse : ((wish x) -> (horse x))
        [注意 在實現時 這涉及到偏序關係與 pattern match]
      - 此時對上一句話的建模可以是
        ((wish x) -> (horse x)) (beggar y)
        ---------------------------
        (horse z) (ride y z) for some z
        論點是
        此時單純的推演規則是不夠的
        需要邏輯連詞還有量詞
        1. 首先
           如果把 -> 理解爲二元謂詞[中綴表達式]
           那麼上面是第一次需要將 謂詞 嵌套到 謂詞 中
        2. 其次
           還有一句 非形式化的 "for some z"

***** 則式[sequent] 與 邏輯連詞
      - 這裏 pfenning 引入了 sequent calculus 中的 則號
        而放棄了 用分數線 表示 則號
        the pfenning uses the turnstile
        and give up on fraction bar
        其實使用分數線就行了
        論點是
        引入 則式
        是爲了敘述 lolipop 的引入律[右律]
        當統一 lolipop 與 turnstile 之後
        這個律其實是 多元函數的一元化[curry]
      - 引入 積 的論點是
        lolipop 只是二元函數
        但是我們需要 其前提和結論有多個元素
        其實
        用參數棧就能解決這一點
      - 由上面兩條可見
        這裏的很多形式語法其實都是沒有必要的
        也就是說 在棧的幫助下
        1. inference rule 中的分數線
        2. 線性蘊含[lolipop]
        3. sequent 中的 turnstile
        都將被認爲有相同的語義
        而給以兩種符號表示
        一種是 ->
        一種是 分數線
        但是
        要知道 有各種類型的 蘊含詞 lolipop 只是其中之一
        也就是說
        這些東西既然有細節上的區別
        就不可能都被合而爲 ->
        也許可以把所合得的 -> 當成是底層語義
        在其基礎上構建各種類型的 蘊含詞
      - 這些處理方式
        可以說是
        因爲 不願意仔細觀察類似性
        而 過早分離語義
        即 發現相似性的東西的區別的時候
        不去吧相似的部分抽象出來
        而是去形成不同的處理方式
        我稱這種現象爲 過早分離現象
        比如
        girard 對兩種 積 的分離 就是如此
      - 但是 pfenning 從前面的單純的 推演規則
        一步一步引入 則式 連詞 量詞
        這還是很值得學習的

***** >< 金融產品中 你可以購買某個交易 儘管購買行爲本身就是交易

*** >< 函數複合的優越性
    - 就對證明的搜索而言
      1. 古典邏輯的推演規則 [非 resource 的]
         是在語法所生成的圖中找 path
      2. linear logic [stack 和 函數複合]
         也可以被理解爲找 path
         但是 用變化和 stack 來理解 則更經濟
      後者的搜索可以因爲沒法再作用任何推演規則而停止 ><><><英文術語
      而前者只能因爲有限集被遍歷完全而停止 ><><><英文術語
      前者是帶有目的的搜索[帶有條件的搜索]
      後者是不能帶有目的的 因爲它的停機條件不可能依賴與目的
      - 哦
        可以發現
        這種搜索之所以可能
        就是因爲
        後綴表達式 還有 函數複合 所形成的語法的純粹線性性
      可以發現 重要的性質是你所選取出來的 primitive-function 的集合必須具有這種性質
      使得 停機條件可以達到
      這就可以被理解爲 refactoring
      比如以找零錢爲例子 很容易就得到兩個 primitive-function 相互循環
      - 這裏已經可以找到 遊戲理論 的影子了
        敘述已經看起很像是遊戲了
      - 注意搜索性的匹配需要忽略順序
        這就涉及到與有限置換羣有關的編程
    - pfenning 對收斂的唯一性[合流][confluent][計算停止之後所能達到的結果是唯一的] 的理解是不對的
      因爲
      在 lambda calculus 中
      計算是對 lambda term 的化簡
      那與這裏的搜索問題很不相同

*** >< 計算與證明的衝突
    - 當需要證明與自然數有關的定理的時候
      常常 add1 來定義所有自然數

*** >< 推演規則 與 謂詞
    - 謂詞是特殊的函數
      所以與類似函數 我可以說
      用推演規則來定義的謂詞 是 抽象的謂詞
      推演規則猶如抽象數學結構中的公理
    - 特殊性在於
      ><><><
    - 一筆畫的例子
      ><><><

*** 類型系統的意義
    - 類型系統限制函數的複合方式
      也就是說
      類型不單單是對函數的分類
      分類之外還一定要有別的規則才能得用
    - 無類型的 lambda-calculus 和 pi-calculus
      可以用來編碼有類型版本的演算中的各種東西
      這些東西
      在後者中是 primitive
      而在前者中是 non-primitive

* ><>< 對比 新語法 舊語法 描述 局部和諧性時

*** note
    * linear logic
      |-----+-----+-----+-----|
      |     | add | mul | exp |
      |-----+-----+-----+-----|
      | pos | ⊕ 0 | ⊗ 1 | !   |
      | neg |     |     | ?   |
      |-----+-----+-----+-----|
    * 其他連詞概覽
      ⅋
      ∧
      ⊤
      ∨
      ⊥
      ⊸
      ⊥
      ⊢
    * harmony is about inverse
      id & cut are two orders of inverse
    * or I should say
      two structures of inverse for
      if certain structure [combination] of the primitive-functions is build up
      then one can eliminate the whole structure
      and the structure is not always linear
      while one for linear structure
      one can say right-inverse & left-inverse
    * such inverse may be used to optimize code at compile time
      but I do not know how useful it actually would be

*** id & cut

***** old notation
      * id intro
        <empty>
        ------- id(A)
        A ⊢ A
      * cut rule
        Δ ⊢ A
        Δ', A ⊢ C
        --------- cut(A)
        Δ, Δ' ⊢ C

***** new notation
      * id : do nothing
        cut : function composition
        or
        t : (Δ -> A)
        n : (Δ' A -> C)
        --------------- cut(A)
        swap t n :
        (Δ Δ' -> C)

*** linear implication

***** old notation
      * ⊸ [lolipop]
      * right
        Δ, A ⊢ B
        --------- ⊸ R
        Δ ⊢ A ⊸ B
      * left
        Δ1 ⊢ A
        Δ2, B ⊢ C
        ------------------- ⊸ L
        Δ1, Δ2, A ⊸ B ⊢ C

***** function
      * apply : (A (A -> B) -> B)
        but [ ] is out of this kind of postfix notation

***** new notation
      * right
        t : (A -> B)
        -------------------
        [t] : (-> (A -> B))
      * or
        I can use curry
        which matchs the old right rule
        t : (Δ A -> B)
        ----------------------
        [t] : (-> (Δ A -> B))
        -------------------------
        >:x [:x swap [t] apply] :
        (Δ -> (A -> B))
      * left
        t : (Δ1 -> A)
        n : (Δ2 B -> C)
        ------------------------
        xswapxx t swap apply n :
        (Δ1 Δ2 (A -> B) -> C)
      * the left rule is not complete
        for swap can be used freely

***** harmony

******* id expansion
        * id(A) : (A -> A)
          id(B) : (B -> B)
          -----------------------------
          swap id(A) swap apply id(B) :
          (A (A -> B) -> B))
          ------------------------
          id(A) swap apply id(B) :
          ((A -> B) A -> B))
          -----------------------------
          >:x
          [:x swap
           [id(A) swap apply id(B)]
           apply] :
          ((A -> B) -> (A -> B))
        * I can say
          >:x [:x swap [swap apply] apply] = do nothing
          note that
          the type of the data in the stack matters
          thus
          I better say
          >:x [:x swap [swap apply] apply] apply
          =
          >:x :x swap [swap apply] apply
          =
          >:x :x swap swap apply
          =
          >:x :x apply
          =
          apply

******* cut reduction
        1. t : (Δ1 A -> B)
           -------------------------------------------
           >:x [:x swap [t] apply] : (Δ1 -> (A -> B))
        2. n : (Δ2 -> A)
           m : (Δ3 B -> C)
           -----------------------------------------------
           xswapxx n swap apply m : (Δ2 Δ3 (A -> B) -> C)
        3. >:x [:x swap [t] apply] : (Δ1 -> (A -> B))
           xswapxx n swap apply m : (Δ2 Δ3 (A -> B) -> C)
           -----------------------------------------------
           xswapxx
           >:x [:x swap [t] apply]
           xswapxx n swap apply m :
           (Δ1 Δ2 Δ3 -> C)
        then
        1. n : (Δ2 -> A)
           t : (Δ1 A -> B)
           --------------------
           n t : (Δ1 Δ2 -> B)
        2. n t : (Δ1 Δ2 -> B)
           m : (Δ3 B -> C)
           ---------------
           xxswapx n t m :
           (Δ1 Δ2 Δ3 -> C)
        thus
        * I can say
          xswapxx
          >:x [:x swap [t] apply]
          xswapxx n swap apply m
          =
          xxswapx n t m
          now
          it is already hard to see
          how these two are equal

*** and version 1 [pos-mul]

***** old notation
      * ⊗ [tensor] [simultaneous conjunction]
      * right
        Δ1 ⊢ A
        Δ2 ⊢ B
        -------------- ⊗ R
        Δ1, Δ2 ⊢ A ⊗ B
      * left
        Δ, A, B ⊢ C
        ------------ ⊗ L
        Δ, A ⊗ B ⊢ C

***** function
      * pair : (A B -> (A ⊗ B))
        dair : ((A ⊗ B) -> A B)

***** new notation
      * right
        t : (Δ1 -> A)
        n : (Δ2 -> B)
        --------------------
        n swap t swap pair :
        (Δ1 Δ2 -> (A ⊗ B))
      * left
        t : (Δ A B -> C)
        ----------------
        dair t :
        (Δ (A ⊗ B) -> C)

***** harmony

******* id expansion
        * id(A) : (A -> A)
          id(B) : (B -> B)
          ----------------------------
          id(B) swap id(A) swap pair :
          (A B -> (A ⊗ B))
          ---------------------------------
          dair id(B) swap id(A) swap pair :
          ((A ⊗ B) -> (A ⊗ B))
        * I can say
          id(A ⊗ B) => dair id(B) swap id(A) swap pair
          or
          dair swap swap pair = do nothing

******* cut reduction
        1. t : (Δ1 -> A)
           n : (Δ2 -> B)
           ---------------------------------------
           n swap t swap pair : (Δ1 Δ2 -> (A ⊗ B))
        2. m : (Δ3 A B -> C)
           --------------------------
           dair m : (Δ3 (A ⊗ B) -> C)
        3. n swap t swap pair : (Δ1 Δ2 -> (A ⊗ B))
           dair m : (Δ3 (A ⊗ B) -> C)
           --------------------------
           xxswapx
           n swap t swap pair
           dair m :
           (Δ1 Δ2 Δ3 -> C)
        then
        1. t : (Δ1 -> A)
           m : (Δ3 A B -> C)
           ---------------------------------
           xswapxx t swap m : (Δ1 Δ3 B -> C)
        2. n : (Δ2 -> B)
           xswapxx t swap m : (Δ1 Δ3 B -> C)
           ---------------------------------
           swap n
           xswapxx t swap m :
           (Δ1 Δ2 Δ3 -> C)
        thus
        * I can say
          xxswapx
          n swap t swap pair
          dair m
          =
          swap n
          xswapxx t swap m
        * actually
          | xxswapx n swap | t swap | pair dair | m |
          | swap n xswapxx | t swap |           | m |

*** and version 2

***** old notation
      * & [with]
      * right
        Δ ⊢ A
        Δ ⊢ B
        ---------- & L
        Δ ⊢ A & B
      * left1
        Δ, A ⊢ C
        ------------- & R
        Δ, A & B ⊢ C
      * left2
        Δ, B ⊢ C
        ------------- & R
        Δ, A & B ⊢ C

***** not function but pattern match
      * these two inference rules are captured by pattern match
        but not by function
        just as pos-mul can be captured by stack

***** new notation
      * right
        (Δ -> A)
        (Δ -> B)
        ---------------
        (Δ -> (A & B))
      * left1
        (Δ A -> C)
        -----------------
        (Δ (A & B) -> C)
      * left2
        (Δ B -> C)
        -----------------
        (Δ (A & B) -> C)

*** or version 1

***** >< old notation
      * ⊕
      * right
      * left

***** new notation
      * right1
        (Δ -> A)
        --------------
        (Δ -> (A ⊕ B))
      * right2
        (Δ -> B)
        --------------
        (Δ -> (A ⊕ B))
      * left
        (Δ A -> C) (Δ B -> C)
        -----------------------
        (Δ (A ⊕ B) -> C)

*** >< or version 2

***** old notation

***** new notation

*** >< 語義差異
    * 這裏 pfenning 的很多處理方式
      都是爲了以 併發計算 爲 linear logic 的語義
      而設計的
      爲了獲得希望的計算模型 pfenning 實際上設計了自己的邏輯系統
    * 這種地方 就是我需要與 pfenning 產生分歧的地方
      但是要注意
      每次拋棄 pfenning 的處理方法時
      我一聽要給出更好的處理方法

* 證明論

*** 教學法 [受 herbrand 啓發]
    * 介紹理論的時候
      切入點可以是 model theory
      即 所有的 inference rule
      都是爲了以 更簡單的方式
      判斷 bool 代數中 某個式子 是否爲 恆真式
      最笨的檢驗 恆真式 的方式是使用真值表
      而 inference rule 能給出更高效的判別方法
    * 注意 這只是一種理解方式而已

* >< 併發[concurrent]

*** 新記
    * 同樣的邏輯
      如果 term 對應整個 sequent 就得到 蟬語語義
      如果 term 對應 sequent 個部分的數據 就得到 併發語義
    * 對 sequent 部分的命名對於 併發來說是必要的
      因爲 此時函數的作用不能依賴於參數在棧中的順序
    * 另外 單單命名是不夠的
      每個函數還要有自己的棧
      不能只有一個 共用的 參數棧
      因爲順序不重要的
      所以應該說是 隊列
      即 進程[process]
      每個函數可以形成多個進程
    * 傳輸的東西不光是數據
      必須包含數據應該如何傳輸
      即 信道[channel]
      函數 之 參數傳入 返回值傳出
      都利用信道進行
    * 進程管理算法 必須考慮到 信道
    * 蟬語 和 併發
      之所以都以 linear logic 或 sequent calculus 爲類型系統
      是因爲 其二者 都適合用 函數複合 來描述變化
    * 每個 function 都可以用來生成 process
      生成的時候 可以使用某些技巧
      這樣就獲得了很有趣的靈活性
    * 信道的限制
      就使得 當我要求某個服務時
      不是所有人提供的這個服務我都使用
      而是 只使用某種信道傳遞過來的這種服務
      類型就是服務的類型
      而具體的服務需要更具體的計算模型才能描述
    * cut 中被 cut 掉的部分
      就是指明 有必要按照順序做的部分
      在 pi-calculus 中這對應於 (new x) (P | Q)
    * 需要命名的地方
      其實是需要用 線性的標記語言 來畫出這些結構
      直接使用二維的圖形來表示 這些結構
      幾乎是唯一的可以接受的語法
      ><><><
      我將先嘗試用圖來畫

*** old

***** 記
      1. inner 解釋器在對函數體做解釋的時候
         可以利用消息傳遞的等待的語義
         把計算分配到不同的處理器上
         一個問題是 等待消息並處理消息的基本單元是 進程
         進程應該如何來實現 ?
      2. 共享某些內存
         此時需要這些內存中的數據具有某種穩定性
      3. 完全不共享內存
         這是不可能的
         比如 我要實現優有向圖處理語言
         有很多函數分工處理有向圖
         如果每次參數傳遞的時候都複製整個有向圖
         那麼計算的時間就都耗費在複製參數上面了
      4. 這基本上說明了
         如果要求語法的一致性[以進行自動的並行化]
         那麼 實現策略 必須是
         在底層實現算法來處理各種情況
      5. 我應該把並行計算的東西放在之後再設計
         因爲 不論是就 有向圖處理 還是就 並行計算 而言
         我的經驗都太少了

***** 模型
      1. 設每個函數都是一個獨立的機器 ???
         優自己的堆 ??

***** 並行計算
      1. 進程 的特點是 它有自己的棧和堆
         設計上優兩種
         1) 所有的函數都是進程
            所要達到的效果是
            使得一個類似數據分配器的計算分配器
            能夠得以實現
            以在多核時不必讓程序員去管理計算的分配
            這樣就破壞了用棧做參數傳遞的傳統
         2) 進程是函數的集合
      2. 計算分配器 需要完成的任務是什麼 ?
         它像是一個信使
         首先
         可能不是爲了
         把計算任務分配給地球另一邊的一個計算機
         然後在計算之後再收回結算結構
         [儘管這樣是可能的]
         計算分配器 的主要使用場合是
         多核的電腦
         整個電腦整個還被看成是一個整體
         計算分配器 需要把整個電腦的很多處理器的算能力分配出來
         計算分配器 本身也必須佔用一個處理器
         以進行調度工作
         [可能不需要這樣 而去實現完全地對稱]
      3. 它必須能夠部分地模擬串行計算的效果
      4. 那麼
         計算分配器 維護一個列表
         它不停的掃描整個列表
         ><
      5. 把消息傳遞出去之後
         可以等待 被傳遞處的返回
         也可以不等

***** pi-calculus
      點之間有一條邊相連時
      它們之間就可以用這條來傳遞信息
      ><><>< 在digrap中如何理解這一點
      ---------------------------------------
      lambda-cal可以被看成是
      在用一種形式語言來描述某種類型的有向圖
      pi-cal更明顯地也可以看成是如此
      ---------------------------------------
      input port & output port
      of the so called agent
      ---------------------------------------
      比如考慮對一個lambda-term的reduce
      顯然我可以把reduction的不同部分的工作分配給不同的cpu
      然後當全算玩之後把結果返回給我
      好讓我作最後的處理以返回最終結果
      ---------------------------------------
      output & input actions
      ---------------------------------------
      有很多的``functional-computer''
      必須能以明顯地控制參數在它們之間的傳遞方式
      讓機器a計算F這個函數
      讓它從機器b和機器c那裏拿參數
      讓它把返回值返回到機器d
      在這個過程中
      機器bc對兩個參數的計算可以是同時進行的
      而機器a必須等待兩個參數都到齊
      參數的傳遞是通過輸入輸出設備來完成的
      ---------------------------------------
      每個機器都有一個獨立的棧
      一個機器可以用自己的棧進行計算
      也可以pop和push 各種port棧
      必須處理``等待''的問題
      即``算好了''這條信息的傳遞的問題

***** 有生命的程序 與 並行計算
      * 生命的特點如下
      * body
        即函數體
      * 新陳代謝[metabolism]
        如果每個函數都有自己的堆和棧的話
        那麼其垃圾回收器[數據分配器]之作用
        就像是機器的新陳代謝
        如果嘗試構建類似生物的程序的話
        對內存的消耗就是對主要資源的消耗
      * 前兩個特點的功能是
        movement & replication
      * 遺傳信息[inheritable infomation]
        每個函數作爲有向圖
        其形態中有固定不變的主要部分
        並且有信息幫助初始化一個與其相似的有向圖
      * 加上這個特點
        就能夠遺傳和變異
      * 但是
        自然選擇所對應的是什麼
      * 所以
        把每個函數都做成一個有獨立時間和空間的進程
        是能夠形成很豐富語義的
        爲了分配時間 也許只要找出好的算法就行了
      * 並且
        如果放棄在每個函數中對新陳代謝的模擬
        讓每個函數的都以全局的鏈表爲自己的數據部分
        那麼就差不多有個模型了
      * 然而
        函數調用的實現方式呢
        如果純粹使用消息傳遞
        那麼參數棧就沒有了
        計算的順序也沒有了
        必須有以維持順序的機制
        線程系統的解釋器和它的 參數棧 和 返回棧
        就作爲一個調度性的協調系統了
        這是可以想像的
        因爲內部解釋器本身利用返回棧來記錄計算位置的方式
        本來就是一種調度
      * 也就是說
        線程碼解釋器本身的地位與其他的函數平等了
        但是
        每個函數都在不停地
        與線程碼解釋器 之間傳遞信息
        這是不合理的
        應該把 線程碼解釋器 的功能內化到每個函數中
        [既然每個函數都被視爲一個有獨立計算能力的機器了]
        每個函數都有用鏈表實現的棧 就行了
        在每個函數體內調用了別的函數的時候
        就是給別的函數傳遞了消息並且等待消息返回
        這樣計算的狀態的編碼就被分散到了各個函數內部
        而不再需要返回棧了 [也沒法實現 call/cc 了]
      * 這種模型能夠適應在 組合子問答集 中
        所發展起來的語義和語法嗎
        要知道
        對計算順序的明指
        在這裏就體現爲
        對返回信息的等待的明指
        而 A (F) (G)
        就是語言的用戶接口[REPL]
        在形成一個消息 A
        然後把這個消息傳遞給函數 F
        返回的消息可以
        1. 返回到 REPL
           然後再順次處理
        2. 在 REPL 把消息 A 傳遞給 F 的時候
           告訴 F 當計算完成之後把結果返回給 G
           並且 G 還必須知道計算完之後
           結果要最終返回給 REPL
           也就是說整個函數
           都必須編碼在這個函數提所傳遞的參數中
           這是不合理的
        3. REPL 在給 F 傳遞參數的同時
           告訴 G 如果接受到 F 傳來的信息
           那麼對這個信息的計算結果應該返回給 REPL
           這樣每個函數每次所計算的參數上
           就都帶有[固定大小的]信息
           比如 A 上帶有 [來自: REPL 目的地:G]
           並且每次作用都必須有不同的標籤 以被識別
      * 這些都是可以想像的
        但是我還是先以單線程爲主來實現我的語言
        我想以後再去考慮多線程的版本也不難

* 蟬語的邏輯

*** 靈蓋來源
    | 計算語義 | forth                           |
    | 對應關係 | cut of type 與 function compose |
    | 依賴性   | 用任意和存在來定義函數          |

*** 野心
    * 形成新的風格
      而不是新的具體體系
    * stack 之引入 脫離了 代數化的數學結構的風格

*** 特點

***** 逆
      * 並不是所有的函數都有逆

***** inference rule 與 polymorphic
      * 之前用 inference rule 表示的東西
        我都可以用帶有 polymorphic 和 dependent 類型的 term 表示
        這樣就方便了敘述
        比如
        inference rule 中的 structural rule
        就對應於 帶有 polymorphic 的 term

***** 底層語義的實用性
      * 爲了活得良好的語義 以描述一筆劃問題
        就不能亂用 drop
      * 底層的語義就是對有序的棧中元素的操作
        改變等價關係
        比如 可以隨便用置換 可以隨便用 drop 等等
        就可以獲得較爲高級的語義
      * 底層語義的實用性在於
        它使得我們很容易描述
        1. 各種高級語義是經過何種等價關係而活得的
        2. 各種高級語義之間的關係
      * 比如
        基本的語義外加如下等價關係會得到各種邏輯
        1. 線性
           隨便置換
        1. 直覺
           隨便 drop dup
           不可返回多個值
        1. 古典
           可以返回多個值

*** 和諧性如何在底層理解
    * 底層和諧性 的範疇論語義如何理解
      apply 之類的 函數可逆嘛 ?
    * 局部和諧性
      * 對大的東西的 identity 可以被擴張成原子性的 identity
      * 對大的東西的 cut[函數複合] 可以被分解成對其部分的 cut
        這對應於 看大的 cut 所複合的兩個函數的函數體
        然後 用 refactoring 來優化
    * 全局和諧性
      ><><><
    * 可以發現在 natural deduction 中
      和諧性 關於 函數作用
      而在 linear logic[sequent calculus] 中
      和諧性 關於 函數複合
      [因爲這些是 核心語義]
      後者的局部 reduction 是編譯時期的優化
      即 找出可以避免的計算

*** >< pfenning 不知道 forth
    * pfenning 說 truth is ephemeral[朝生暮死]
      並舉例來說 在 linear logic 中
      一個 A 被做爲 resource 而使用之後就不再有 A 可以使用了
      棧中有 A 則 A 爲真
      A -> B 作用之後則 A 不再真
      這種 ephemeral 是看位置[是否在棧中]
      而還有一種 ephemeral 是看時間
    * pfenning 提到如下值得注意的一點
      既然真是朝生暮死的 那麼假也是朝生暮死的
      這樣 就很有可能同時證明一個命題的真和假 而得到矛盾
      因此在這裏邏輯中引入 否定詞 的時候 要非常小心
    * ephemeral 與否
      可用程序語言中常見的對變元的分類來描述
      1. 無名局部變元
         參數棧 中的數學
      2. 有名局部變元
      3. 無名全局變元
         其他棧 中的東西
         注意
         某些棧可以是臨時設置的 這樣分類就要更複雜了
      4. 有名全局變元
    * pfenning 不知道 在 forth 中
      linear logic 中的命題如何可以被看成是函數的類型
      但是 pfenning 熟悉 natural deduction 中的處理方式
      所以不是把 A -> B 當作一個 term 的類型 [命名]
      而是當作多個 term 的類型
      [命名到結構的細節部分 因而可能能夠做更細緻的處理]
    * 在 cicada-language 中
      ephemeral[朝生暮死] 的數據 是 無名局部變元
      非 ephemeral 的數據 是 有名局部變元
      有名局部變元 可以被使用多次
      但是函數退出的時候 如果不明指要返回他們的話
      對這些數據的引用就丟失了
    * 非 ephemeral 的數據
      也可以被認爲是全局的有名變元
    * 而在 pfenning 所給出的語義 與 蟬語語義的對比
      |----------------------------+--------------------------------|
      | term 以整個 sequent 爲類型 | term 以 sequent 的部分爲類型   |
      |----------------------------+--------------------------------|
      | sequent 中的是無名數據類型 | sequent 中的是有名服務類型     |
      |                            | 被名所區分的各個元素被稱作信道 |
      |----------------------------+--------------------------------|
      | cut 對應於函數複合         |                                |
      |----------------------------+--------------------------------|

*** >< 對於蟬語來說也許應該有新的邏輯而不能用 linear logic
    * 觀察到 linear logic 的對稱連詞在蟬語中很難解釋
      而 據說 linear logic 已經被成功指配爲 concurrent 的類型系統了
    * 儘管如此 蟬語 的邏輯將與 linear logic 很相似
      concurrent 與蟬語的關係也將很有趣
    * 一個邏輯的計算語義不只一種

*** >< 線性邏輯中複雜的連詞是如何活得並行計算的解釋的
    * 可能
      使用的時候只要服務的類型匹配了就行
      是那個進程提供了某個[某類]服務並不重要

*** 邏輯的分類
    * 古典 [truth]
      就模型而言的完備性強 能證明的東西多
      實際的連接詞少
      只有 "且" "否"
      此時對命題的變形非常靈活
      其他連接詞可以劃歸到上面兩個
    * 直覺 [proof]
      就模型而言的完備性弱 能證明的東西少
      實際的連接詞多
      有 "且" "否" "或" "則"
    * 線性 [resources]
      就模型而言的完備性更弱
      以 stack 而言
      drop dup 之類的都被理解爲邏輯連詞了
    * 其實所說的表達能力更強就是 區分更多操作 的意思
      也就是說這裏的分類 所分的其實是不同的 primitive-function 的集合

*** 計算模型的邏輯解釋
    * 在 cicada-language 的計算模型中
      還有很多的東西可以活得有趣的邏輯解釋
    * 就像在 cicada-language 中我可以重新實現 lambda-calculus 一樣
      在 linear-logic 中可以重新實現 直覺主義邏輯

*** >< substructure logic 中一定存在某種邏輯可以以蟬語爲計算模型

*** polymorphic 與 dependent
    * 多態[polymorphic]
      函數體所編碼的算法可以重用於不同類型的參數
    * 依賴[dependent]
      可以通過把 type 做爲參數傳遞
      來達到 強於 polymorphic 的效果
      因爲 傳遞來的做爲參數的 type
      可以用來把算法 分配到 作用與不同類型參數的子算法
    * 但是
      用 dependent 來獲得 polymorphic 的效果
      其語法非常繁瑣

*** program as type
    * 關於兩個 formal system 的融合
      其功效在於
      1. 通過編輯 term 來找證明
      2. 通過 -b-> 來簡化已有證明
      3. term 對 proof 的記錄 揭示了
         在類型空間中對 可證性 所定義的一元謂詞的判斷
         其實是在 term 的空間中對 term 的 生成
      4. 然而 dependent type
         可以用於 破壞 term 與 type 兩個空間的邊界
         [然而說 "兩個空間" 本身也是一種分類 即 type]
    * term 做爲記錄方式
      來展示 type 的空間中的謂詞的生成性
      記錄的時候 當然要把信息 "包" 進來
      而 信息以 term 爲媒介的傳遞與轉化 就是 計算

*** 相對性原理
    * 沒有絕對的素性[primitive]

*** 則式之吃 & 切
    * 或 可吃 其部分
      無依賴 可吃 有依賴
    * 切[cut]
      [與 gentzen 的原始語義不同]
      to cut
      is
      to match pattern of sentence
      and to disassemble[cut] the sentence
      and to reassemble the sentence
      [recorded by concatenate terms]

*** 函數的等詞
    * 最重要的數據類型函數的等詞是什麼
      沒有等詞邪
      所有關於函數的性質都由類型系統給出邪
    * 對 函數體 的任意處理
      會如何影響 等詞 還有 其他關於函數的謂詞 的性質

*** 證明語義 與 計算語義
    * 遺忘有相同類型的不同函數
      而只知類型 只處理類型
      就從 計算語義 轉化到了 證明語義
    * 計算語義 比 證明語義 等詞更細緻[更底層]

*** cut elimination
    * cut elimination 而化證明爲 "信息不減式"
    * 把對證明的記錄
      轉寫成 更易於使用歸納法 的形式
      而 將用 歸納法 證明的
      是形式體系的一般性質
    * 所以
      cut elimination 和 sequent calculus
      都是 爲證明形式系統一般性質而提出的 "策略性理論"

*** >< dijkstra 的啓示
    * 變形 有時是 弱化[->] 有時是 等價[<->]
      如何區別
    * 上面只是對 <-> 這個等詞而言
      處理其他等詞的 等價 或 弱化
      必須臨時切換語法



* >< constructivism [dijkstra & bishop]

*** >< 新語法
    * 新語法的特點是
      1. 每個命題都帶有 ->
         可以理解爲分數線
      2. 消去否定詞
      3. 所有的 inference rule
         都用分數的運算規則來表示
    * 所有的命題都是蘊含式
      其表示方式有兩種
      首先 箭頭
      (A -> B)
      其次 分數
      | A |
      |---|
      | B |
      對推演規則的表達可以用表格來寫
      比如
    * cut [product 的特殊形式]
      即同分子分母的消去
      | A | B | cut | A |
      |---+---+-----+---|
      | B | C |     | C |
    * curry & apply
      這裏與同形式的分數變換不同
      分子移下去以形成嵌套的分母時 還是做爲分子
      | A | curry |          |
      |---+-------+----------|
      | B | apply | (A -> B) |
    * imply 的語義
      如果有對 (-> A) 的構造
      那麼把這個構造轉化爲對 (-> B) 的構造的算法 就是對 (A -> B) 的構造
      imply [product 的特殊形式]
      |   | A | imply |   |
      |---+---+-------+---|
      | A | B |       | B |
    * conjunction-right [product 的特殊形式]
      |   |   | conjunction-right |     |
      |---+---+-------------------+-----|
      | A | B |                   | A B |
      in another way
      | C | D | conjunction-right | C D |
      |---+---+-------------------+-----|
      | A | B |                   | A B |
    * conjunction-left [drop]
      | A | conjunction-left | A B |
      |---+------------------+-----|
      |   |                  |     |
      or
      | B | conjunction-left | A B |
      |---+------------------+-----|
      |   |                  |     |
    * sum-left
      注意這裏的規則如何與一般的分式相加不同
      也就是說
      類型的運算規則
      只有 product 在形式上與分式的算數運算規則相同
      | A | B | sum-left | (A + B) |
      |---+---+----------+---------|
      |   |   |          |         |
      in another way
      | A | B | sum-left | (A + B) |
      |---+---+----------+---------|
      | C | D |          | (C + D) |
    * sum-right
      |   | sum-right |         |
      |---+-----------+---------|
      | A |           | (A + B) |
      or
      |   | sum-right |         |
      |---+-----------+---------|
      | B |           | (A + B) |
      即
      有對 (-> A) 的構造 就有對 (-> (A + B)) 的構造
      有對 (-> B) 的構造 就有對 (-> (A + B)) 的構造
      而古典的邏輯
      允許在證明 (-> (A + B)) 的時候根本不用構造 (-> A) 或 (-> A)
    * De Morgan's laws
      這裏涉及到 否定消除
      即 否定必須出現在最外層 並且用 conjunction 相連
      (否 (A 且 B))
      對應於
      | A B |
      |-----|
      |     |
      De Morgan's laws 沒法用 分式的推演規則表達
      如果能夠自由的使用 De Morgan's laws
      那麼
      命題演算中所有命題就能化爲可用分式表達的形式
      也就是說 分式的形式化能力是有限的
      把一個式子化爲 分式 已經是一次變化了
      這種解釋 否定 的方式是有問題的
      要知道
      一般人們定義 A 的 否定 的方式是 (A -> (0 = 1))
    * drop 之 存在 並不代表 能證明任何命題的否定
      因爲 drop 是個變換規則
      每個 變換規則 本身 也有類型 (... ->)
      但是
      drop 的類型對應的命題並不影響形式系統的一致性
    * pattern match
      match 與否
      決定了 product 的可行性
      一般的 product 是不交換的 考慮 cut 就知道了
      | A | (B + C) | product | A |
      |---+---------+---------+---|
      | B | D       |         | D |
      match 與否 被一個序關係決定
      在這個序關係中 (B + C) 高於 B
      所以
      就可以用 分子中的 (B + C)
      消除 分母中的 B
    * 否定消去
      其動機在於
      在古典的命題演算中 (A -> B) 等價於 ((not A) or B)
      但是若如我所言 否定不能直接爲 or 所連
      那麼這裏的動機就失效了
      這種對等也許必定是不合適的
      (not (A -> B))
      (not ((not A) or B))
      ((not (not A)) and (not B))
      (A and (not B))
      ((not B) and A)
      而
      (A -> (not B))
      ((not A) or (not B))
      (not (A and B))
      ???
      (A B ->)

*** >< 無限
    * 人們想像無限之物
      但是描述這些想像時所用語言確實有限的
      1. 無窮級數
         雖然有無窮多項
         然而項有規律可循
         所以用有限的語言就能指明這無窮多的項是那些
      2. 連續的幾何體
         雖然形態萬變
         但是有等價關係用以捕捉這些變化
         在某種等價關係的意義之下
         我們對其形態的分類定理又表明
         這些形態之本實爲有窮
      3. 實數中
         實際用於計算的
         都是以有限的方式就能構造出來的數

*** >< principle of omniscience
    * ((a : A -> (P a)) or (-> b : A (not P b)))

* 新構造主義

*** 數學
    * 沒有豐富模型的形式系統爲無益
      相關的形式理論讀來也索然無味

*** 具體數學結構
    * 具體數學結構 集合 類型 爲近義詞
    * 抽象 與 具體 有別
      1. 抽象數學結構
         用公理定義 公理描述結構中關係的性質
         比如羣
         範疇論 專門研究抽象數學結構之間的關係
      2. 具體數學結構
         由具體的表示定義
         比如某個有限單羣
    * 構造主義數學中 定義集合 步驟有二
      正如在程序語言中定義數據類型
      1. 首先 說明 如何構造集合中的元素
         正如 用已有的基礎數據類型 和 構造新類型的手段
         來構造新數據類型
         * 動態類型語言
           這裏將有一個謂詞來判斷
           某個元素是否屬於這個新定義的類型
           靜態類型語言
           不必有這種謂詞
         * 當需要定義一個新數據類型時
           可能有很多種實現方式 都能達到所需要的特性
           實現方式不同
           即 基礎類型 和 構造手段 之選取不同
           實現方式決定 底層操作[operation]
      2. 其次 說明 如何判別集合中的兩個元素之相等
         即 每定義一個數據類型時
         都要輔以等詞 才算定義完備
         保持等詞的變換稱 函數[function]
         * 當寫出一個 底層操作 後
           往往需要額外討論
           才能確信它保持等詞 而爲函數
    * 等詞分層次
      等詞之間的關係總是相對的
      用 底層的等詞 定義 高層的等詞
      就像是 用 素函數 定義 函數
      畢竟等詞本身就是函數

*** 結構化的無窮小分析
    * 比如對實屬這個類型的定義
      (-> x : (<number> -> <fraction>)
       (m n : <number> ->
              (n x m x sub abs
               1 n div 1 m div add
               less-then?)))
      ==
      (-> x : <real>)
    * 定義類系時 要同時定義等詞
      (-> x : <real>
          y : <real>
       (n : <number> ->
            (n x n y sub abs
             2 n div
             less-then?)))
      ==
      (-> x : <real>
          y : <real>
       (x y real:equal?))
    * 當 計算 在命題[類型]中 出現時
      它們只是代表 真實計算 的符號
      符號組合而成命題
      符號之出現 只爲討論符號所代表的計算的性質
      這種對符號的處理 在類型棧中進行
      而真實計算 在參數棧中進行

*** >< 謂詞
    * 上面對 等詞 的定義顯示
      等詞 的 函數體
      既用於計算 又用於形式處理
    * 定義謂詞的函數體
      既是命題
      又是函數
      這與通常的
      類型對命題
      函數對證明
      並不相同

*** 實數集上的函數
    * 按照 bishop 的方式
      一個實數 被實現爲一個函數
      實數集上的函數就成了函數到函數的映射
      這是不合理的
    * 實際上
      連續函數在有理點的值
      決定了其在實數集上的值
      * 這種函數是用處最廣的
        概率論 可能用到這個範圍之外的函數
        因爲那裏要用積分計算平均值
        而函數在某一點的值並不影響其平均值
    * 超越的常數
      應該由超越函數給出
    * 在推理中
      函數之間的關係才重要
      對函數的實際計算 與計算的效率 是另外一個層次的事情
    * 推理 對 函數之間關係
      計算 對 函數之實現方式
    * bishop 在處理實數時
      當給實數以構造性的定義之後
      就爲了推理的優雅
      而直接把 ><><><
      並沒有考慮到
      這些定義還可以爲了計算和推理效率而優化
      * 這裏所謂的 優化 如何理解
        改變處理方式之後
        整個理論看來更具有更造性和實用價值了
        但是這裏我潛意識裏裏使用的判斷標準是什麼

*** 更合適的基點
    * 只描述函數與函數之間的關係
      而重新獲得算數化的無窮小分析的表達能力
      同時獲得更好的計算語義

*** 相對否定
    * 否 不做爲一個一元邏輯連詞
      因爲它不具有構造性
    * 否定總是相對的
      如果一個命題蘊含了荒謬的命題
      那麼這個命題本身就是更荒謬的

*** 謂詞的幾何性質
    * 對於 形式體系 這種數學結構
      形式語法 生成有向圖
      而 謂詞 對應於 有向圖中 某種離散的幾何體
    * 最明顯的就是 等詞 對應於 無向路
    * 對於 其他類型的數學結構
      也可能有類似的對應

*** 參數棧 與 類型棧
    * 兩個棧是自然的選擇
      就像在通常的 具體數學結構 中一樣
      我們
      有時需要操作數學結構中的元素 以計算
      有時需要討論數學結構中的元素的類型 以證明一般性質
    * 通常 程序在運行時只用到了 參數棧
      而 類型棧 只用於編譯時期的類型檢查
      而 類型檢查 就是對具體結構中元素[函數]的一般性質的證明

*** >< 不同層次的等詞和關係 如何轉換  :難點:
    * 看 dijkstra

*** 雜

***** 意義
      * 關於 意義[meaning] 的形而上學
        有很多流派
        來源有二 [以函數爲例]
        * 宏觀
          函數之意義在於
          它與空間中所有其他函數的關係
          [關係是利用函數複合這個基本關係來表達的]
          形而上者
          一個詞的意義
          在於它如何在語言中被使用
        * 微觀
          函數之意義在於
          它具體對數據進行的操作
          形而下者
          界定一個詞意義的方式
          並不是窮盡它在語言中的所有使用方式
          而是使用巧妙的編碼與構造
      * 通過 參數棧 這個交換參數的市場
        只要給出了函數微觀意義 就獲得其宏觀意義
        宏觀意義 這個概念 是用靜態類型檢查實現的

***** general proof theory
      * 以 proof 爲自足的數學對象
        每每如此時
        只爲獲得認可而已
        只得弱化其用而已
      * 所謂 consequence vs. proofs 在於
        認爲
        古典的處理方式
        以 proofs 分析 consequence
        而不以 proofs 爲基本數學對象
        其實
        當用 則詞 來展示 consequence 時
        就沒有這種衝突了

***** 等詞
      * 兩個 proof 如何相等
        兩個 function 如何相等
        這些等詞的定義都很難處理
      * 當等詞難以處理時
        就感覺數學對象虛無縹緲
        難以把握 不像實體
      * 解決辦法是
        爲更易計算的等詞
        而優化模型[具體數學結構]

*** 避免過早代入數值
    * rational trigonometry 就是如此

*** 直覺與實用
    * 每個違背 直覺與實用 的概念與定理 都值得商榷

*** 對自然數集這個具體數學結構的觀察計劃
    * 語法方面 也許需要設計高度重載的記法
      語義方面 主要是對結構的擴展
      1. 擴張
         逆運算封閉
      2. 拓展
         序關係重新引入
    * 分析素數
      p-進數
      看看能否有新的啓發
    * 關於結構的擴展
      galois 理論
    * 結構的計算性
      初等函數的算數性質
      構造主義
      古典數值計算
    * 關於記法
      一般語言學
      可以以幾何的語法爲範例

*** dup
    * dup 類型棧中的一個則式
      就像是重複一次可重複的實驗一樣
    * intentional equality
      連個構造是否相同
      取決於人們的意願
