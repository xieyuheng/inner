#+title: proof theory

* [todo-stack]

  - one language can use different type systems,
    just as one proof style can be applied to different logics.

  - classical logic and logic programming

  - how different proof styles are correspond to each other ?

* judgment and inference rule

*** inference rules are formed about judgment

    - a type constructor is a judgment
      its data constructors are its inference rules
      - the type of the data constructor is the inference rule
      - the name of the data constructor is the name of the inference rule

    - inference rules can generate directed graph
      where judgment is node
      and inference is directed star in the graph

    - a proof is formed by an inference tree
      a function is a proof
      - the type of the function is the theorem to be proved
      - the body of the function record the inference tree

    - both inference rule and theorem are
      expressed in the form of arrow

*** judgment and predicate

    - a judgment reads like a predicate
      a predicate can be viewed as a set

    - a judgment can generate a predicate
      by searching its inference rules
      - the searching can be viewed as happening in
        the directed graph generated by inference rules

*** meta judgment

    - in the above we used ':' such as :
      type constructor : inference rule
      proof : theorem
      function : type

    - note that
      ':' itself is a name of a judgment !
      - thus if we want to write a type checker
        we can model ':' as a judgment
        just like an interpreter is a program

* plan

  - in sequent calculus style, I will show :
    1. the proof theory of intuitionistic logic
    2. why class logic is not constructive
    3. how to restrict semantics to get linear logic

  - no inductively defined type in this version.

  - no conj, because we have data stack.

  - no duality,
    because the dogma of duality
    is in conflict with the dogma of constructivism.

  - we *do* need disj,
    but literal disj is only used for types, not for values,
    because literal disj of values
    will introduce the concept of non-deterministic.

  - (+) is a type-constructor,
    and hypothetical object of this type
    will be used by (case)

  - objects of disj type can be returned,
    only because of different types are returned
    in different branches of a (case)

  - this is also true for arrow
    we use literal arrow for types,
    but not for values.

  - (->) is a type-constructor,
    and hypothetical object of this type
    will be used by 'apply' and 'compose'

* (1975) (gaisi takeuti) proof theory

*** chapter 1 first order predicate logic

*** chapter 2 peano arithmetic

*** chapter 3 second order systems and simple type theory

*** chapter 4 infinitary logic

*** chapter 5 consistency proofs

* (1998) (buss) an introduction to proof theory

*** proof theory of propositional logic

***** intro

      - propositional variable

      - propositional formula formed by a set of connectives

      - inputting true or false
        to a formula's variables,
        the formula can be viewed as a boolean function.

      - so defined formal language is *complete*,
        if every boolean function can be defined by a formula.

      - a propositional formula is a *tautology*
        or to be (classically) valid
        if its boolean function always return true.

      - a propositional formula is a *satisfiable*
        if its boolean function can return true.

      - if we want to decide whether a formula
        is a tautology,
        we can check if it returns true on all its input.
        this brute-force method is of O(n^2)

      - propositional proof systems provide better methods.

***** frege proof systems

******* one inference rule

        - modus ponens

        #+begin_src jojo
        :a : A, :f : (-> A -- B)
        --------------------------
        :a :f : B
        #+end_src

******* axiom schemes

        #+begin_src jojo
        (+fun * (-> :a1 : :P1 -- (-> :P2 -- :P1))
          {drop :a1})

        (+fun * (-> :f1 : (-> :P1 -- :P2)
                    :f2 : (-> :P1 -- (-> :P2 -- :P3))
                 -- (-> :P1 -- :P3))
          {dup :f1 swap :f2 apply})

        (+fun * (-> :P1 -- (+ :P1 :P2))
          nop)

        (+fun * (-> :P2 -- (+ :P1 :P2))
          nop)

        (+fun *
          (-> :f1 : (-> :P1 -- :P3)
              :f2 : (-> :P2 -- :P3)
           -- (-> (+ :P1 :P2) -- :P3))
          {(case dup
             :P1 :f1
             :P2 :f2)})

        (+fun * (-> :P1 :P2 -- :P1)
          drop)

        (+fun * (-> :P1 :P2 -- :P2)
          swap drop)

        (+fun * (-> :P1 :P2 -- :P1 :P2)
          nop)
        #+end_src

***** the propositional sequent calculus

******* inference rules

        #+begin_src jojo
        (-> X -- (+ Y A))
        (-> A X -- Y)
        ------------------------ cut
        (-> X -- Y)

        (-> A B X -- Y)
        ------------------------ conj-left
        (-> (* A B) X -- Y)

        (-> X -- (+ Y A))
        (-> X -- (+ Y B))
        ------------------------ conj-right
        (-> X -- (+ Y (* A B)))

        (-> A X -- Y)
        (-> B X -- Y)
        ------------------------ disj-left
        (-> (+ A B) X -- Y)

        (-> X -- (+ Y A B))
        ------------------------ disj-right
        (-> X -- (+ Y (+ A B)))

        (-> X -- (+ Y A))
        (-> B X -- Y)
        ------------------------ arrow-left
        (-> (-> A -- B) X -- Y)

        (-> A X -- (+ Y B))
        ------------------------ arrow-right
        (-> X -- Y (-> A -- B))
        #+end_src

******* one axiom scheme

        #+begin_src jojo
        (-> :A -- :A)
        #+end_src

***** propositional resolution refutations

*** proof theory of first-order logic

***** syntax and semantics

      #+begin_src jojo
      (-> :x : A -- :x B)
      [:x : A, :x B]
      #+end_src

***** hilbert-style proof systems

***** the first-order sequent calculus

******* inference rules

        #+begin_src jojo
        (-> t A, X -- Y)
        ------------------------ hypo-left
        (-> (-> :x : :T -- :x A) X -- Y)
        #+end_src

***** cut elimination

***** herbrand's theorem, interpolation and definability theorem

***** first-order logic and resolution refutations

*** proof theory of other logics  /home/xyh

***** intuitionistic logic

***** linear logic

* (1992) (a. s. troelstra) lectures on linear logic
