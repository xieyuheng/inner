8. Developing a Programming Aesthetic


<question>
  What we should do about programming aesthetic?

  <answer>
    While learning from others, it is more important to develop your own.
  </answer>
</question>


<question>
    What is intuition?

  <answer>
    Judgement is informed by past experience.

    Experience accumulates into an intuition
    about how best to act in the face of uncertainty.

    Intuition is a form of pattern matching
    performed by your unconscious mind,
    trained throughout your career on scores of code examples.
  </answer>
</question>


<question>
  How should we deal with our intuition?

  <answer>
    Intuition is generated by the big super-computer of your unconscious mind.
    Intuition not well expressed by words are just feelings.
    Intuition not well expressed by words are not convincing.

    It's the job of your conscious brain to figure out how to put words on those feelings.

    These words form your programming aesthetic,
    or the set of principles that underlie and guide your work.

    Intuition drives action,
    justified by aesthetics,
    and guided by heuristics.
  </answer>
</question>


<question>
  What is Dependency Inversion Principle (DIP)?

  <answer>
    1. High-level modules should not depend upon low-level modules.
       Both should depend upon abstractions.

    2. Abstractions should not depend upon details.
       Details should depend upon abstractions.

    First, note that the word "module" in the definition above
    does not refer to a specific language feature.
    In this definition module means an encapsulated,
    named unit of functionality in a program.
    You can substitute the words "classes" or "objects" for "modules."
  </answer>
</question>


<question>
  How to create new role and do dependency injection?

  <answer>
    Isolate the behavior you want to vary.

    One of the most fundamental concepts in OO is to isolate the behavior you want to vary.
  </answer>
</question>


<question>
  When injecting collaborators, should you inject classes or instances of those classes?

  <answer>
    We should inject instances.

    Because we do not want to depend on how instances are created.

    Injecting classes will violate the Law of Demeter.

    The rule for injecting dependencies is that
    you should inject the thing you want to talk to.

    In other words, the receiver may directly send messages
    only to the injected object,
    not to it and all of its friends.

    The practical effect of this rule is to
    prohibit the use of injected objects in message chains
    that violate the Law of Demeter.
  </answer>
</question>


<question>
  What is the Law of Demeter (LoD)?

  <answer>
    The Law of Demeter says that from within a method, messages should be sent only to:

    1. objects that are passed in as arguments to the method
    2. objects that are directly available to this

    ----

    This is define in a worse way in "Object-Oriented Programming: An Objective Sense of Style":

    For all classes C and for all methods M attached to C,
    all objects to which M sends a message
    must be instances of classes associated with the following classes:

    1. The argument classes of M (including C).
    2. The instance variable classes of C.

    (Objects created by M, or by functions or methods which M calls,
    and objects in global variables are considered as arguments of M.)
  </answer>
</question>


<question>
  Why the we should obey the Law of Demeter?

  <answer>
    The Law of Demeter effectively restricts the list of other objects
    to which an object may send a message.
    Its purpose is to reduce the coupling between objects.

    From the message-senders point of view,
    an object may talk to its neighbors but not to its neighbor's neighbors.

    Objects may only send messages to direct collaborators.
  </answer>
</question>


<question>
  How to cure Demeter violations?

  <answer>
    Use message forwarding.

    Also to avoid encoding the names of existing objects
    into the names of the forwarding messages,
    We should think about design from the message senders point of view.
  </answer>
</question>


<question>
  What is the difference between delegation and message forwarding?

  <answer>
    In delegation sender also pass itself to receivers.
  </answer>
</question>


<question>
  How to get a quick handle on the consequences of a code arrangement?

  <answer>
    One way is to attempt to test it.

    Testing is the first form of reuse.

    It is all about feedback.
  </answer>
</question>


<question>
    What does OOD teach us about when we want something?

  <answer>
    If you want something, just ask for it.
    If the receiver doesn't know how to comply, teach it.
    Don't be trapped by what's currently true,
    but instead, loosen coupling by designing a conversation
    that embodies what the message sender wants.
  </answer>
</question>


<question>
  What does well-designed object-oriented applications consist of?

  <answer>

    Well-designed object-oriented applications consist of loosely-coupled objects
    that rely on polymorphism to vary behavior.

    Injecting dependencies loosens coupling.

    Polymorphism isolates variant behavior
    into sets of interchangeable objects
    that look the same from the outside
    but behave differently on the inside.
  </answer>
</question>


<question>
    When using dependency injection, what should we do about object creation?

  <answer>
    Object creation should be pushed more towards the edges.

    Applications that use dependency injection evolve,
    naturally and of necessity, into systems where
    object creation begins to separate from object use.

    Object creation gets pushed more towards the edges, towards the outside,
    and the objects themselves interact more towards the middle, or the inside.
  </answer>
</question>


<question>
  What rules experienced programmers know about class name, that make applications most easily adapt to the unknown future?

  <answer>
    Experienced object-oriented programmers know that applications most easily adapt to the unknown future if they:

    - resist giving instance methods knowledge of concrete class names, and
    - seek opportunities to move the object creation towards the edges of the application.

    These are guidelines, not hard and fast rules.
    This is especially true in cases like this where the hard-coded reference is to a factory,
    so the coupling is already loose.

    Even so, you should be eternally alert for instance methods that reference class names
    and perpetually on the lookout for ways to remove those references,
    by pushing object creation towards the edges.
  </answer>
</question>


<question>
    What is a programming aesthetic?

  <answer>
    Well expressed intuition is aesthetic.

    A programming aesthetic is the set of internal heuristics
    that guide your behavior in times of uncertainty.

    Vague feelings about the rightness of code
    become part of your aesthetic
    once you can eloquently and convincingly
    use actual words to explain your concerns and proposed improvements.

    A good programming aesthetic focuses attention
    on improvements that are likely to prove worthwhile.
  </answer>
</question>


<question>
    What are some precepts that belong in everyone's object-oriented programming aesthetic?

  <answer>
    1. Put domain behavior on instances.
    2. Be averse to allowing instance methods to know the names of constants.
    3. Seek to depend on injected abstractions rather than hard-coded concretions.
    4. Push object creation to the edges, expecting objects to be created in one place and used in another.
    5. Avoid Demeter violations, using the temptation to create them as a spur to search for deeper abstractions.
  </answer>
</question>
