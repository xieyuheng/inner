#+title: cicada note

* 目標 <2017-05-19>

*** 兩個問題

    - x -
      首先要知道 cicada 將是一個實用的程序語言
      而不是一個實驗性的程序語言
      at1 將用 cicada 寫成
      在 at1 中
      我發現
      證明和類型的層次已經需要被擴展了
      因爲 在考慮二維流形的 normalization 時
      類型[即 空間]也將能夠被作爲數據處理

      當我們把空間當作數據處理的時候
      把三維空間的各種展示在屏幕上就是非常重要的了

      因此
      利用 cicada 這個實用的語言
      我將實現三維空間的建模
      我將用它來寫各種各樣的解釋器
      cicada 一定要善於解決這類問題

      就一個實用的語言來講
      我先想到的是兩個基本問題
      一個語法擴展系統
      一個是類型系統

      (問題 1)
      如何設計語法擴展系統?
      我們是否需要強大的語法擴展系統?
      我想以更靈活 更結構化的方式 把代碼視爲數據
      我想以這種方式 避免一個相對獨立的語法擴展系統
      我想使語義的一致性更強

      (問題 2)
      如何設計類型系統?
      如何保持類型系統的靈活性?
      在考慮這個問題的時候
      一定要多以那些非平凡的實際問題爲例子
      比如建立三維空間的模型
      並且把這個模型展示在屏幕上
      我要實現一個三維空間的編輯器
      輸入的是用戶的操作
      輸出的是展示與屏幕的結果
      類型系統要如何靈活才能處理這種問題?

*** (問題 2)

    - k -
      我們先討論 (問題 2)
      因爲對一個程序語言而言
      語義必語法更本質
      而類型系統正是語義的核心

      首先我想反問的是
      爲什麼認爲 io 與類型系統有衝突?
      爲什麼說在類型系統中 很難處理 io?

    - x -
      我想這是因爲 io 將讓我們出離函數範式
      假設我們在寫一個編輯器
      如果想把編輯的結果作爲函數的結果
      那麼函數的輸入就是所有操作的累積
      然而
      這顯然是不經濟的
      更好的方式是
      把操作看成是對某個數據結構的修改

    - k -
      但是出離函數範式
      並不意味着沒法使用類型系統了
      當時獲得局部的 作爲修改的輸入時
      我們可以生成修改函數
      等等

    - x -
      感覺 函數的輸入不能決定積累而來的最終數據本身了
      但是 我們可以觀察 最終的數據的各種性質
      還有 這些性質在某些修改下的不變性
      利用這些不變性
      我們就能否定某些命題
      當我們把對這些命題的肯定作爲類型
      而聲明於最終數據 用以檢查時
      我們就能獲得一定的 '安全性'
      這種意義上 我們就有了一個類型系統了

    - k -
      (問題 2)
      就這樣吧
      我們知道了 類型系統於 io 並否是不可共存的

*** (問題 1)

    - x -
