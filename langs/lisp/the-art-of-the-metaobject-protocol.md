---
title: the art of the metaobject protocol
---

# [note]

- x -
  oo 中重要的是 易於更改
  即 當需要添加某些東西時
  不必更改很多地方

# 1 how clos is implemented

## intro

- to progressively design and implement a metaobject protocol,
  motivating each step with an example
  of the kind of problem users have with CLOS.
  Each example will be resolved by showing
  how it is handled by the newly developed portion of the protocol.

- metaobject protocol means
  to implement an interpreter of CLOS in CLOS
  called Closette.

  simplify CLOS to Closette by
  1. interpreter rather than compiler
  2. neglecting performance
  3. ommit error-checking

- Although understanding implementation architecture is important,
  it is vital to distinguish the implementation
  from the documented language.

- theatre metaphor :
  | documented language | on-stage  |
  | implementation      | backstage |
  | implementor         | producer  |

## syntax example

```lisp
(defclass rectangle ()
  ((height :initform 0.0 :initarg :height)
   (width  :initform 0.0 :initarg :width)))

(defclass color-mixin ()
  ((cyan    :initform 0 :initarg :cyan)
   (magenta :initform 0 :initarg :magenta)
   (yellow  :initform 0 :initarg :yellow)))

(defclass color-rectangle (color-mixin rectangle)
  ((clearp :initform nil
           :initarg :clearp
           :accessor clearp)))

(defgeneric paint (x))

(defmethod paint ((x rectangle))
  (vertical-stroke (slot-value x 'height)(slot-value x 'width)))

(defmethod paint
    :before ((x color-mixin))
  (set-brush-color (slot-value x 'cyan)
                   (slot-value x 'magenta)
                   (slot-value x 'yellow)))

(defmethod paint ((x color-rectangle))
  (unless (clearp x) (call-next-method)))

(setq door
      (make-instance
       'color-rectangle
       :width 38 :height 84
       :cyan 60 :yellow 55
       :clearp nil))
```

## semantic

- directed graph

## Utilities

```lisp
;;; push-on-end is like push except it uses the other end:

(defmacro push-on-end (value location)
  `(setf ,location (nconc ,location (list ,value))))

;;; (setf getf*) is like (setf getf) except that it always changes the list,
;;;              which must be non-nil.

(defun (setf getf*) (new-value plist key)
  (block body
    (do ((x plist (cddr x)))
        ((null x))
      (when (eq (car x) key)
        (setf (car (cdr x)) new-value)
        (return-from body new-value)))
    (push-on-end key plist)
    (push-on-end new-value plist)
    new-value))

;;; mapappend is like mapcar except that the results are appended together:

(defun mapappend (fun &rest args)
  (if (some #'null args)
      ()
      (append (apply fun (mapcar #'car args))
              (apply #'mapappend fun (mapcar #'cdr args)))))

;;; mapplist is mapcar for property lists:

(defun mapplist (fun x)
  (if (null x)
      ()
      (cons (funcall fun (car x) (cadr x))
            (mapplist fun (cddr x)))))
```

## How classes are represented

- object can be anonymous
  class is [meta] object.
  thus, class can be anonymous.

- directed graph of subclass relation
  is implemented by one class stores
  - direct-superclasses
  - direct-subclasses

  both are list of class objects
  insteaded of class names.

- class-precedence-list
  can be generated by direct-superclasses
  but it is also stored in class as cache.

## How objects are printed

## How instances are represented, initialized, and accessed

## How generic functions are represented

## How methods are represented

## What happens when a generic function is called

# 2 introspection and analysis

# 3 extending the language

# 4 protocol design

# 5 a metaobject protocol for clos

# 6 generic functions and methods

# a an introduction to the common lisp object system

## example

```lisp
(defclass rectangle ()
  ((height
    :initform 5)
   (width
    :initform 8)))

(defclass circle ()
  ((radius
    :initform 5)))

(setf rl (make-instance 'rectangle))

(defgeneric paint (shape medium))

(defmethod paint ((shape rectangle) medium)
  (vertical-stroke (slot-value shape 'height)
                   (slot-value shape 'width)
                   medium))

(defmethod paint ((shape circle) medium)
  (draw-circle (slot-value shape 'radius) medium))
```

## a.5 structure encapsulation

- use :accessor instead of slot-value
  because this allows these generic functions to be specialized,
  for example, replacing direct access by a computation,
  without requiring anychange to client code.

  - x -
    這就使得消息傳遞語法簡化函數名的功能失去意義了
    一個 accessor 作爲函數只有一個參數那就是這個 class 的 object
    進一步 specialize 這個函數根本沒有必要
