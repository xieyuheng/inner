#+TITLE:  learning low level languages
#+AUTHOR: XIE Yuheng

* ===================================
* architecture
** the 8 named general purpose registers
   1. eax : accumulator register. used in arithmetic operations.
   2. ecx : counter register. used in shift/rotate instructions.
   3. edx : data register. used in arithmetic operations and i/o operations.
   4. ebx : base register. used as a pointer to data (located in ds in segmented mode).
   5. esp : stack pointer register. pointer to the top of the stack.
   6. ebp : stack base pointer register. used to point to the base of the stack.
   7. esi : source register. used as a pointer to a source in stream operations.
   8. edi : destination register. used as a pointer to a destination in stream operations.
** the 6 segment registers
   1. SS : Stack Segment. Pointer to the stack.
   2. CS : Code Segment. Pointer to the code.
   3. DS : Data Segment. Pointer to the data.
   4. ES : Extra Segment. Pointer to extra data. ('E' stands for "Extra")
   5. FS : F Segment. Pointer to more extra data. ('F' comes after 'E')
   6. GS : G Segment. Pointer to still more extra data. ('G' comes after 'F')
   Most applications on most modern operating systems
   (like Linux or Microsoft Windows)
   use a memory model that points nearly all segment registers
   to the same place (and uses paging instead)
   effectively disabling their use
   Typically FS or GS is an exception to this rule
   to be used to point at thread-specific data
** the EFLAGS Register (这个寄存器有特殊的读写方式)
   0: CF: Carry Flag
   Set if the last arithmetic operation
   carried (addition) or borrowed (subtraction) a bit
   beyond the size of the register
   This is then checked when
   the operation is followed with an add-with-carry or subtract-with-borrow to deal with
   values too large for just one register to contain

   2: PF: Parity Flag
   Set if the number of set bits in the least significant byte is a multiple of 2

   4: AF: Adjust Flag
   Carry of Binary Code Decimal (BCD) numbers arithmetic operations

   6: ZF: Zero Flag
   Set if the result of an operation is Zero (0)

   7: SF: Sign Flag
   Set if the result of an operation is negative

   8: TF: Trap Flag
   Set if step by step debugging

   9: IF: Interruption Flag
   Set if interrupts are enabled.

   10: DF: Direction Flag
   Stream direction
   If set, string operations will decrement their pointer
   rather than incrementing it, reading memory backwards.

   11: OF: Overflow Flag
   Set if signed arithmetic operations result in a value too large
   for the register to contain

   12-13: IOPL: I/O Privilege Level field (2 bits)
   I/O Privilege Level of the current process

   14: NT: Nested Task flag
   Controls chaining of interrupts. Set if the current process is
   linked to the next process

   16: RF: Resume Flag
   Response to debug exceptions

   17: VM: Virtual-8086 Mode
   Set if in 8086 compatibility mode

   18: AC: Alignment Check
   Set if alignment checking in of memory references are done

   19: VIF: Virtual Interrupt Flag
   Virtual image of IF

   20: VIP: Virtual Interrupt Pending flag
   Set if an interrupt is pending

   21: ID: Identification Flag
   Support for CPUID instruction if can be set


   Table 2.1  Conditions
   |----------+-----------------------+-----------------------|
   | Mnemonic | Condition tested      | Description           |
   |----------+-----------------------+-----------------------|
   | o        | OF = 1                | overflow              |
   |----------+-----------------------+-----------------------|
   | no       | OF = 0                | not overflow          |
   |----------+-----------------------+-----------------------|
   | c        |                       | carry                 |
   | b        | CF = 1                | below                 |
   | nae      |                       | not above nor equal   |
   |----------+-----------------------+-----------------------|
   | nc       |                       | not carry             |
   | ae       | CF = 0                | above or equal        |
   | nb       |                       | not below             |
   |----------+-----------------------+-----------------------|
   | e        | ZF = 1                | equal                 |
   | z        |                       | zero                  |
   |----------+-----------------------+-----------------------|
   | ne       | ZF = 0                | not equal             |
   | nz       |                       | not zero              |
   |----------+-----------------------+-----------------------|
   | be       | CF or ZF = 1          | below or equal        |
   | na       |                       | not above             |
   |----------+-----------------------+-----------------------|
   | a        | CF or ZF = 0          | above                 |
   | nbe      |                       | not below nor equal   |
   |----------+-----------------------+-----------------------|
   | s        | SF = 1                | sign                  |
   |----------+-----------------------+-----------------------|
   | ns       | SF = 0                | not sign              |
   |----------+-----------------------+-----------------------|
   | p        | PF = 1                | parity                |
   | pe       |                       | parity even           |
   |----------+-----------------------+-----------------------|
   | np       | PF = 0                | not parity            |
   | po       |                       | parity odd            |
   |----------+-----------------------+-----------------------|
   | l        | SF xor OF = 1         | less                  |
   | nge      |                       | not greater nor equal |
   |----------+-----------------------+-----------------------|
   | ge       | SF xor OF = 0         | greater or equal      |
   | nl       |                       | not less              |
   |----------+-----------------------+-----------------------|
   | le       | (SF xor OF) or ZF = 1 | less or equal         |
   | ng       |                       | not greater           |
   |----------+-----------------------+-----------------------|
   | g        | (SF xor OF) or ZF = 0 | greater               |
   | nle      |                       | not less nor equal    |
   |----------+-----------------------+-----------------------|
** flags
*** Adjust flag
    The Adjust flag (also known as the Auxiliary flag)
    is a flag stored in the FLAGS register on all x86 compatible CPUs.
    It is bit 4.
    It is used to indicate when an arithmetic carry or borrow
    has been generated out of the 4 least significant bits.
    It is primarily used in BCD arithmetics.

    Auxiliary flag is set (AF=1)
    if there is a carry from low nibble to high nibble
    or a borrow from a high nibble to low nibble
    of the low order 8-bit of a 16-bit number.
    (for example, in BCD addition or subtraction.)
*** The CARRY flag and OVERFLOW flag in binary arithmetic
    Do not confuse the "carry" flag with the "overflow" flag in integer
    arithmetic.  Each flag can occur on its own, or both together.  The CPU's
    ALU doesn't care or know whether you are doing signed or unsigned
    mathematics; the ALU always sets both flags appropriately when doing any
    integer math.  The ALU doesn't know about signed/unsigned; the ALU just
    does the binary math and sets the flags appropriately.  It's up to you,
    the programmer, to know which flag to check after the math is done.

    If your program treats the bits in a word as unsigned numbers, you
    must watch to see if your arithmetic sets the carry flag on, indicating
    the result is wrong.  You don't care about the overflow flag when doing
    unsigned math.  (The overflow flag is only relevant to signed numbers, not
    unsigned.)

    If your program treats the bits in a word as two's complement signed
    values, you must watch to see if your arithmetic sets the overflow flag
    on, indicating the result is wrong.  You don't care about the carry
    flag when doing signed, two's complement math.  (The carry flag is only
    relevant to unsigned numbers, not signed.)

    In unsigned arithmetic, watch the carry flag to detect errors.
    In unsigned arithmetic, the overflow flag tells you nothing interesting.

    In signed arithmetic, watch the overflow flag to detect errors.
    In signed arithmetic, the carry flag tells you nothing interesting.

    English
    -------

    Do not confuse the English verb "to overflow" with the "overflow flag"
    in the ALU.  The verb "to overflow" is used casually to indicate that
    some math result doesn't fit in the number of bits available; it could be
    integer math, or floating-point math, or whatever.  The "overflow flag"
    is set specifically by the ALU as described below, and it isn't the same
    as the casual English verb "to overflow".

    In English, we may say "the binary/integer math overflowed the number
    of bits available for the result, causing the carry flag to come on".
    Note how this English usage of the verb "to overflow" is *not* the same as
    saying "the overflow flag is on".  A math result can overflow (the verb)
    the number of bits available without turning on the ALU "overflow" flag.

    Carry Flag
    ----------

    The rules for turning on the carry flag in binary/integer math are two:

    1. The carry flag is set if the addition of two numbers causes a carry
       out of the most significant (leftmost) bits added.

       1111 + 0001 = 0000 (carry flag is turned on)

    2. The carry (borrow) flag is also set if the subtraction of two numbers
       requires a borrow into the most significant (leftmost) bits subtracted.

       0000 - 0001 = 1111 (carry flag is turned on)

    Otherwise, the carry flag is turned off (zero).
    * 0111 + 0001 = 1000 (carry flag is turned off [zero])
    * 1000 - 0001 = 0111 (carry flag is turned off [zero])

    In unsigned arithmetic, watch the carry flag to detect errors.
    In signed arithmetic, the carry flag tells you nothing interesting.

    Overflow Flag
    -------------

    The rules for turning on the overflow flag in binary/integer math are two:

    1. If the sum of two numbers with the sign bits off yields a result number
       with the sign bit on, the "overflow" flag is turned on.

       0100 + 0100 = 1000 (overflow flag is turned on)

    2. If the sum of two numbers with the sign bits on yields a result number
       with the sign bit off, the "overflow" flag is turned on.

       1000 + 1000 = 0000 (overflow flag is turned on)

    Otherwise, the overflow flag is turned off.
    * 0100 + 0001 = 0101 (overflow flag is turned off)
    * 0110 + 1001 = 1111 (overflow flag is turned off)
    * 1000 + 0001 = 1001 (overflow flag is turned off)
    * 1100 + 1100 = 1000 (overflow flag is turned off)

    Note that you only need to look at the sign bits (leftmost) of the three
    numbers to decide if the overflow flag is turned on or off.

    If you are doing two's complement (signed) arithmetic, overflow flag on
    means the answer is wrong - you added two positive numbers and got a
    negative, or you added two negative numbers and got a positive.

    If you are doing unsigned arithmetic, the overflow flag means nothing
    and should be ignored.

    The rules for two's complement detect errors by examining the sign of
    the result.  A negative and positive added together cannot be wrong,
    because the sum is between the addends. Since both of the addends fit
    within the allowable range of numbers, and their sum is between them, it
    must fit as well.  Mixed-sign addition never turns on the overflow flag.

    In signed arithmetic, watch the overflow flag to detect errors.
    In unsigned arithmetic, the overflow flag tells you nothing interesting.

    How the ALU calculates the Overflow Flag
    ----------------------------------------

    This material is optional reading.

    There are several automated ways of detecting overflow errors in two's
    complement binary arithmetic (for those of you who don't like the manual
    inspection method).  Here are two:

    Calculating Overflow Flag: Method 1
    -----------------------------------

    Overflow can only happen when adding two numbers of the same sign and
    getting a different sign.  So, to detect overflow we don't care about
    any bits except the sign bits.  Ignore the other bits.

    With two operands and one result, we have three sign bits (each 1 or
    0) to consider, so we have exactly 2**3=8 possible combinations of the
    three bits.  Only two of those 8 possible cases are considered overflow.
    Below are just the sign bits of the two addition operands and result:

    ADDITION SIGN BITS
    num1sign num2sign sumsign
    ---------------------------
    0 0 0
    *OVER* 0 0 1 (adding two positives should be positive)
    0 1 0
    0 1 1
    1 0 0
    1 0 1
    *OVER* 1 1 0 (adding two negatives should be negative)
    1 1 1

    We can repeat the same table for subtraction.  Note that subtracting
    a positive number is the same as adding a negative, so the conditions that
    trigger the overflow flag are:

    SUBTRACTION SIGN BITS
    num1sign num2sign sumsign
    ---------------------------
    0 0 0
    0 0 1
    0 1 0
    *OVER* 0 1 1 (subtracting a negative is the same as adding a positive)
    *OVER* 1 0 0 (subtracting a positive is the same as adding a negative)
    1 0 1
    1 1 0
    1 1 1

    A computer might contain a small logic gate array that sets the overflow
    flag to "1" iff any one of the above four OV conditions is met.

    A human need only remember that, when doing signed math, adding
    two numbers of the same sign must produce a result of the same sign,
    otherwise overflow happened.

    Calculating Overflow Flag: Method 2
    -----------------------------------

    When adding two binary values, consider the binary carry coming into
    the leftmost place (into the sign bit) and the binary carry going out
    of that leftmost place.  (Carry going out of the leftmost [sign] bit
    becomes the CARRY flag in the ALU.)

    Overflow in two's complement may occur, not when a bit is carried out
    out of the left column, but when one is carried into it and no matching
    carry out occurs. That is, overflow happens when there is a carry into
    the sign bit but no carry out of the sign bit.

    The OVERFLOW flag is the XOR of the carry coming into the sign bit (if
    any) with the carry going out of the sign bit (if any).  Overflow happens
    if the carry in does not equal the carry out.

    Examples (2-bit signed 2's complement binary numbers):

    11
    +01
    ===
    00

    - carry in is 1
    - carry out is 1
    - 1 XOR 1 = NO OVERFLOW


    01
    +01
    ===
    10

    - carry in is 1
    - carry out is 0
    - 1 XOR 0 = OVERFLOW!


    11
    +10
    ===
    01

    - carry in is 0
    - carry out is 1
    - 0 XOR 1 = OVERFLOW!


    10
    +01
    ===
    11

    - carry in is 0
    - carry out is 0
    - 0 XOR 0 = NO OVERFLOW

    Note that this XOR method only works with the *binary* carry that goes
    into the sign *bit*.  If you are working with hexadecimal numbers, or
    decimal numbers, or octal numbers, you also have carry; but, the carry
    doesn't go into the sign *bit* and you can't XOR that non-binary carry
    with the outgoing carry.

    Hexadecimal addition example (showing that XOR doesn't work for hex carry):

    8Ah
    +8Ah
    ====
    14h

    The hexadecimal carry of 1 resulting from A+A does not affect the
    sign bit.  If you do the math in binary, you'll see that there is
    *no* carry *into* the sign bit; but, there is carry out of the sign
    bit.  Therefore, the above example sets OVERFLOW on.  (The example
    adds two negative numbers and gets a positive number.
*** sign flag
    In a computer processor the negative flag or sign flag is
    a single bit in a system status (flag) register
    used to indicate
    whether the result of the last mathematical operation
    resulted in a value whose most significant bit was set.
    In a two's complement interpretation of the result,
    the negative flag is set if the result was negative.

    The negative flag is set according to the result
    in the x86 series processors
    by the following instructions: (referring to the Intel 80386 manual)
    1. All arithmetic operations except multiplication and division
    2. compare instructions
    3. Logical instructions - XOR, AND, OR
    4. TEST instructions
* real mode
** 指令和数据没有语法上的区别(都是二进制数) 只有语义上的区别
   机器把某解二进制数理解为指令 把另一些二进制数理解为数据
   就像你把我所说的某一些音节理解位动词 而把另一些音节理解为名词
   我所说的音节流 有的被你理解为祈使句 有的被你理解疑问句
   当然我所说的音节流 在你的理解中所可能形成的语义是非常丰富的
   计算机对二进制数的理解未尝不是如此
   但是对计算机而言要形成更丰富的语义就要用编译器来作一些抽象

   算法和数据在更高层次上也能没有区别
   比如对lisp而言算法是sexp数据也是sexp
   比如对digrap而言算法是gexp数据也是gexp
** 总线 与 CPU存储器(内存)的读写
   总线:
   1. 地址总线
      64根地址总线所能寻址的内存大小为2^64 bytes
   2. 数据总线
      其宽度决定了数据在CPU和内存之间的传送速度
   3. 控制总线
      是很多控制总线的集合
      有多少根控制总线 CPU就提供了对其他硬件的多少种控制
** 设备
   每个设备都有相应的存储器
   至少有只读的存储器(ROM)来储存支持基本输入输出的软件(BIOS)
   这些存储器被CPU一视同仁
   CPU在控制硬件的时候把它们当作内存来待
** 十六位的限制带来有趣而无奈的寻址方式
*** cs:ip
    real mode:
    1. 从CS:IP寻址以fetch当前需要被执行的指令到buffer
    2. IP = IP + (指令长度)
    3. 执行指令
    4. loop
    对8086而言CS:IP的初值如下:
    f000:ffff

    long mode:
    1. RIP寻址以fetch当前需要被执行的指令到buffer
    2. RIP = RIP + (指令长度)
    3. 执行指令
    4. loop
*** jmp
    为了简化程序员对CPU的控制
    设计者规定程序员只能通过读写CPU中的寄存器来控制CPU
    但是不能用mov来读写CS,DS这类段寄存器
    jmp是最简单的修改CS:IP的指令了
    jmp指令是别的(并不合法的)指令的指令糖

    具体的各种转跳方式比较复杂
*** loop <label>
    (cx)代表循环数

    loop <label>
    ==
    (cx) = (cx) - 1
    if (cx) =/= 0
    jmp <label>
    else
    go next
*** ret
    ret
    ==
    pop ip
    ==
    (ip) = ((ss) * 16 + (sp))
    (sp) = (sp) + 2
    + real mode中栈的单位是word
    + ((ss) * 16 + (sp)) = [ss:sp]
*** retf
    retf
    ==
    pop ip
    pop cs
    ==
    (ip) = ((ss) * 16 + (sp))
    (sp) = (sp) + 2
    (cs) = ((ss) * 16 + (sp))
    (sp) = (sp) + 2
    + real mode中栈的单位是word
*** call
    real mode:
    call <label>
    ==
    push ip
    jmp near <label>
    ==
    (sp) = (sp) - 2
    ((ss) * 16 + (sp)) = (ip)
    (ip) = (ip) + <16位二进制符号数表示的位移(在编译时算出)>

    call far <label>
    ==
    push cs
    push ip
    jmp far <label>
    ==
    (sp) = (sp) - 2
    ((ss) * 16 + (sp)) = (cs)
    (sp) = (sp) - 2
    ((ss) * 16 + (sp)) = (ip)
    (cs) = <label>的段地址
    (ip) = <label>的偏移地址

    call <16位寄存器>
    ==
    push ip
    jmp <16位寄存器>
    ==
    (sp) = (sp) - 2
    ((ss) * 16 + (sp)) = (ip)
    (ip) = (<16位寄存器>)

    call word <内存单元地址>
*** DS
    DS = f000时
    mov al, [f]
    ==
    mov al, [f000f]
*** SS:SP (栈顶地址)
    1. 在real mode下栈的单位是word
       而在long mode下栈的单位是4 words == 8 bytes
    2. 入栈之后栈顶地址减小
    3. 栈是空的的时候SS:SP为栈顶的地址的下一个地址(栈顶)
    4. 没有栈底寄存器来保护你
    5. real mode:
       push <val>
       ==
       (sp) = (sp) - 2
       ((ss) * 16 + (sp)) = <val>

       pop <memory>
       ==
       (sp) = (sp) + 2
       <memory> = ((ss) * 16 + (sp))
** ><
   0xe9 / JMP

   *(PDWORD)( Opcode + 1 ) = ( destination - origin - 5)

   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Short jumps:

   Opcodes:

   0x70 / JO
   0x71 / JNO
   0x72 / JB/JC/JNAE
   0x73 / JAE/JNB/JNC
   0x74 / JE/JZ
   0x75 / JNE/JNZ
   0x76 / JBE/JNA
   0x77 / JA/JNBE
   0x78 / JS
   0x79 / JNS
   0x7a / JP/JPE
   0x7b / JNP/JPO
   0x7c / JL/JNGE
   0x7d / JGE/JNL
   0x7e / JLE/JNG
   0x7f / JG/JNLE
   0xeb / JMP

   If the destination is lower than origin:

   // ( *PBYTE( Opcode + 1 ) >= 0x80 )

   *PBYTE( Opcode + 1 ) = ~( ( origin - destination ) + 1 );


   If the is origin lower than destination:

   // ( *PBYTE( Opcode + 1 ) <= 0x7f )

   *PBYTE( Opcode + 1 ) = ( destination - origin ) - 2;

   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Near jumps:

   Opcodes:

   0x0f 0x80 / JO
   0x0f 0x81 / JNO
   0x0f 0x82 / JB/JC/JNAE
   0x0f 0x83 / JAE/JNB/JNC
   0x0f 0x84 / JE/JZ
   0x0f 0x85 / JNE/JNZ
   0x0f 0x86 / JBE/JNA
   0x0f 0x87 / JA/JNBE
   0x0f 0x88 / JS
   0x0f 0x89 / JNS
   0x0f 0x8a / JP/JPE
   0x0f 0x8b / JNP/JPO
   0x0f 0x8c / JL/JNGE
   0x0f 0x8d / JGE/JNL
   0x0f 0x8e / JLE/JNG
   0x0f 0x8f / JG/JNLE

   If the destination is lower than origin:

   // ( *(PDWORD)( Opcode + 2 ) < 0 )


   *(PDWORD)( Opcode + 2 ) = ~( ( origin - destination ) + 5 );


   If the is origin lower than destination:

   // ( *(PDWORD)( Opcode + 2 ) > 0 )


   *(PDWORD)( Opcode + 2 ) = ( ( destination - origin ) - 6 );

   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Near Relative Jump:

   Opcode:

   0xe9 / JMP

   *(PDWORD)( Opcode + 1 ) = ( destination - origin - 5);

   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Near relative call:

   Opcode:

   0xe8 / CALL

   *(PDWORD)( Opcode + 1 ) = ( ( destination - origin ) - 4 )
** and & or
   可以看成是对二进制数的过滤:
   1. and
      一个是筛子 另一个是被筛的数
      就筛子而言 1是可以漏过的孔
   2. or
      一个是筛子 另一个是被筛的数
      就筛子而言 0是可以漏过的孔
** 设备端口 (port)
   (CPU可以直接读写的三个地方之一)
   0 -- 65535
   in out
   在保护模式下这些命令不能被直接使用
** 中断
   中断是CPU所提供的全局例外机制
   CPU接收到中断信息(中断类型码)之后
   查中断向量表
   找相应的中断处理程序(的第一条指令的地址)去处理
** CUP指令总结:
   1. 数据传送指令:
      mov push pop pushf popf xchg
   2. 算数运算指令:
      inc dec add sub cmp mul div
      adc sbb imul idiv aaa
   3. 逻辑运算指令:
      not(not不影响flag)
      and or xor
      shl shr
      sal sar
      rol ror
      rcl rcr
      test
   4. 转移指令:
      jmp
      jcxz je jb ja jnb jna
      loop
      call ret
      int iret
   5. 处理机控制指令(flag控制指令):
      cld std cli sti nop clc cmc stc hlt wait esc lock
   6. 串处理指令:
      对内存中的数据进行批量处理
      movsb movsw cmps scas lods stos
      + 相关的前缀指令:
        rep repe repne
** fasm的作者给出的自然数,整数,有理数,实数(能否作为实数的模型我还不确定)的补码模型
   或者说是无穷0,1序列对自然数,整数,有理数,(可能还有实数)的编码
   这种编码对小数的表示是不利用浮点的
   1. 对自然数的表示,与加法运算的算法:
      只有有限个位置上不是0的0,1数列代表了所有自然数
      加法运算的算法是简单,只要注意进位就行了,当进位出现时进位数只能是1
   2. 对整数的表示,与减法运算:
      定义减法运算为加法的逆运算
      + 减法作为加法的逆运算,就是加法所能形成的一种方程的一种解
        也就是说还是以这个模型中的加法运算的算法为核心的
      + 因为加法有交换性所以只有一个逆运算
      然后就减法在自然数集中的不完备性把自然数集扩展为整数集,这在于:
      1)
      在自然数集中不总是存在方程的解
      2) 当自然数集中不存在方程的解的时候
         加法运算的算法依然有效
         因为就这个模型而言加法算法的适用性本身就超出自然数的加法的语义
         + `相加'的可以是任何两个1,0序列间进行
         + 在1,0序列的集合内,方程总是存在唯一解
         不过这种断言某种程度上是先验的
      3) 既然使用的都是同样的加法算法
         那么很容易发现新数与旧数就运算而言相容
         还是以就原来模型的加法运算为核心的
      当有了负数的表示之后
      减法就可以用加法的算法来一致的计算
      这就相当于对于方程给出了求解公式
      + 当位数有限时 符号数的减法可以通过把减数化为负数然后再作加法来实现
        当位数有限时 对于无符号数减法是用机器提供的sub来作的
   3. 对分数表示,与乘法运算和除法运算:
      这类模型下的乘法总要有乘法表,二进制下的乘法表是最简单的了
      因为乘法表非常简单,所以乘法是如何作为连加的在这里就表现的特别明显
      除法也用定义为逆运算,即用方程定义
      很容易就发现不考虑零时方程是可解的并且解是唯一的
   4. >< 下面说一下这个模型的特点
      1) 最重要的是要明白
         这个模型的给出是为了帮助人们理解符号数在计算机中的表示
         首先要理解当位数有限的时候的进,借位
         其次要理解负数的这种特殊表示使得加法的运算可以以一致的进行
      2) 在这个模型下`1/2'+`1/2'不等于`1'
         或者说所得到的结果给出了1的另以中表示方式
         那么这样每个数就失去了表示上的唯一性了
      3) 分数之间的序关系是不能很好的被明显看出来的
         带浮点的分数模型就能很方便的看出序关系
         但是带一个分数线的序关系也是不容易看出来序关系
      4) 高次的代数方程可能是没有解的
         比如等号二就不能在这种模型下表示
** flag寄存器
   real mode:
   | 15 | 14 | 13 | 12 | 11 | 10 |  9 |  8 |  7 |  6 | 5 |  4 | 3 |  2 | 1 |  0 |
   |----+----+----+----+----+----+----+----+----+----+---+----+---+----+---+----|
   |    |    |    |    | of | df | if | tf | sf | zf |   | af |   | pf |   | cf |
   flag总是记录CPU的算数运算指令和逻辑运算指令之后的结果
   只影响flag的指令 和 条件转跳 共同形成着谓词语义
   1. zf
      结果是否为0
   2. pf
      结果作为二进制数其中的1的个数是否为偶数
      比如可以被用于奇偶校准
   3. sf
      结果作为符号数是否为负数
      即最高位是否为1
   4. cf
      无符号运算是否进位或借位
      不是一个简单的对运算结果的谓词了
      借位与负数的语义虽然不同 但是语法是重叠的
      要知道
      当一次减法运算最后还是需要借位的时候
      所得的结果就是负数了
   5. of
      符号数运算是否溢出
      溢出就是把符号位给侵占了
      机器的计算总是对无符号数而言的 形成有符号数的语义就在于这个flag
   6. df
      代表串传送指令的方向
      影响字符串操作
   ----------------------------------
   cmp(最常用的改变flag信息的指令):
   因为两个整数在整数全序集中的大于小于关系可以被化归为
   1) 两个整数的差对0的大于小于关系
   2) 或者两个整数的商(已经出离整数集了)对1的大于小于关系
   3) 等等
   所以不保存值的减法cmp与zf与cf一起就构成了比较大小的谓词
   + 在作减法的时候intel的语法相比AT&T的语法的直观性就体现出来了
   cmp rax, rbx
   下面就可以用flag来区分语义了,非常有趣:
   对无符号数的比较:
   + rax  == rbx : zf == 1
   + rax =/= rbx : zf == 0
   + rax  <  rbx : cf == 1
   + rax  >= rbx : cf == 0
   + rax  >  rbx : cf == 0 且 zf == 0 (利用'且',从上面的>=中剔除=的情况)
   + rax  <= rbx : cf == 1 或 zf == 1 (利用'或',给上面的<添加商=的情况)
   对符号数的比较:
   + rax  == rbx : zf == 1
   + rax =/= rbx : zf == 0
   + rax  <  rbx :
     下面的例子中有sf == 1但是不足以说明rax  <  rbx
     rax = 00100010, rbx = 10100000
     rax - rbx = 10000010
     这个数的算出是解方程而得到的,可以带回去验算
     如果验算时很容易理解什么是符号数的溢出
     即 可以用验算来判断是否符号位溢出
     或者直接把符号位溢出简单的理解为所得的整数结果超出了可表示的范围
   + 所以稍微复杂的有:
     + of == 0 时:
       sf == 1 --> rax  <  rbx
       sf == 0 --> rax  >= rbx
     + of == 1 时:(相等的时候不可能溢出)
       sf == 1 --> rax  >  rbx
       sf == 0 --> rax  <  rbx
   ----------------------------------
   常用的利用到flag信息的指令(形成一些关键的语义全靠这些指令了):
   1. adc sbb
      考虑逐位地(或逐段地,比如逐8位)对加法的计算就很容易理解
      即 对应的位上的每一对数在相加的同时还要加上或减去之前的进位与借位的1
      #+begin_src fasm
      1ef000h + 201000h
      mov ax, 001eh
      mov bx, 0f000h
      add bx, 1000h
      adc ax, 0020h
      #+end_src
   条件转移指令(修改cs:ip或rip的指令):
   1. jcxz
      转移条件:cx(ecx,rcx) == 0
   2. 针对无符号数的比较(检验zf,cf):
      | je  | equal     | ==  | zf == 1            |
      |-----+-----------+-----+--------------------|
      | jne | not equal | =/= | zf == 0            |
      |-----+-----------+-----+--------------------|
      | jb  | below     | <   | cf == 1            |
      |-----+-----------+-----+--------------------|
      | jnb | not below | >=  | cf == 0            |
      |-----+-----------+-----+--------------------|
      | ja  | above     | >   | cf == 0 且 zf == 0 |
      |-----+-----------+-----+--------------------|
      | jna | not above | <=  | cf == 1 或 zf == 1 |
   3. 针对有符号数的比较(检验zf,sf,of):
      ><><><
* differences between real-mode and protected-mode
  |----------------------+----------------------------+--------------------------+-----------------------------------|
  |                      | Real Mode                  | 16-bit Protected Mode    | 32-bit Protected Mode             |
  |----------------------+----------------------------+--------------------------+-----------------------------------|
  | Segment base address | 20-bit (1M byte range)     | 24-bit (16M byte range), | 32-bit (4G byte range),           |
  |                      | i.e. 16 * segment register | from descriptor          | from descriptor                   |
  |----------------------+----------------------------+--------------------------+-----------------------------------|
  | Segment size (limit) | 16-bit, 64K bytes (fixed)  | 16-bit, 1-64K bytes      | 20-bit, 1-1M bytes or 4K-4G bytes |
  |----------------------+----------------------------+--------------------------+-----------------------------------|
  | Segment protection   | no                         | yes                      | yes                               |
  |----------------------+----------------------------+--------------------------+-----------------------------------|
  | Segment register     | segment base address / 16  | selector                 | selector                          |
  |----------------------+----------------------------+--------------------------+-----------------------------------|
  In protected mode, besides the segment base address,
  we also need the segment size (limit)
  and some flags indicating what the segment is used for.
  This information goes into an 8-byte data structure called a descriptor:
  |--------------+------------+----------+-----------+------------+--------+--------------------+--------------|
  | Lowest bytes | Byte 1     | Byte 2   | Byte 3    | Byte 4     | Byte 5 | Byte 6             | Highest byte |
  |--------------+------------+----------+-----------+------------+--------+--------------------+--------------|
  | Limit 7:0    | Limit 15:8 | Base 7:0 | Base 15:8 | Base 23:16 | Access | Flags, Limit 19:16 | Base 31:24   |
  |--------------+------------+----------+-----------+------------+--------+--------------------+--------------|
  This is a 32-bit ('386) descriptor.
  For 16-bit ('286) descriptors,
  the top two bytes (Limit 19:16, Flags, and Base 31:24) are zero.
  The Access byte indicates segment usage (data segment, stack segment, code segment, etc.):
  |-------------+-----------+-------+------------+--------------------------------+-------------------+------------|
  | Highest bit | Bits 6, 5 | Bit 4 | Bits 3     | Bit 2                          | Bit 1             | Lowest bit |
  |-------------+-----------+-------+------------+--------------------------------+-------------------+------------|
  | Present     | Privilege |     1 | Executable | Expansion direction/conforming | Writable/readable | Accessed   |
  |-------------+-----------+-------+------------+--------------------------------+-------------------+------------|
* What's a selector?
  In protected mode, the segment registers contain selectors,
  which index into one of the descriptor tables.
  Only the top 13 bits of the selector are used for this index.
  bit-2 choses between the GDT and LDT.
  bit-0 and bit-1 of the selector set a privilege value.
* How do I enter protected mode?
  Entering protected mode is actually rather simple, and is is described in many other tutorials. You must:
  1. Create a valid Global Descriptor Table (GDT), and create the 6-byte 'pseudo descriptor' pointing to the GDT
  2. Disable interrupts
  3. LGDT. The operand of this instruction points to the GDT pseudo-descriptor, which in turn points to the GDT
  4. Set the PE bit in the MSW register
  5. Load all data segment registers with valid selectors
  6. Do a far jump (load both CS and IP/EIP) to load CS and enter pmode
* What pitfalls have you encountered?
  1. You must pay extreme attention to detail here.
     One wrong bit will make things fail.
     Protected mode errors often triple-fault the CPU, making it reset itself.
     Be prepared to see this happen again and again.
  2. Most library routines probably won't work.
     printf(), for example, won't work
     because it evenutally calls either a DOS or BIOS service
     to put text on the screen.
     Unless you have a DOS extender,
     these services are unavailable in protected mode.
     I had good luck using sprintf() to put formatted text in a buffer,
     which I then wrote to the screen with my own protected-mode routine.
  3. Before clearing the PE bit,
     the segment registers must point to descriptors that are appropriate to real mode.
     This means a limit of exactly 0xFFFF (see other restrictions above).
     One of my demo programs had ES pointing to a text-video segment.
     With a limit of 0xFFFF, things worked well. With a limit of 3999 (80 * 25 * 2 - 1),
     the system froze up after returning to real mode and trying to use the ES register.
     - Actually, for DS, ES, FS and GS, the segment limit must be 0xFFFF or greater.
       If you give the segment a limit of 0xFFFFF and make it page-granular,
       you can access up to 4G of memory from real mode -- this is unreal mode.
       However, limits other than 0xFFFF (or page-granularity) for CS or SS cause big problems in real mode.
  4. You can not use the '286 LMSW instruction to clear the PE bit.
     Use MOV CR0, nnn.
     (On the '286 CPU, the only way to return to real mode is to reset the CPU!)
  5. Load all segment registers with valid selectors after entering protected mode.
     I forgot to do this with ES.
     A protected-mode routine pushed ES, loaded it with a valid selector, and used it.
     When it tried to pop the old, invalid (real-mode) selector back into ES, it crashed.
  6. The IDTR must also be reset to a value that is appropriate to real-mode
     before re-enabling interrupts (see above).
  7. Not all instructions are legal in real mode.
     If you attempt to use task state segments for multitasking,
     note that executing the LTR instruction in real-mode will cause an illegal instruction interrupt.
  8. Descriptor tables in ROM? Section 10.4.3 of 386INTEL.TXT states
     - The GDT (as well as LDTs) should reside in RAM,
       because the processor modifies the accessed bit of descriptors.
     However, one of my sources (thanks Vinay) states that
     later CPUs will not attempt to set the Accessed bit in a descriptor
     if that bit is already set.
     Check the docs for the CPU you are using.
  9. The naive code described here will crash if the PC is in Virtual 8086 (V86) mode.
     This is a fourth mode of operation found on the 386 CPU,
     with addressing similar to real mode but some of the protection mechanisms of protected mode.
     You may know that a Windows (or OS/2, or Linux) DOS box runs in V86 mode,
     but you may not realize that memory managers such as EMM386 also put the CPU in V86 mode.
* If you want to start simple, try these tips:
  1. Don't worry about returning to real mode. Use the reset button :)
  2. Leave interrupts disabled.
  3. Don't use an LDT.
  4. Put only four descriptors in the GDT: null, code, stack/data, and linear data (base address = 0).
  5. Set the segment bases to real-mode values
     i.e. 16 * real-mode segment register value.
     This lets you address variables in the same way in both real and protected modes.
  6. Set all segment limits to their maximum.
  7. Leave all privilege values set to 0 (Ring 0, highest privilege).
  8. Before each step of switching to pmode,
     poke a character into video memory, to see (literally!) how far the code gets.
     Text-mode VGA memory starts at address 0B8000h.
* gas
** 寻址语法
   displacement[base register, offset register, scalar multiplier)
   + in Intel syntax:
     [base register + displacement + offset register * scalar multiplier]
   + Either or both of the numeric
     and either of the register parameters may be omitted
   #+begin_src asm
   movl    -4(%ebp, %edx, 4), %eax
              # Full example: load *(ebp - 4 + (edx * 4)) into eax

   movl    -4(%ebp), %eax
              # Typical example: load a stack variable into eax

   movl    (%ecx), %edx
              # No offset: copy the target of a pointer into a register

   leal    8(,%eax,4), %eax
              # Arithmetic: multiply eax by 4 and add 8
   leal    (%eax,%eax,2), %eax
              # Arithmetic: multiply eax by 2 and add eax (i.e. multiply by 3)
   #+end_src
** 寻址模式
   寄存器的名字也可以被当作特殊的地址
   这样就能对下面的东西形成统一的理解了
   交换下面的movl的两个变元的位置
   所得到的新命令都是符合语法的
   #+begin_src asm
   ### direct addressing mode
           movl address, %eax

   ### indexed addressing mode
           movl string_start(,%ecx,1), %eax

   ### indirect addressing mode
           movl (%eax), %ebx

   ### base pointer addressing mode
           movl 4(%eax), %ebx
   #+end_src
** 退出并返回状态码
   注意: 注释程序的每个奇怪行为
   :tangle ./play/exit.S
   #+begin_src asm
   ## PURPOSE:
   ##         Simple program that exits and returns a
   ##         status code back to the Linux kernel

   ## INPUT:
   ##         none

   ## OUTPUT:
   ##          returns a status code.  This can be viewed
   ##          by typing
   ##          echo $?
   ##          after running the program

   ## VARIABLES:
   ##          %eax holds the system call number
   ##          %ebx holds the return status


           .section .data
           .section .text
           .globl _start

   _start:
           movl $1, %ebx
           movl %ebx, %ecx
           movl %ecx, %edx
           movl %edx, %edi
           movl %edi, %esi
           movl %esi, %eax

           movl $66, %ecx
           movl %ecx, %edx
           movl %edx, %edi
           movl %edi, %esi
           movl %esi, %ebp
           movl %ebp, %esp
           movl %esp, %ebx         # exit status is of 1 byte
           int $0x80

   #+end_src

   :tangle ./play/exit.S
   #+begin_src asm
           .section .data
           .section .text
           .globl _start
   _start:
           movq $7, %rdi
           movq $60, %rax
           syscall
   #+end_src
   every program when it exits gives Linux an exit status code
   which tells it if everything went all right
** 用状态码返回三个数中最大的数
   :tangle ./play/max-of-three.S
   #+begin_src asm
           .section .data
   var1:
           .int 66
   var2:
           .int 20
   var3:
           .int 30


           .section .text
           .globl _start
   _start:
           movl  (var1), %ecx
           cmpl  (var2), %ecx
           jg    check_third_var
           movl  (var2), %ecx

   check_third_var:
           cmpl  (var3), %ecx
           jg    _exit
           movl  (var3), %ecx

   _exit:
           movl  $1, %eax
           movl  %ecx, %ebx
           int   $0x80
   #+end_src

** 一个数组的数中最大的数
   :tangle ./play/max-of-array.S
   #+begin_src asm
   ### PURPOSE:
   ###        finds the maximum number in data items array

   ### VARIABLES:
   ###        %edi - Holds the index of the data item being examined
   ###        %ebx - Largest data item found
   ###        %eax - Current data item
   ###        data_items: contains the item data, 0 is used to terminate the data


           .section .data
   data_items:
           .long 3,67,34,222,45,75,54,34,44,33,22,11,66,0


           .section .text
           .globl _start
   _start:
           movl $0, %edi
           movl data_items(,%edi,4), %eax
           movl %eax, %ebx

           ## 上面在于要准备好循环开启时的三个寄存器的状态
           ## 每次要进入循环的时候 都对三个寄存器的状态有约定:
           ## %edi : 当前指向的数的索引
           ## %eax : 当前指向的数
           ## %ebx : 在比较%eax之前 所知道的最大的数

   start_loop:
           cmpl $0, %eax
           je loop_exit

           incl %edi
           movl data_items(,%edi,4), %eax

           cmpl %ebx, %eax
           ## %eax <= %ebx
           jle start_loop          # 这个谓词所问的序关系的第一个参数是 cmpl的第二个参数
                                   # 这是为了让cmpl与subl一致 subl的第二个参数是被减数
           ## %eax > %ebx
           movl %eax, %ebx
           jmp start_loop


   loop_exit:
           movl $1, %eax
           int $0x80
   #+end_src
** 汇编中的函数
   1. 函数名:
      就是代码段地址的标签
      也就是代码段的首地址
   2. 输入与输出:
      这是通过约定一些存储器来保存输入数据和输出数据
      对输入与输出的保存应该使用统一的存储器约定
      因为一个函数的输出可能作为其他函数的输入
      使用栈是常用的方式
   3. 调用约定(calling convention):
      上面的东西也叫做calling convention
      也就是说需要设计统一的接口来实现函数的调用
   4. 副作用:
      在汇编中对辅佐用的使用是最自由的
      >< 如否可以像使用类型推到系统来管理输入输出一样
      以某种方式来系统化地管理副作用呢 ???
      副作用也是有类型的
      并且很多被函数被抽象成一个大函数之后
      也是可以推到副作用的
      但是为什么之前没有这种副作用管理系统呢 ???
      有什么困难的地方我没有注意到的码 ???
   5. 继续(返回):
      需要有另一个代码段的地址作为返回地址
      这样这个被调用的代码段执行结束之后程序才能继续下去
      + x86中call和ret帮助人们来实现调用与返回
        但是很容易设计自己的调用和返回的方式
   通过讨论汇编中的函数
   我可以看到函数语义的本质
   我发现我可以设计自己的方式去实现函数语义
   下面是一种嵌入scheme中的伪汇编:
   + 比如在forth这中栈处理器之外
     我可以把sicp中的寄存器处理器也嵌入到scheme中
   #+begin_src scheme
   '(:other-keys ...

     :><
      ><><><

     :other-keys ...)
   #+end_src
** calling convention
   1. C:
      注意这里就发现C对 %esp 和 %ebp 的使用方式就和forth不一样
      C 对它们的使用就像它们的名字一样是最典型的
      理解了这一点就理解了C中local-var static-var global-var的实现方式
      其中local-var通过%ebp而用栈实现
      而static-var是函数代码段内部的一片区域
      或者 只在这个代码段内保存那片内存的地址
      + 但是当函数调用嵌套时scope就断了 !!!
        因为每次%ebp只能帮你找到当前的召唤者的参数
        所以C中的函数定义不能嵌套 !!!
      + 注意:
        很容易发现C的calling convention是很低能的
        它所实现的函数根scheme中的函数根本就没法相提并论
   2. forth:
      与C完全不同
   3. scheme:
      scheme是怎么处理这一点的呢??
** a function example
   :tangle ./play/power.S
   #+begin_src asm
           .macro PushStack reg
           leaq -8(%rsp),%rsp
           movq \reg,(%rsp)
           .endm

           .macro PopStack reg
           movq (%rsp),\reg
           leaq 8(%rsp),%rsp
           .endm


   ### PURPOSE:
   ###        Program to illustrate how functions work
   ###        This program will compute the value of
   ###        2^3 + 5^2

   ### Everything in the main program is stored in registers,
   ### so the data section doesn't have anything.


           .section .data
           .section .text
           .globl _start
   _start:
           PushStack $3                  # push second argument
           PushStack $2                  # push first argument
           ## call power                # call the function
           movq BackToStartAfter_1st_CallingPower, %rcx
           PushStack %rcx
           jmp power
   BackToStartAfter_1st_CallingPower:
           addq $16, %rsp             # move the stack pointer back
           PushStack %rax                # save the first answer before
                                     # calling the next function
           PushStack $2                  # push second argument
           PushStack $5                  # push first argument
           ## call  power               # call the function
           movq BackToStartAfter_2st_CallingPower, %rcx
           PushStack %rcx
           jmp power
   BackToStartAfter_2st_CallingPower:
           addq  $16, %rsp            # move the stack pointer back
           PopStack  %rbx                # The second answer is already
                                     # in %rax. We saved the
                                     # first answer onto the stack,
                                     # so now we can just pop it
                                     # out into %rbx
           addq  %rax, %rbx          # add them together
                                     # the result is in %rbx
           movq  $60, %rax            # exit (%rbx is returned)
           syscall


   ### PURPOSE:
   ###        This function is used to compute
   ###        the value of a number raised to
   ###        a power.

   ### INPUT:
   ###        First argument - the base number
   ###        Second argument - the power to
   ###        raise it to

   ### OUTPUT:
   ###        Will give the result as a return value

   ### NOTES:
   ###        The power must be 1 or greater

   ### VARIABLES:
   ###        %rbx - holds the base number
   ###        %rcx - holds the power
   ###
   ###        -4(%rbp) - holds the current result
   ###
   ###        %rax is used for temporary storage
   ###
   ###        .type power, @function

   power:
           PushStack %rbp                # save old base pointer
           movq  %rsp, %rbp          # make stack pointer the base pointer
           subq  $8, %rsp            # get room for our local storage
           movq  16(%rbp), %rbx       # put first argument in %rax
           movq  24(%rbp), %rcx      # put second argument in %rcx
           movq  %rbx, -8(%rbp)      # store current result
   power_loop_start:
           cmpq $1, %rcx             # if the power is 1, we are done
           je    end_power
           movq -8(%rbp), %rax       # move the current result into %rax
           imulq %rbx, %rax          # multiply the current result by
                                     # the base number
           movq %rax, -8(%rbp)       # store the current result
           decq  %rcx                # decrease the power
           jmp   power_loop_start    # run for the next power
   end_power:
           movq -8(%rbp), %rax       # return value goes in %rax
           movq %rbp, %rsp           # restore the stack pointer
           PopStack %rbp                 # restore the base pointer


           ## ret
           PopStack %rdx
           jmp *%rdx
   #+end_src
** x86_32 and x86_64 assembler example
*** x86_64
    gcc -m64 -nostdlib -o x86_64 x86_64.S
    :tangle ./play/x86_64.S
    #+begin_src asm
    #include <asm/unistd_64.h>

    STDOUT = 1

    .data
    program_name:           .string "X86_64 AT&T assembler example 1\n"
    program_name_length   = 32
    exit_code:              .long 0

    .text
    .globl _start
    _start:
            movq $__NR_write, %rax
            movq $STDOUT, %rdi
            movq $program_name, %rsi
            movq $program_name_length, %rdx
            syscall

            popq %rcx                       # argc

    argv:
            popq %rsi                       # argv
            test %rsi, %rsi
            jz exit                         # exit if last (NULL) argument string

            movq %rsi, %rdx

    strlen:
            lodsb

            test %al, %al
            jnz strlen                      # continue if not end of string

            movb $0x0A, -1(%rsi)            # replace NUL-byte with \n


            subq %rdx, %rsi                 # calculate buffer size
            xchg %rdx, %rsi                 # reorder for syscall conventions
            movq $__NR_write, %rax
            movq $STDOUT, %rdi              # file descriptor
            syscall

            jmp argv                        # process next argument

    exit:
            movq $__NR_exit, %rax
            movl exit_code, %edi
            syscall
    #+end_src
*** x86_32
    #+begin_src asm
    /* Copyright (C) 2007 Mario Lang <mlang@delysid.org> */
    /* Compile with "gcc -nostdlib -o x86_both x86_both.S" adding -m32 or -m64 */
    #ifdef __x86_64__
      #include <asm-x86_64/unistd.h>
    #elif __i386__
      #include <asm-i386/unistd.h>
    #else
      #error "Unhandled architecture"
    #endif
    STDOUT = 1

    .data
    #ifdef __x86_64__
    program_name:           .string "X86_64 AT&T assembler example 1\n"
    program_name_length   = 32
    #else
    program_name:           .string "X86 AT&T assembler example 1\n"
    program_name_length   = 29
    #endif
    exit_code:              .long 0

    .text
    .globl _start
    _start:

    #ifdef __x86_64__
            movq $__NR_write, %rax
            movq $STDOUT, %rdi
            movq $program_name, %rsi
            movq $program_name_length, %rdx
            syscall

    #elif __i386__
            movl $__NR_write, %eax
            movl $STDOUT, %ebx
            movl $program_name, %ecx
            movl $program_name_length, %edx
            int $0x80
    #endif


    #ifdef __x86_64__
            popq %rcx                       # argc
    #elif __i386__
            popl %ecx
    #endif


    argv:
    #ifdef __x86_64__
            popq %rsi                       # argv
            test %rsi, %rsi
            jz exit                         # exit if last (NULL) argument string
    #elif __i386__
            popl %ecx
            jecxz exit
    #endif


    #ifdef __x86_64__
            movq %rsi, %rdx
    #elif __i386__
            movl %ecx, %ebx
            xorl %edx, %edx
    #endif


    strlen:
    #ifdef __x86_64__
            lodsb
    #elif __i386__
            movb (%ebx), %al
            inc %edx
            inc %ebx
    #endif

            test %al, %al
            jnz strlen                      # continue if not end of string



    #ifdef __x86_64__
            movb $0x0A, -1(%rsi)            # replace NUL-byte with \n

            subq %rdx, %rsi                 # calculate buffer size
            xchg %rdx, %rsi                 # reorder for syscall conventions
            movq $__NR_write, %rax
            movq $STDOUT, %rdi              # file descriptor
            syscall
    #elif __i386__
            movb $0x0A, -1(%ebx)           # replace NUL-byte with \n

            movl $__NR_write, %eax
            movl $STDOUT, %ebx
            int $0x80
    #endif

            jmp argv                        # process next argument


    exit:
    #ifdef __x86_64__
            movq $__NR_exit, %rax
            movl exit_code, %edi
            syscall

    #elif __i386__
            movl $__NR_exit, %eax
            movl exit_code, %ebx
            int $0x80
    #endif
    #+end_src
* -----------------------------------
* play with fasm
** about syscall
   32-bits:
   define sys_5_edi edi
   define sys_4_esi esi
   define sys_3_edx edx
   define sys_2_ecx ecx
   define sys_1_ebx ebx
   define sys_n_eax eax
   int 80h
   -----------------------------------------------
   64-bits:
   1. syscall numbers:
      /usr/include/asm/unistd_64.h (in archlinux)
      /usr/include/asm/unistd_32.h (for x86)
   2. syscall parameters order:
      r9    ; 6th parameter
      r8    ; 5th parameter
      r10   ; 4th parameter
      rdx   ; 3rd parameter
      rsi   ; 2nd parameter
      rdi   ; 1st parameter
      rax   ; syscall_number
      syscall
      return register:
      rax   ; 1st
      rdx   ; 2nd
      preserved accross function call: rbx rbp esp r12 r13 r14 r15
   3. functions parameter (when linked with external libraries):
      r9    ; 6th param
      r8    ; 5th param
      rcx   ; 4th param
      rdx   ; 3rd param
      rsi   ; 2nd param
      rdi   ; 1st param
      call <library>
** kkk
   :tangle ./fasm-play/kkk.fasm
   #+begin_src fasm
   format elf64 executable 3

   ;; parameters order of linux syscall:
   define sys_6_r8  r8
   define sys_5_r9  r9
   define sys_4_r10 r10
   define sys_3_rdx rdx
   define sys_2_rsi rsi
   define sys_1_rdi rdi
   define sys_n_rax rax

   segment readable executable
   entry display_massage

   display_massage:

           push rdi
           mov sys_3_rdx,  massage_size
           mov sys_2_rsi,  massage
           mov sys_1_rdi,  1 ;; stdout
           mov sys_n_rax,  1 ;; sys_write
           syscall

           pop sys_1_rdi     ;; exit code argc
           mov sys_n_rax, 60 ;; sys_exit
           syscall

   segment readable writeable
   massage   db "kkk took my baby away !", 10
   massage_size = ($ - massage)
   #+end_src
** 用退出码返回数组的数中最大的数
   要想打印数字就要作编码转换
   :tangle ./fasm-play/max-of-array.fasm
   #+begin_src fasm
   ;;; purpose:
   ;;;        finds the maximum number in data items array
   ;;;
   ;;; variables:
   ;;;        edi - holds the index of the data item being examined
   ;;;        ebx - largest data item found
   ;;;        eax - current data item
   ;;;        data_items: contains the item data, 0 is used to terminate the data

   format elf64 executable 3

   ;; parameters order of syscall:
   define sys_6_r8  r8
   define sys_5_r9  r9
   define sys_4_r10 r10
   define sys_3_rdx rdx
   define sys_2_rsi rsi
   define sys_1_rdi rdi
   define sys_n_rax rax

   segment readable executable
   entry start
   start:
           mov r8, 0
           mov rax, [data_items + r8*8]
           mov rbx, rax

           ;; 上面在于要准备好循环开启时的三个寄存器的状态
           ;; 每次要进入循环的时候 都对三个寄存器的状态有约定:
           ;; r8  : 当前指向的数的索引
           ;; rax : 当前指向的数
           ;; rbx : 在比较rax之前 所知道的最大的数

   start_loop:
           cmp rax, 0
           je print_and_exit

           inc r8
           mov rax, [data_items + r8*8]

           cmp rax, rbx
           ;;  rax <= rbx
           jle start_loop
           ;;  rax > rbx
           mov rbx, rax
           jmp start_loop


   print_and_exit:
           mov sys_1_rdi, rbx
           mov sys_n_rax, 60
           syscall

   segment readable
   data_items dq 3,67,34,222,45,75,54,34,44,33,22,11,66,0
   #+end_src
** create_new_file.fasm
   #+begin_src fasm :tangle create-new-file.fasm
   syscall_read  = 0
   syscall_write = 1
   syscall_open  = 2
   syscall_close = 3
   syscall_exit  = 60

   STDIN  = 0
   STDOUT = 1
   STDERR = 2

   open_read         = 0
   open_write        = 1
   open_readAndWrite = 2

   open_creat      = 0100o
   open_rewrite    = 1000o ;; rewrite if file exist
   open_append     = 2000o

   open_excl       = 0200o ;; ensure that THIS call creates the file
   open_noctty     = 0400o
   open_nonblock   = 4000o
   open_nondelay   = open_nonblock
   open_sync       = 10000o
   open_async      = 20000o
   open_direct     = 40000o
       ;; to minimize cache effects of the I/O to and from this file.
   open_largefile  = 100000o
   open_directory  = 200000o
   open_nofollow   = 400000o ;; If pathname is a symbolic link, then the open fails.



   format elf64 executable 3

   ;; parameters order of syscall:
   define sys_6_r8  r8
   define sys_5_r9  r9
   define sys_4_r10 r10
   define sys_3_rdx rdx
   define sys_2_rsi rsi
   define sys_1_rdi rdi
   define sys_n_rax rax

   ;; parameters order of call <fun>:
   define fun_6_r9  r9
   define fun_5_r8  r8
   define fun_4_rcx rcx
   define fun_3_rdx rdx
   define fun_2_rsi rsi
   define fun_1_rdi rdi

   segment readable executable
   entry create_new_file

   create_new_file:

           mov     sys_3_rdx, input_buffer_size
           mov     sys_2_rsi, input_buffer
           mov     sys_1_rdi, STDIN
           mov     sys_n_rax, syscall_read
           syscall

           mov     qword [input_size], rax

           mov     sys_3_rdx, 110100100b
           mov     sys_2_rsi, open_readAndWrite or open_creat or open_rewrite
           mov     sys_1_rdi, filename
           mov     sys_n_rax, syscall_open
           syscall

           mov     qword [file_handle], rax

           mov     sys_3_rdx, qword [input_size]
           mov     sys_2_rsi, input_buffer
           mov     sys_1_rdi, qword [file_handle]
           mov     sys_n_rax, syscall_write
           syscall

           mov     sys_1_rdi, qword [file_handle]
           mov     sys_n_rax, syscall_close
           syscall


           mov     sys_1_rdi, 0
           mov     sys_n_rax, syscall_exit
           syscall

   segment readable writeable
   filename     db 'kkk',0

   input_buffer_size = 1000h
   input_buffer rb input_buffer_size

   input_size   rq 1
   file_handle  rq 1
   #+end_src
* ===================================
