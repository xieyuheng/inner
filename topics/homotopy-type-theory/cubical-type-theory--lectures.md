---
title: Cubical type theory -- Lectures
---

# Using elements of Equal as function

So called path type.

A term of type `Equal(A, a, b)` can be used
as a function `p: (Interval) -> A`,
such that `p(Interval::start) = a` and `p(Interval::end) = b`,
i.e. a path in space `A`,

```cicada
function equalPair(
  start: Pair(A, B),
  end: Pair(A, B),
  carPath: Equal(A, car(start), car(end)),
  cdrPath: Equal(B, cdr(start), cdr(end)),
): Equal(Pair(A, B), start, end) {
  // NOTE First we can eta-expend the pairs `start`, `end` to cons:
  //    Equal(Pair(A, B), start, end)
  // => Equal(Pair(A, B), cons(car(start), cdr(start)), cons(car(end), cdr(end)))

  equal carPath(Interval::start) = car(start)
  equal carPath(Interval::end) = car(end)

  equal cdrPath(Interval::start) = cdr(start)
  equal cdrPath(Interval::end) = cdr(end)

  let resultPath: Equal(Pair(A, B), start, end) =
    (i: Interval) => cons(carPath(i), cdrPath(i))

  equal resultPath(Interval::start) = cons(car(start), cdr(start))
  equal resultPath(Interval::end) = cons(car(end), cdr(end))

  // Thus by the definition of `Equal`, we have
  //   resultPath: Equal(Pair(A, B), cons(car(start), cdr(start)), cons(car(end), cdr(end)))

  return resultPath
}
```

```cicada
function equalCompose(
  implicit A: Type,
  implicit x: A,
  implicit y: A,
  implicit z: A,
  xyPath: Equal(A, x, y),
  yzPath: Equal(A, y, z),
): Equal(A, x, z) {
  equal xyPath(Interval::start) = x
  equal xyPath(Interval::end) = y

  equal yzPath(Interval::start) = y
  equal yzPath(Interval::end) = z

  let xzPath: Equal(A, x, z) =
    // NOTE But we can not just case over 0-level elements.
    (i: Interval) => match (i) {
      case (Interval::start) => xyPath(i)
      case (Interval::end) => yzPath(i)
    }

  equal xzPath(Interval::start) = x
  equal xzPath(Interval::end) = z

  return xzPath
}
```

Wishful thinking about `composePath`:

```cicada
function equalCompose(
  implicit A: Type,
  implicit x: A,
  implicit y: A,
  implicit z: A,
  xyPath: Equal(A, x, y),
  yzPath: Equal(A, y, z),
): Equal(A, x, z) {
  return (i: Interval) => match (i) {
    case (Interval::start) => xyPath(i)
    case (Interval::end) => yzPath(i)
    case (Interval::path) => composePath(xyPath, yzPath)
  }
}
```

Wishful thinking about a `path` keyword:

```cicada
function equalCompose(
  implicit A: Type,
  implicit x: A,
  implicit y: A,
  implicit z: A,
  xyPath: Equal(A, x, y),
  yzPath: Equal(A, y, z),
): Equal(A, x, z) {
  return (i: Interval) => match (i) {
    case (Interval::start) => xyPath(i)
    case (Interval::end) => yzPath(i)
    case (Interval::path) => path [ xyPath, yzPath ]
  }
}
```

# Lecture: Type-Theoretic Truncation Levels

[ [YOUTUBE](https://www.youtube.com/watch?v=LWQqE2JcDSQ&list=PL0OBHndHAAZrGQEkOZGyJu7S7KudAJ8M9&index=1) ]

A **mapping (function)** from `A` to `B` -- `f: (A) -> B`,
can be viewed as folding (embedding) of `A` in `B`.

Where `A` and `B` might be defined as higher inductive datatypes,
we also call them "space", "shape", "type", ...

- `f: (S(1)) -> A` -- `f` is a loop in `A`.
- `f: (S(2)) -> A` -- `f` is a twisted ball in `A`.

A shape `A` has **truncation level n**,
if there is no interesting folding of `S(m)` where `m > n`.
i.e. no interesting homotopy above dimension `n`.

Where "homotopy" can be viewed as structure generated by
paths, paths between paths, paths between paths between paths, ...

- **Xie:** The intrinsic higher algebraic structure of `A`.

```
No interesting homotopy above dimension n.
-------------------------------------------- [because S(m) are special homotopy]
No interesting folding of S(m) where m > n.
```

```
No interesting folding of S(m) where m > n.
-------------------------------------------- [TODO need prove]
No interesting homotopy above dimension n.
```

```cicada
function TruncationLevelMinusOne(A: Type): Type {
  return forall (x: A, y: A) Equal(A, x, y)
}

function TruncationLevelZero(A: Type): Type {
  return forall (x: A, y: A)
    forall (p: Equal(A, x, y), q: Equal(A, x, y))
    Equal(Equal(A, x, y), p, q)
}

function TruncationLevelOne(A: Type): Type {
  return (x: A, y: A)
    forall (p: Equal(A, x, y), q: Equal(A, x, y))
    forall (r: Equal(Equal(A, x, y), p, q), s: Equal(Equal(A, x, y), p, q))
    Equal(Equal(Equal(A, x, y), p, q), r, s)
}
```

TODO Recursive definition of `TruncationLevel(n, A)`.

- In the talk the names are `has-level` and `is-contr` (contractible).

  `is-contr` will be used as inductive base step of level -2.

  > In mathematics, a topological space X is contractible if the
  > identity map on X is null-homotopic, i.e. if it is homotopic to
  > some constant map.
  >
  > Intuitively, a contractible space is one that can be continuously
  > shrunk to a point within that space.
  >
  > -- https://en.wikipedia.org/wiki/Contractible_space

`is-contr` is also called `Singleton` in some papers.

- https://ncatlab.org/nlab/show/contractible+type

```cicada
function Singleton(X: Type): Type {
  return exists (c: X) forall (x: X) Equal(X, c, x)
}
```

# Lecture: Introduction to Cubical Type Theory (Part I)

[ [YOUTUBE](https://www.youtube.com/watch?v=6cLUwAiQU6Q&list=PL0OBHndHAAZrGQEkOZGyJu7S7KudAJ8M9&index=3) ]

```cicada
datatype Interval {
  start: Interval
  end: Interval
  path: endpoint [ start, end ]
}
```

Or say:

```cicada
datatype I {
  0: I
  1: I
  path: endpoint [ start, end ]
}
```

Favonia: The higher inductive type `Interval` is not a type.

Using `Interval` as an opaque coordinate system.

instead say:

```cicada
datatype S1 {
  base: S1
  loop: Equal(S1, base, base)
}
```

we say:

```cicada
datatype S1 {
  base: S1
  loop: (I) -> S1 with {
    case (loop(0)) => base
    case (loop(1)) => base
  }
}
```

In my way it would be:

```cicada
datatype Endpoint {
  start: Endpoint
  end: Endpoint
}

datatype S1 {
  base: S1
  loop: Skeleton(1, S1) with {
    Coordinate: Endpoint,
    attach(endpoint: Endpoint): Skeleton(0, S1) {
      case (Endpoint::start) => base
      case (Endpoint::end) => base
    }
  }
}

datatype Interval {
  start: Interval
  end: Interval
  path: Skeleton(1, Interval) with {
    Coordinate: Endpoint,
    attach(endpoint: Endpoint): Skeleton(0, Interval) {
      case (Endpoint::start) => start
      case (Endpoint::end) => end
    }
  }
}
```

```cicada
-------
S1: U

---------
base: S1

r: I
------------
loop(r): S1

// or say

---------------------
loop: (r: I) -> S1

--------------------
loop(0) = base : S1

--------------------
loop(1) = base : S1

target: S1
motive: (x: S1) -> U
baseCase: motive(S1.base)
loopCase: (i: I) -> motive(S1.loop(i))
loopCase(0) = baseCase : motive(S1.base)
loopCase(1) = baseCase : motive(S1.base)
---------------------------------------
elimS1(target, motive, baseCase, loopCase): motive(target)
```

The computational rule:

- **Xie:** A continuous function between cell-complexes
  is a function that preserves boundary.

```cicada
function elimS1(
  target: S1,
  motive: (x: S1) -> U,
  baseCase: motive(S1.base),
  loopCase: (i: I) -> motive(S1.loop(i)),
) -> motive(target) {
  return match (target) {
    case (S1.base) => baseCase
    case (S1.loop(i)) => loopCase(i)
    // Maybe with
    //   loopCase: motive(S1.loop)
    // instead of
    //   loopCase: (i: I) -> motive(S1.loop(i))
    // because we can not only specify map on the boundary of `S1.loop`,
    // we must also specify `S1.loop` maps to which element.
    case (S1.loop) => loopCase with {
      case (S1.loop(0)) => loopCase(0)
      case (S1.loop(1)) => loopCase(1)
    }
  }
}
```

We can not do `loop * loop` and `- loop` yet.

Understanding the path types.

```cicada
function A(i: I): Type {
  TODO
}

function M(i: I): A(i) {
  return match (i) {
    case (0) => the(A(0), N)
    case (1) => the(A(1), O)
  }
}
```

# Lecture: Cartesian cubical type theory, by Favonia

[ [YOUTUBE](https://www.youtube.com/watch?v=VbBDxVEu_bA&list=PLtIZ5qxwSNnzpNqfXzJjlHI9yCAzRzKtx&index=73) ]

```cicada
datatype Interval {
  start: Interval
  end: Interval
  path: endpoint [ start, end ]
}

function aPath(i: Interval): A {
  // TODO How case on `Interval::path`.
  return ...
}

function aSurface(i: Interval, j: Interval): A {
  // TODO How case on `Interval::path`.
  return ...
}
```
