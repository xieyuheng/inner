---
title: note on notation of calculus
---

# 關於語法

- 我對語法和語義之間的關係又有了新的理解
  這個新的理解就是去堅定我之前的理解
- 語境代表了一個語法的集合
  而在語境之間的相互轉換
  也需要被設計以語法
- 此處對用來轉換語境的語法如果有一致的設計
  那效果就很好
  所以用於轉換語境的語法
  應該被設計爲一個共享的語境
  當然 其他的語境可以實現自己的 用來轉換語境的語法
- 這是否又回到原來的
  語素分離 語法解析 語法解析樹的處理
  這種老過程了?

# 記

- 如同對新的人類語言的學習
  對新的程序語言的學習一樣
  我也尋找並學習新的數學語言
  自謂正統的數學家常常看不起這種新的數學語言
- 這裏所用的術語中的 distinction 這個詞
  就是我所說的基本等詞了
  然而對這個概念的不同認識在於
  我不認爲應該限制可以被識別的物體的個數
  而這裏的觀點實去限制其基本集合形狀與操作於最少

# border-fix notation

## 記

- 本節討論的內容來自
  [a calculus of number based on spatial forms]
  [jeffrey james]
- 首先 borderfix notation
  之好處在於它能夠用以說明作用範圍
- 此文作者自稱並不熟悉數學
  而對傳統數學語言的流弊有很多有趣的見解
  對當今程序語言的設計缺陷的批判是我熟悉的
  而對數學語言之最最基本之符號
  我缺也未有諸多質疑
- 但是又確實如作者所承認的
  文章的大部分
  在我看來
  都是因爲不習古典的數學結構
  而發的空泛堂皇之言
  更不用說對編程還有程序語言的熟悉了
- 但是又如何呢
  我常說
  只要有足夠的好奇心和興趣
  在沒有先導性的識的前提下
  一個人也能對他所感興趣的問題形成有效的戲考與討論
  ><><>< 應該怎麼處理這個矛盾呢? 我之前的觀點有什麼問題嗎?
- notation 有 prefix infix postfix
  而這裏的是 borderfix
  如果說 具有 結合性和交換性[對稱性]的二元函數 適合使用 infix
  那麼 一元函數 就適合使用 borderfix
- 有了這種認識之後本文的論點就明白而顯然了
  用 borderfix 以記
  exp 爲 ()
  log 爲 []
  以此爲基礎利用一個同態 就能用加法來表示乘法了
  這樣就產生了這篇文章中的大論
- 考慮蟬語中對 borderfix notation 的使用
  就能獲得對這篇文章的一個更爲中肯的評價
  即 borderfix notation 的對稱性減輕了閱讀時的認知負擔
  還在於
  多樣的表達方式代表了多樣的理解方式
  而在思想上對多樣性的追求總是好的

## 引

- 批判古典記號系統的曖昧不明
- 批判之一在於符號的抽象性掩蓋了所指之性質
  致使
  人對數的思想直覺
  與人在計算中對符號的形式操作相脫節
- 作者非常強調數學在計算當中所體現出來的動態性
  而在我看來數之符號與其計算性質相分離
  正是 數學結構之靜態性質比計算本身更重要 之體現
- 在我看來只把自己所發現的有趣的記號系統說清楚就足矣了
  不必有此泛泛之談
- 並且更重要的是去分析自己所發現的記號系統的性質
  然而這種分析顯然已經超出了本文作者的能力
- 有趣之處在於運算律被以一種新穎的[更好的]方式表達着

## 前人之作

### 記

- 其實其中

### spencer-brown numbers

- only one distinction
- 獨一的符號本身是數的同時
  其變形規則又使
  以不同方式擺放這個獨一的符號時
  就編碼了運算本身

### kauffman numbers

- 以 乘以二 爲 borderfix 一元函數
- 兩個泡泡碰到一起的時候
  其邊界可以融合
- [正負的]點可以進出泡泡
  就像細胞內外的電的[離子的]平衡一樣

### bricken numbers

## 更多的討論

- 相當於是 exp 和 log 爲基礎的記號系統
  [即 就 exp 和 log 而優化]的
- 加 a b
  乘 ( [ a ] [ b ] )
  冪 ( ( [ [ a ] ] [ b ] ) )
- 乘法結合律 將被表示地很難看
- 由其對前三級運算的表達可以發現
  這種符號系統能夠以很自然地方式表達出運算的
  1) 等級
  2) 對稱性
- 這裏所引入的基本運算律爲
  ( N [ A B ] )
  ( N [ A ] ) ( N [ B ] )
  這是在這種就 exp 和 log 優化的記號系統中
  對 乘法對加法的分配律 的自然的推廣
- 上面的運算律即是
  exp ( N + log ( A + B ) )
  exp ( N + log ( A ) ) + exp ( N + log ( B ) )
  用 scheme 的語法就是
  ( exp ( add N ( log ( add A B ) ) ) )
  ( add  ( exp ( add N ( log A ) ) )  ( exp ( add N ( log B ) ) ) )
- 可見 這裏所使用的語法
  確實非常適合用來表達這個運算律

## 相位

- 這裏有很多錯誤的推導
- J == [<()>] == log -1
  這個 帶有 <> 的值
  可以用來消除其他表達式中的 <>
- 而 -1 == exp (i * pi)
  所以 log -1 == i * pi mod 2 * pi
  這樣 J 就能用來幫助表示複數了

# mix-fix notation

- example

  ``` lisp
  1 2 (add) = 1 (add 2) = (add 1 2)


  2 1 (sub)
  2
  1 2 (add)
  (fun)

  2 1 (sub)
  (fun 2
       1 2 (add))

  (fun (sub 2 1)
       2
       (add 1 2))


  2 1 (sub) <:arg1
  2 <:arg2
  1 2 (add) <:arg3
  (fun)

  2 1 (sub) <:arg1
  (fun 2 <:arg2
       1 2 (add) <:arg3)

  2 1 (sub) <:arg1
  (fun (arg2:> 2)
       (arg3:> 1 2 (add)))

  (fun (arg1:> 2 1 (sub))
       (arg2:> 2)
       (arg3:> 1 2 (add)))

  (fun (arg1:> (sub 2 1))
       (arg2:> 2)
       (arg3:> (add 1 2)))
  ```
- 蟬語 與 蟬圖 的 對應
  三種括號的使用方式應該被重新設計了
  [儘管 蟬圖的語義基本已經固定了]
- 感到 蟬圖 與 蟬語 之間的聯繫很單薄了
  這都源自 蟬圖 中對一元化的要求
  ``` cicada
  x <:name1 (k)
  y <:name2 ()

  { x <:name1 (k) }
  { y <:name2 ()  }

  x <:name1 (k #1)
  y <:name2 ()

  x <:name1
  (k (name2:> y))

  x <:name1
  {k (name2:> y)}

  (k (name1:> x)
     (name2:> y))
  ```
- 語法設計無法決定
  但是沒有關係
  利用語境機制保持靈活性
  之後再作決定
