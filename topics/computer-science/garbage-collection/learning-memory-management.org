#+TITLE: learning memory management
#+AUTHOR: XYH(谢宇恒)
#+EMAIL: xyheme@gmail.com


* note
1. 可以发现当用free-list来实现gc时
   每次cons都伴随这对free-list的副作用
   >< 可不可以设计更丰富的这种``伴随副作用''以达到常数时间内的分配 ???
2. 这里的free-list是一个线性的列表
3. 需要被计算联通性的图是一个二叉有向图(可能有圈)
   除了从某些根出发进行遍历之外没有更好的方式能够让机器识别出这个图了吗 ???
   注意 每次cons就是在添加一个有向二叉到有向图中
4. 注意 如果那个进行遍历的递归函数用到了栈
   那么当图很大而复杂的时候栈就非常容易溢出
5. 对于标记与清除算法来说
   愚蠢的是只有完全标记好之后才能知道那些内存是自由的
   也就是说如果标记过程进行到了一半 那就根本没用 因为为还是不知道那些内存是自由的
   而swap算法就克服了这个弱点
   但是swap算法没法实现我需要的性状
6. 对于我的forth系统来说
   对于不同的用户空间
   我甚至能使用不同的内存管理机制
   1) 我可以有一个用户空间
      在其中我实现类lisp的cons数组来进行动态内存管理
   2) 我也可以有一个用户空间
      在其中使用类C的手动内存管理
   3) 我甚至可以在不同的用户空间中实验不同的gc算法
   4) 我体会到一种灵活性
      这几乎使得我再次不必在性状的选择上彷徨不前
      但是这种灵活性来自哪里??
      我并没有模块系统 也没有面向对象
      这种灵活性是因为我有一个静态的核心为基础吗 ???
7. 如果我把字符串实现为字符的list
   那么我必须约定方便的reader和writer
8. 在给我的forth系统实现gc的时候一定要注意设计良好的报错机制
   以使得当后面写的函数出现错误的时候
   我要能分辨出来是gc的错误还是所写的函数的错误
9. 注意也许我需要先明确我的forth系统中的数据类型之后才能写好一个gc
   要知道 这个forth系统已经有一个静态的核心了
   而一个gc和这个gc所工作于其中的用户空间是作为这个静态核心的扩展部分的
   所以要先仔细考虑可能出现的冲突
* Allocation
** First fit
In the first fit algorithm,
the allocator keeps a list of free blocks (known as the free list)
and, on receiving a request for memory,
scans along the list for the first block
that is large enough to satisfy the request.
If the chosen block is significantly larger than that requested,
then it is usually split,
and the remainder added to the list as another free block.
** Buddy system
In a buddy system,
the allocator will only allocate blocks of certain sizes,
and has many free lists, one for each permitted size.
The permitted sizes are usually either powers of two,
or form a Fibonacci sequence (see below for example),
such that any block except the smallest
can be divided into two smaller blocks of permitted sizes.

When the allocator receives a request for memory,
it rounds the requested size up to a permitted size,
and returns the first block from that size's free list.
If the free list for that size is empty,
the allocator splits a block from a larger size and returns one of the pieces,
adding the other to the appropriate free list.

同时我也可以想像被回收的连续的很多小的自由内存块如何被重新声明为大的自由内存块

但是当我如此极端地用list来实现所有其他的数据结构时
(比如 用8 bytes来编码一个字符)
Buddy system就没有必要了
** Suballocators
Suballocators are usually written for one of the following reasons:
1. To avoid general inefficiency in the system memory manager;
2. To take advantage of special knowledge of
   the application's memory requirements that
   cannot be expressed to the system memory manager;
   + 但是注意 这样的话 一旦application's memory requirements改变
     那么后果就不堪设想
3. To provide memory management services that
   the system memory manager does not supply.
* Recycling
** Tracing collectors
*** note
Automatic memory managers that
follow pointers to determine which blocks of memory
are reachable from program variables (known as the root set)
are known as tracing collectors.
The classic example is the mark-sweep collector.
*** Mark-sweep collection
In a mark-sweep collection,
the collector first examines the program variables;
any blocks of memory pointed to are added to a list of blocks to be examined.
For each block on that list,
it sets a flag (the mark) on the block to show that it is still required,
and also that it has been processed. (这样就处理了循环)
It also adds to the list any blocks pointed to by that block
that have not yet been marked.
In this way, all blocks that can be reached by the program are marked.

In the second phase,
the collector sweeps all allocated memory,
searching for blocks that have not been marked.
If it finds any, it returns them to the allocator (free-list) for reuse.

The two drawbacks of simple mark-sweep collection are:
1) It must scan the entire memory in use before any memory can be freed;
2) It must run to completion or, if interrupted, start again from scratch.

If a system requires real-time or interactive response,
then simple mark-sweep collection may be unsuitable as it stands,
but many more sophisticated garbage collection algorithms
are derived from this technique.
*** Copying collection
如果我统一用list来实现所有其他的数据结构 那么Copying collection就是没必要的
*** Incremental collection
Older garbage collection algorithms relied on being able to start collection
and continue working until the collection was complete, without interruption.
This makes many interactive systems pause during collection,
and makes the presence of garbage collection obtrusive.

Fortunately, there are modern techniques
(known as incremental collection)
to allow garbage collection to be performed in a series of small steps
while the program is never stopped for long.
In this context, the program that uses and modifies the blocks
is sometimes known as the mutator.
While the collector is trying to determine
which blocks of memory are reachable by the mutator,
the mutator is busily allocating new blocks,
modifying old blocks,
and changing the set of blocks it is actually looking at.

Incremental collection is usually achieved with
either the cooperation of the memory hardware or the mutator;
this ensures that, whenever memory in crucial locations is accessed,
a small amount of necessary bookkeeping is performed
to keep the collector's data structures correct.

>< 我没明白这里所描述的东西的实现方式
*** Conservative collection
很愚蠢
有些语言因为缺少地址类型数据而无法实现gc

Although garbage collection was first invented in 1958,
many languages have been designed and implemented
without the possibility of garbage collection in mind.
It is usually difficult to add normal garbage collection to such a system,
but there is a technique,
known as conservative garbage collection, that can be used.

The usual problem with such a language is that
it doesn't provide the collector with information about the data types,
and the collector cannot therefore determine what is a pointer
and what isn't.
A conservative collector assumes that anything might be a pointer.
It regards any data value that looks like a pointer
to or into a block of allocated memory as preventing the recycling of that block.

Note that, because the collector does not know for certain
which memory locations contain pointers,
it cannot readily be combined with copying garbage collection.
Copying collection needs to know where pointers are
in order to update them when blocks are moved.

You might think that conservative garbage collection
could easily perform quite poorly,
leaving a lot of garbage uncollected.
In practice, it does quite well, and there are refinements
that improve matters further.
** Reference counts
*** note
A reference count is a count of how many references
(that is, pointers) there are
to a particular memory block from other blocks.
It is used as the basis for some automatic recycling techniques
that do not rely on tracing.

考虑一下那个二叉有向图
用引用计数实现的gc也是可以想像的
但是loop就有问题了
一个孤立的loop不能被引用到 但是它的引用计数器却是不是0
*** Simple reference counting
In a simple reference counting system,
a reference count is kept for each object.
This count is incremented for each new reference,
and is decremented if a reference is overwritten,
or if the referring object is recycled.
If a reference count falls to zero,
then the object is no longer required and can be recycled.

Reference counting is frequently chosen
as an automatic memory management strategy
because it seems simple to implement
using manual memory management primitives.
However, it is hard to implement efficiently
because of the cost of updating the counts.
It is also hard to implement reliably,
because the standard technique cannot reclaim objects connected in a loop.
In many cases, it is an inappropriate solution,
and it would be preferable to use tracing garbage collection instead.

Reference counting is most useful in situations where
it can be guaranteed that there will be no loops
and where modifications to the reference structure
are comparatively infrequent.
These circumstances can occur in some types of database structure
and some file systems.
Reference counting may also be useful
if it is important that objects are recycled promptly,
such as in systems with tight memory constraints.
*** >< Deferred reference counting
The performance of reference counting can be improved
if not all references are taken into account.
In one important technique, known as deferred reference counting, only references from other objects are counted, and references from program variables are ignored. Since most of the references to the object are likely to be from local variables, this can substantially reduce the overhead of keeping the counts up to date. An object cannot be reclaimed as soon as its count has dropped to zero, because there might still be a reference to it from a program variable. Instead, the program variables (including the stack) are periodically scanned, and any objects which are not referenced from there and which have zero count are reclaimed.

Deferred reference counting cannot normally be used unless it is directly supported by the compiler. It's more common for modern compilers to support tracing garbage collectors instead, because they can reclaim loops. Deferred reference counting may still be useful for its promptness -- but that is limited by the frequency of scanning the program variables.
*** >< One-bit reference counting
*** >< Weighted reference counting
