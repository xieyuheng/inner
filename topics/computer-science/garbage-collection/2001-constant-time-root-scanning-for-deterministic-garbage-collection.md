---
title: constant-time root scanning for deterministic garbage collection
author: fridtjof siebert
year: 2001
---

# 动机

[2025-11-19] 在实现 x-lisp runtime 的 GC，
需要知道如何发现寄存器中的 root。

# Abstract

> Root scanning is the task of identifying references to heap objects
> that are stored outside of the heap itself, in global and local
> variables and on the execution stack. Root scanning is particularly
> difficult within an incremental garbage collector that needs to be
> deterministic or give hard realtime guarantees. Here, a method that
> allows exact root scanning is presented.

> The basic idea is to ensure that copies of all root references exist
> on the heap whenever the garbage collector might become active. This
> approach reduces the root scanning phase of the garbage collection
> cycle to an efficient constant-time operation.

constant-time 的前提看来是时刻准备着扫描好的 roots。

# 2 Related Work

> Stichnoth et. al [15] show that it is even feasible to avoid the
> need for GC-points and instead provide exact information on live
> root references for every machine instruction generated by a
> compiler. This avoids the need to resume suspended threads when
> garbage collection is triggered. GC maps are needed to hold the
> exact information, the space required for theses maps is about 20%
> of the size of the generated code.

> Christopher presented an interesting approach that is based on
> reference counting [16] and that avoids the need of scanning root
> references that are stored outside of the heap [17]. The idea is
> that all objects with a reference count that is higher than the
> number of references from other heap objects to this object must be
> reachable from a root reference outside the heap. All the objects
> reachable from such a root reference are then used as the initially
> marked set in the marking phase of the garbage collector. The
> disadvantage is the high runtime overhead that is required to keep
> the reference counts accurate: any assignment between local
> reference variables needs to ensure correct adjustment of the
> reference counts.

这个方案很有趣。

[17] 所引用的这篇论文非常短，可以看一下：

- 1984-reference-count-garbage-collection--thomas-w-christopher.pdf

[16] 关于引用计数，所引用的是：

- Donald E. Knuth: The Art of Computer Programming, Volume 1

# 3 The Garbage Collector

> The technique for root scanning presented here is largely
> independent of the actual garbage collection algorithm. The
> explanation is therefore limited to the description of the
> mechanisms relevant for root scanning.

就是说 root scanning 问题是相对独立的。

> For compacting or copying techniques, additional difficulties might
> arise when updating of root references is required. The use of
> handles would be a solution here.

# 4 Synchronization Points

> An important prerequisite for the root scanning technique presented
> in the next section is to limit thread switches and garbage
> collection activity to certain points during the execution of the
> application. The idea has been presented earlier [18] and similar
> mechanisms have been employed earlier [19]. When synchronization
> points are used, thread switching at arbitrary points during the
> execution is prohibited. Instead, thread scheduling can occur only
> at synchronization points that are automatically inserted in the
> code by the compiler or virtual machine. The implementation has to
> guarantee to insert the code required at a synchronization point
> frequently enough to ensure short thread pre-emption delays. Since
> thread switches are restricted to synchronization points, root
> scanning might also only occur at these points. A different thread
> might run and cause garbage collection activity only if all other
> threads are stopped at synchronization points.

fil-c 的 gc 应该就是在这个基础上再使用额外的技巧，来避免 stop：

- https://fil-c.org/fugc
- https://fil-c.org/safepoints

# 5 Constant Time Root Scanning

> The idea presented here is to ensure that all root references that
> exist have to be present on the heap as well whenever the garbage
> collector might become active.  This means that the compiler has to
> generate additional code to store references that are used locally
> on the program stack or in processor registers to a separate root
> array on the heap. Each thread in such a system has its own private
> root array on the heap for this purpose.

> All references that have a life span during which garbage collection
> might become active need to be copied to the root array.
> Additionally, whenever such a reference that has been stored is not
> used anymore, the copy on the heap has to be removed to ensure that
> the referenced object can be reclaimed when it becomes garbage. The
> compiler allocates a slot in the current thread’s root array for
> each reference that needs to be copied to the heap. The root array
> might be seen as a separate stack for references.

> To ensure that the garbage collector is able to find all root
> references that have been copied to the root arrays, it is
> sufficient to have a single global root pointer that refers to a
> list of all root arrays.

# 6 Saving References in Root Arrays

> Saving local references in root arrays on the heap is performance
> critical for the implementation: Operations on processor registers
> and local variables in the stack frame are very frequent and
> typically cheap. Storing these references in the root arrays and
> executing the write barrier typically requires several memory
> accesses and conditional branches. To achieve good performance the
> number of references that are saved to the heap must be as small as
> possible.

> The garbage collector might become active at any synchronization
> point.  From the perspective of a single method, the collector might
> as well become ac tive at any call, since the called method might
> contain a synchronization point. It is therefore necessary to save
> all local references whose life span contains a synchronization
> point or a call point. For simplicity of terms, synchronization
> points and call points will both be referred to as GC-points in the
> following text.

如果每个 call 都认为带有潜在的 synchronization point，
那么所有保存了 pointer 的 callee saved register，
都需要被 caller save。

如果不需要 copy 的话，也可以不保存寄存器，
而是复制 pointer 到 shadow stack 中。
只有不需要 copy 时才可以，
因为这样会有两个位置保存着 pointer。

> It is not clear when the best time to save a reference would
> be. There are two obvious possibilities:
>
> - 1. Late saving: All references that remain live after a GC-point
>   are saved directly before the GC-point. The entry of the root
>   array that was used to save the reference will then be cleared
>   right after the GC-point.
>
> - 2. Early saving: Any reference with a life span that stretches
>   over one or several GC-points is saved at its definition. The
>   saved reference is cleared at the end of the life span, after the
>   last use of the reference. Note that a life span might have
>   several definitions and several ends, so code to save or clear the
>   reference will have to be inserted at all definitions and ends,
>   respectively.

> It is not obvious which of these two strategies will cause less
> overhead. Early saving might cause too many references to be saved,
> since the GC-points within the life span might never be reached,
> e.g., if they are executed within a conditional statement. Late
> saving might avoid this problem, but it might save and release the
> same reference unnecessarily often if its life span contains several
> GC-points that are actually reached during execution.

我觉得显然 late saving 更高效，
这里说的第二种情况（比如一次函数调用中出现多次 GC）很少见。
如果出现了，这里的 saving 也不是瓶颈，因为 GC 不会频繁出现。

- 这样想的前提是，不是所有的 call point 都是 synchronization point，
  每次 saving 的时候 save 所有的 register，
  而不是这个函数所知的保存了 pointer 的 register。

  - 因为有些没有用到的 callee saved register 中，
    可能保存了 parent 函数中所用到的 pointer。

- 这种方案的前提是：
  register 中（callee saved register 中）所能保存的，
  只能是 tagged value。

early saving 等同于每次在寄存器里保存一个 pointer 的同时，
需要在 shadow stack 里保存一个备份。

- 这个方案的好处是不需要假设 register 中只能保存 tagged value。

  如果想让 C 函数能够调用 x-lisp 函数，
  就不能有这个假设，因为 C 函数的 register 中可能保存任何 value。

  fil-c 用的可能就是这种方案。

  但是对于动态类型语言而言，
  所有的 tagged value 都有可能是 pinter，
  也就是说要么所有保存在寄存器中的 value 都要有备份，
  要么根据 tag 来判断是否需要备份。

# 7 The Jamaica Virtual Machine

> Jamaica is a new implementation of a Java virtual machine and a
> static Java compiler that provides deterministic hard real-time
> garbage collection.

# 8 Write Barrier in Jamaica

> The purpose of a write barrier is to ensure that all reachable
> objects are found by the incremental garbage collector even though
> the memory graph is changed by the application while it is traversed
> by the collector.

> The write barrier has to ensure the invariant that no black object
> refers to a white object (alternative invariants and write barriers
> have been presented by Pirinen [24]).

# 9 Analysis Using the SPECjvm98 Benchmark Suite

这里对比 late saving 和 early saving 所保存的 pointer 数量，
反而是 early saving 保存的少，
这与我所设想的实现方式不符。

可能是我对方案的理解，
已经与论文所描述的方案有出入了。
