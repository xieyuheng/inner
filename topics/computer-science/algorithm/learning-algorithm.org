#+title: 算法學記 / learning algorithm

* 算法分析

*** 漸進表達式 [asymptotic notation]
    * 忽略依賴於機器的常數
    * 不是看運行時間
      而是看運行時間作爲輸入規模的函數的增長
      [這是常識性的]

* 僞雙射 [散列表] [hash-table]

*** 應用
    * 用以實現 "名" 的概念
      字符串的散列表
      形成任意有限長度的字符串集
      到有限整數集之間的僞雙射
      把對字符串之等詞
      轉化成數字之等詞
    * 我以這種應用爲手段
      來形成具體的討論

*** 術語
    | 術語 | 傳統術語       |
    |------+----------------|
    | 義域 | 定義域         |
    | 值域 | 值域           |
    | 義   | 定義域中的元素 |
    | 值   | 值域中的元素   |
    | 射   | 映射           |
    | 逆   | 逆映射         |

*** 正名
    * 因爲 我強調上面的應用
      所以 我稱之爲 僞雙射
      [而不是 散列表]
      或者說
      利用一個表
      來把不單的映射變成僞雙射
    * 利用一個表來實現並不存在的雙射
      其雙射之不存在 在於 義域基數大 而值域基數小
      形成僞雙射的目的是 空間換時間
      (查) 這個操作的平均時間複雜度接近常數
    * 基本操作
      * 查 ::
           參看某一義是否在表中
      * 添 ::
           添義於表
           則僞雙射能夠處理這個義到值的射
           注意
           這個裏的 (添)
           其實是 (試添)
           因爲當一個義域中值被添加過之後
           就不必再次添加了
           所以
           (添) 其實是在 (查) 的基礎上實現的
           注意
           添加義域中值的順序不同
           所形成的雙射就可能不同
      * 刪 ::
           從表中刪除某一義域中值
    * 作爲 僞雙射
      其基本操作就是映射與逆映射
      這些基本操作是以上面的底層操作爲基礎實現的
      注意
      爲了或者所需要的僞雙射本身
      只需要 (添) 這一個操作
      * 射 ::
           (查) 然後按照找到與否
           直接返回值
           或 (添) 然後返回值
      * 逆 ::
           (查) 應該是能找到的
           此時取出義即可

*** 衝突與分類
    * 僞雙射
      其實並不是單射
      其中不單之處會引起衝突 [collision]
    * 衝突出現時
      給引起衝突的數據分配空間的方式有兩種
      1. 外部鏈表 [chaining]
      2. 表內探尋 [open addressing]

*** 外部鏈表 [chaining]
    * 需要額外實現外部的鏈表
    * 易於實現 (刪)
    * 表可以過載

*** 表內探尋 [open addressing]
    * 不易實現 (刪)
      其實
      當需要用僞雙射來實現等詞時
      爲了等詞的穩定性
      就不能去實現 (刪) 這個操作
    * 當表接近滿載時性能急劇下降
    * 這裏處理衝突的方式是
      當衝突發生時
      探尋[probe]表內另外一個位置
      探尋以一個計數器爲參數
      計數器記錄衝突次數
      計數器的值從一開始
      到表的大小而結束
      注意
      此時表不能過載
      因爲衝突次數不超過值域的大小 即表的大小
      探尋函數必須是一個值域上的置換
      即值域到值域的雙射 且不能有不動點
      探尋函數可以用以下幾種
      1. 線性的平移 [linear probing]
         即循環置換
      2. 二次函數外加取模所形成的置換 [quadratic probing]
         此時要選取常熟
         以使得所形成的探尋函數是置於的置換
      3. 其他複雜的函數
         此時 探尋函數以衝突次數爲參數 的同時
         還可以以發生衝突的位置爲參數
         也就是可以形成的是值域上的二參數變換羣
         而之前的都是單參數的
         其實
         之前的也是雙參數的
         只不過 hash (k i) 對 i 求一階差分之後
         k 這個變量就消失了
      4. 算兩次 [double hashing]
         把義用兩次 以增加隨機性
         每個義都已經存到軌道基本點上了
         所以看每個軌道基本點就能找到其軌道
      5. 用其他的隨機數
         這個隨機數要被保存在軌道基本點上
         用以重新找到軌道
      從上到下依賴逐漸增多
      1 2 3 不依賴義和外界
      4 依賴義
      5 完全依賴外界
      也就是說每個軌道本身可能是相當任意的
      用以生成這些軌道的函數的性質是完全未知的

*** 數論
    * 上面已經引出了某些有趣的數論問題了

*** 小技巧
    * 以字符串的僞雙射爲例
      使用 表內探尋 的方式來解決衝突
      下面一些小技巧值得注意
      1. 可以在表中的每一欄裏配置一個域
         用以記錄上次探尋函數被調用的次數
         這個次數可以作爲 (查) 的終止條件
         否則 若令 (查) 在空的位置終止
         可能會因探尋到別的欄所引起的衝突
         而這是沒有必要的
      2. 可以在表中的每一欄裏配置一個域
         用以記錄衝突的起點[如果有衝突的話]
         外加上這個域之後
         我就能恢復所有衝突的歷史[部分歷史]
         包括每個欄所引起的衝突的次數
         還有部分序關係
         因爲
         以一個欄爲起點 探尋函數 能形成一個
         以 上次探尋函數被調用的次數 爲長度的
         值域中的軌跡
         而這個軌跡上每個點是否因這一欄而被佔據
         也是被清楚標明的
         這樣
         雖然就每一點而言可以恢復衝突的序關係
         但是 全局的 點進入的順序是不知道的
      3. 注意
         這樣把實現方式變複雜了之後
         (添) 就不能重用 (查) 了

*** 錯誤處理
    * 表內探尋時
      注意對表滿載時的錯誤處理
    * 用鏈表時 也許設置一個載入率的上線

*** 函數的選取 [hash-function]
    * 首先是義域之數據到數字的映射
      例如字符串到數字的映射
      這一步之後
      我們就能專注於 義域與值域
      都是有限自然數集的情況了
    * 其次是大的數字到小的值域的映射
      1. 表的大小必須是素數
         作一些運算
         最後模這個素數即可
      2. 表的大小是二的方冪
         作一些運算
         最後
         乘以一個無理數 然後取其小數部分
         再乘以表的大小 然後取其整數部分
         所選取的無理數甚至可以不是代數數
         所得到的函數的數論性質將是很有趣的
         並且要知道
         這裏的整個運算綜合起來
         是很容易被處理成整數的乘法的
         這樣就避免了對浮點數的運算
    * 細心選取的函數使得衝突數量減少

*** 利用一族函數與隨機性 [universal hashing]
    * 在多個函數中隨機選擇
      以避免特意的輸入引起過多的衝突
      而使性能下降

*** 完美僞雙射 [perfect hashing]
    * 完美僞雙射 [perfect hashing]
      當需要被映射的值的集合
      作爲義域的子集固定了之後
      就可以實現雙射
      美其名曰 完美僞雙射
    * 還是用空間換時間
      只不過需要仔細選取所使用的函數而已
    * 要知道
      理論上這種函數的存在性是顯然的
      只不過要保證其計算的快速
    * 有要知道
      可以選取一個函數的集合
      對於固定的義域的子集
      嘗試在這個集合中找完美僞雙射
      但是在這個集合中其存在性可能是難以證明的

*** 其他性狀
    * 調整大小 [resizing]
      使得初始時的表可以較小
      以節約空間的使用

*** 對性能的分析
    * 對性能的分析也能構成一些有趣而具體的數學題目

* 有向圖 [directed-graph]

*** 分類
    |        | 不應用矩陣代數 | 用矩陣代數       |
    |--------+----------------+------------------|
    | 點主導 | 刺球列表       | 點點相鄰關係矩陣 |
    | 邊主導 | 點對列表       | 點邊相鄰關係矩陣 |

*** 刺球列表 [adjacency list]
    * 當圖稀疏時
      [邊數 遠小域 點數之二次方 時]
      適合用這種表示
    * 方便點的添加和刪除

*** 點對列表 [vertex pair list]
    * 每個邊對應 點對列表 中的一對點
    * 方便邊的添加和刪除
      因此在邏輯編程語言的設計中
      被用來實現格

*** 點點矩陣 [adjacency matrix]
    * 點點相鄰關係所形成的離散二維圖像
      橫縱座標階爲點
      矩陣中數值的語義可以是邊的長度
      邊的無向性就是矩陣的對稱性
    * 形成矩陣的目的是 利用矩陣的代數運算
      這些代數運算的語義很有趣
      有時能給出圖的某些謂詞的快速算法
    * 很容易從刺球列表得到點點相鄰關係矩陣
    * 當圖稠密時
      或者 當需要快速的判斷是否有一條邊鏈接某兩點時
      適合用這種表示

*** 點邊矩陣 [incidence matrix]
    * 點邊相鄰關係所形成的離散二維圖像
      橫縱座標分別爲點和邊
      矩陣中數值之正負的語義就是有向邊的出與入
      又比如 數值之大小可以編碼 從點的角度來看邊的類型 等等
    * 形成矩陣就能用矩陣的代數運算來處理
      這些代數運算的語義很有趣
      有時能給出圖的某些謂詞的快速算法
    * 很容易從點對列表得到點邊相鄰關係矩陣

*** 另類
    * 把點對其他點的地址的保存
      作爲有向邊的語義
      稱之爲 存址爲邊

*** 存址爲邊
    * 從一個點到另一個點的速度很快
    * 想像一個圖的編輯器
      一些小精靈在編輯這個圖
      而每個小精靈就是一個

*** 圖的遍歷
    * 好像圖的每個節點中買藏着寶藏一樣
      遍歷以尋寶

*** 最小支撐樹 [minimum spanning tree]

* 堆 [heap]

*** 正名
    * heap 這個詞來源於 heapsort 這個算法
      而用 heap 這個術語來代表 被垃圾回收器所管理起來的內存
      是術語濫用的例子

*** ><
    * 用自然數給二叉樹標號
      自然數本身又對應於數組
      這樣就自然把數組視爲了二叉樹
    * 要求序關係 就得到 max-heap 和 min-heap

*** priority queue
