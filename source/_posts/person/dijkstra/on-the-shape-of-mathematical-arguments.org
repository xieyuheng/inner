#+title: On the shape of mathematical arguments

* >< a termination argument

* note

  - 值得一提的是這本書的作者 van Gasteren
    是一位女性

  - 只要強調某些常識性的原則
    就 敘述論證而言
    很多的風格選擇問題
    就不成爲題了
    該遵從什麼樣的約定將是顯然的

  - 形式化 應該幫助數學家思考
    而不應該成爲數學家的負擔
    而這本書的核心結論將是
    形式化 有利無害
    [當然進行形式化的過程要複合一定的原則]

  - 重要的論點是
    - 別去命名沒有後必要命名的東西
    - 千方百計以維護對稱性

  - 一個錯誤是
    作者的在敘述的時候把自己限制在線性的文本當中
    整本書連一副圖都沒有
    用笨拙的語言描述很久也描述不好的場景
    通過一副圖就能很容易來說明
    作者沒有認識到這一點

* >< a problem on bichrome 6-graphs

* >< proving the existence of the euler line

* in adherence to symmetry

  - 不要給那些
    在論證中根本不會出現的
    全局變量[比如序列的長度]
    以名字

  - 這是關於古典的不等式的
    在敘述方面
    也許
    先給出古典的大家熟悉的敘述方式
    再介紹新的敘述方式 會更好一些

  - 兩種敘述方式的區別在於
    |------------------+----------------|
    | 古典             | 新             |
    |------------------+----------------|
    | 兩個數列         | 兩個無序數集   |
    |------------------+----------------|
    | 數列的長度       | 集合 其大小    |
    | 數列中的每個元素 | 其元素         |
    | 都有名字         | 都無名         |
    |------------------+----------------|
    | 規定 單調性      | 一一映射       |
    | 並命名 置換      | 以說明對應關係 |
    | 以說明對應關係   |                |
    |------------------+----------------|
    | 展開以定義和     | 遞歸以定義和   |
    |------------------+----------------|
    | 結論很直觀       | 利用兩個引理   |
    | 但是這裏的敘述   | 來敘述結論     |
    | 稍顯笨拙         |                |
    |------------------+----------------|

  - 可見
    這種敘述風格的衝突
    在數論和數學分析中是多麼尋常

* 心得

  - 這裏我已經看到在敘述中
    把與所關心的問題無關的東西明顯的表述出來
    都是有害於敘述的清晰性的
    這是顯然的
    因爲這些額外的東西帶來了 "認知的負擔"

  - 尤其是關於 "命名"
    去命名的能力是必要的
    但是不恰當的 "命名"
    是最主要的把無關的東西引入敘述的方式

* on a proof by Arbib, Kfoury, and Moll

  - 這篇是對上面三個作者的論證風格的批判
    - 他們證明的命題是很簡單的
      當你明白什麼是同餘符號 mod 之後
      這個定理是不證自明的
    他們的風格展示了一種可怕的反面教材
    基本上說明了
    上面三個作者不足以任其學者之職

  - 批判
    用相互推導 來證明兩個命題的等價
    - 類似的有
      用兩個不等式 來證明一個等式

  - 批判
    不知使用 mod 這個記號

  - 批判
    論證時的含糊其辭

  - 批判
    使用最原始形式的歸納法
    要知道就計算機科學而言
    論證某個程序的運行會在有限的時間內結束時
    經常以相當自由的方式 來使用歸納法

  - 其罪過真是罄竹難書
    所以我就不多說了

  - 沒有東西相加就是 0
    沒有東西相乘就是 1
    所以我們有 2^0 == 1
    即 沒有 2 來相乘的時候得到的就是 1
    所以說
    "除了 1 以外所有的正整數 要麼是素數 要麼是素數的乘積"
    應該被改成
    "除了 1 以外所有的正整數 是素數的乘積"
    進一步 應該被改成
    "所有的正整數 是素數的乘積"

* not about open and closed sets

  - 這是一個由論證的語法[而不是語義]
    引導證明者到結論的例子
    - 在這裏所使用的形式敘述風格下
      解[證明]幾乎是唯一的

  - 同時這也是對另外一種證明風格的批評
    這種證明風格在這裏的標準看來根本就不算是證明

  - 在學習拓撲之初
    我也觀察到了一系列非常對稱的定理
    那時 我也想發明自己的論證風格以整理這些定理
    但是 那時我並沒有能力完成這個任務
    現在我明白了
    EWD 的符號系統[也許加上我的一些改進]
    正是當時我所求而未得的

  - 這一節的討論說明了
    在使用 EWD 的符號系統的時候
    最好先給這個符號系統建立一些簡單的規則[引理性的]
    即 這個[用來記錄集合的]符號系統跟某些函數的關係
    - 所說的函數
      比如
      謂詞演算中的量詞
      算數中的求和
      命題演算中的推導

  - 用集合論的謂詞演算解釋
    而不用集合論本身
    來進行論證的敘述
    有的時候方便很多
    因爲謂詞演算[命題演算]是對等式的形變
    而集合論更爲複雜一點
    - 因爲它們都是 [抽象的] bool 代數
      這在與
      集合計算中
      對 空集和全集的等式 可以被翻譯成 bool 代數

  - 對一個對象的表示揭示了這個對象的內部結構
    如果在論證中這些內部結構並不重要
    那麼就別去使用這個對象的表示
    而直接使用這個對象的名字

  - 仔細的辨別出來那些東西是需要命名的
    那些東西是不需要命名的

  - 也許在使用蟬語編程的時候也是如此
    在使用程序語言編寫代碼的時候
    某些時候人們寫出的代碼可能非常難讀
    這可能是因爲
    - 應該省略命名[約束變元[局部變量]]的時候
      編碼者 還是在命名
      也許語言根本就沒有提供 不命名而引用一個數據的機制
      [比如 scheme]
    - 應該使用命名[約束變元[局部變量]]的時候
      編碼者 沒有使用命名
      也許語言根本就沒有提供 臨時地形成一個名到值的映射的機制
      [比如 forth]
    - 應該使用全局變量[在語境中做一些約定以避免某些重複]的時候
      編碼者 沒有使用全局變量
      也許語言根本就沒有提供機制 來讓你形成全局範圍內的名到值的映射
      [比如 CPS 和 monad]
    - 不應該使用全局變量的時候
      編碼者 還是在使用全局變量
      [比如 匯編語言]

  - 可見
    造成難以閱讀的困境的
    可能是語言的設計錯誤
    也可能是編碼者的風格錯誤

  - 那麼
    想要把一個語言設計正確
    就必須提供機制
    以讓編碼者能夠
    在需要的時候
    選擇以使用各種風格來進行編碼
    這就是蟬語要做的

  - 名在蟬語中有三種
    - 全局變元名
    - 約束變元名在函數定義中的出現
    - 約束變元名在函數作用中的出現
    在數學證明中
    通過減少命名 我能夠 揭示 對象之間的對稱性
    而通過 命名我能夠隱藏 對象的內部結構
    那麼在 編程之時 情況如何呢???

* 心得

  - 在讀上一節的時候
    我同時學習了
    關於 抽象的 bool 代數結構的知識
    利用抽象的代數結構[數學結構 因爲還有 格]的術語
    我甚至能夠把上面的證明敘述地更清晰簡練

  - 這就凸顯了現代數學的重要方法論
    即
    在類比中觀察
    把共性進行抽象
    以形成更好的認識
    [控制複雜性]

* >< a monotonicity argument

  - 這一小節的內容是 EWD878 的改進版
  - 以相互推出證等價是初等幾何中常見的論證方式
    但是並不要濫用這種論證方式
  - 我覺得這篇不好看

* >< on the inverse of a function

* ><><>< a calculational proof of Helly's theorem on convex figures

* >< clarity of exposition

* on naming

*** note

    - 這是關於名的一般討論

    - "名的意義是什麼"
      這是一個[極爲]困難的題目
      其難度幾乎和語言這個題目相當

    - 相對簡單的是
      "如何命名" 還有 "命名什麼"
      這兩個問題

*** 數學論證中的非形式語言

    - 人對語言要素的辨認有歧義

    - 數學語言和程序語言在用名時
      其人所慾義 與 其詞之本義 之間有衝突
      即 與自然語言有衝突
      - 除非讓用名之詞源 脫離自然語言
      - 我在讀用英文寫的數學文獻[比如這本書]的時候
        就能體會到某些非數學層面上的困難
        首先書的作者是荷蘭人
        而書用英語寫成
        荷蘭語與英語雖然同源
        但是其基本詞和用詞習慣亦有分疏
        而讀者是中國人
        其母語漢語與英語[荷蘭語]分屬不同語系
        我所遇到的閱讀困難也不足爲奇了
        而這些困難都是非數學層面上的

    - 數學語言和程序語言在用名時
      用 顏色 聲調 之類的
      語義單純的詞似乎是一種解決辦法
      [比如三染色算法]

    - 數學語言和程序語言在用名時
      如果選取了一個 在自然語言中 具有豐富語義的詞
      儘管重新定義以聲明 詞之義 在文本中是受限制的
      但是當遇到這個詞的時候
      這個詞的原本語義還是會對讀者的思維形成干擾

    - 在鑄造術語[漢語]時
      也許 我應該去選擇一些意義陌生的字
      以避免與自然語言相互衝突

    - 從這裏也可以看出
      設計有別於自然語言的數學形式語言的必要性
      對程序語言而言 情況也是同樣

    - 關於
      對應與某一個術語的否定性術語的缺乏
      這裏有一個有趣的討論
      這裏的觀點是
      否定性術語應該有自己的特名
      而不該用肯定性術語加以詞綴來獲得
      [這樣能夠減少讀者認知上的負擔]
      - 否則 就有 "單調不增函數" 這種術語
        這裏建議的術語是 "上升函數" [ascending]
        有例如
        不等於 --> 異於
        不大與[小於等於] --> 至多[at most]
        不小與[大於等於] --> 至少[at least]
        其實上面兩個例子的漢語版本
        還是在用否定前綴
        至 == 不
        多 == 大
        這是漢語的問題
        還有 "正整數" "正或零" 這種例子

*** 啓示

    - 這裏所描述的自然語言之困難
      也許暗指了
      在設計程序語言[數學語言]時
      可以去考慮使用類似 solresol 這種人造語言的詞法系統

    - 這就需要良好的設計
      否則很難被接受
      比如就程序語言而言
      怎麼利用七個音符呢?
      用它們來命名 數據類型?
      用它們來命名 棧處理函數之類的小精靈?

    - 這種意義上來看
      如果引入得當
      solresol 就可以被作爲
      數學和計算機科學中的輔助語言

*** 數學論證中的形式語言

    - 首先這裏對語素的辨認是沒有[不應該有]歧義的
      這一點 蟬語 就做的很好
      即 所有的語素都必須用空格隔開
      比如
      在蟬語中 p^ 不可能是
      一個名字叫 "^" 的函數
      作用與 "p"
      要想達函數的作用就必須用空格
      把 函數 和 參數 分開
      在數學符號中
      這種討論就引起了對 上[下]標記法 的批評
      因爲它們會與函數作用相互混淆
      又比如
      當 "x" 以有他用的時候
      又引入 "x_1 x_2 ..."
      來命名一個 與 "x" 之原來的用處 不相關的數列

    - 關於 如何命名
      首先 符號的意義在於[在論證中]被處理
      所以 選取符號就應該以易於處理爲原則

    - 注意上面那個是本書中的原則
      而我個人則認爲 "易讀性" 比 "易寫性" 要重要的多
      - "易讀性" 之定義爲
        在最大程度上減少閱讀者對語義的 "認知負擔"
      如果 "易寫性" 被等同於 "易處理性" 的話
      那麼關於這個問題
      我所認同的原則
      就完全與本書的原則相反了

    - "名字越簡短越好"
      在數學論證中這也許被認爲是好的原則
      但是在編程中這絕對是錯誤的原則
      事實是在數學文獻中
      幾乎所有的作者都很少使用 詞 來命名
      而都使用字母
      這種現象值得被好好討論一下
      - 在寫程序的時候
        我並沒有感受到長的命名所帶來的不變
        而在寫數學公式的時候
        我卻能夠感受到長的命名所帶來的不變
        可能是因爲在一個設計好的文本編輯器的幫助下
        打字的輸出效率比手寫要高出很多很多
        如果真是這樣
        那麼
        在數學中不使用長命名的主要原因就是
        不利於寫
      - 另一個原因是
        機器可以把長的公式排版地很整齊
        而人在書寫數學手稿的時候常常疏於排版
        所以當使用長的命名的時候
        就會感覺很亂
      - 但是要知道
        [至少是目前爲止]
        書寫手稿的優越性在於能夠突破線性文本的限制
      - 在蟬語中 在不同的時候
        空格 可以被當作 函數複合 或 函數作用
        因爲在手寫中卻不行
        因爲手寫體中的空格太不穩定了

    - 還可以發現
      由於西方拼寫語言與漢語的本質不同
      很多的討論在漢語方面是不適用的
      [比如 大小寫 字母的順序 等等]

    - 在今後的書寫中
      我會利用在程序語言中的經驗
      來審視書寫數學文本時的某些習慣
      尤其是嘗試使用長的詞[或漢字]
      來命名某些約束變元將是很有趣的

    - 作者批評了對希臘字母的使用
      但是其實
      使用希臘字母和使用大小寫字母的本質是一樣的

    - 關於 命名什麼
      第一個原則是 儘量少命名東西
      沒必要進行的命名的例子是
      "任意一個正整數 n 都可以被以唯一的方式分解成素數的乘積"
      其中 "n" 就是一個沒有必要的命名
      因爲之後就再也引用不到 "n" 了
      另外一種常見的過度描述的例子是
      "不失一般性我們可以取什麼爲什麼"
      既然 取一個特殊的元素 也 "不失一般性"
      [那麼 一定是因爲有某種對稱性存在]
      那麼如果不取這個特殊的元素
      我們就能維護原本的對稱性
      - 本書作者的觀點是
        此時如果維護對稱性
        那麼我們就常常能把
        "逐一分析組合方式" 這種風格的證明
        改寫成
        "量化某個性質而計數這個量" 這種風格的證明

    - 除了命名過剩對對稱性的破壞之外
      還有命名不足最對象細節的暴露

    - 在變換等式或邏輯表達式的時候
      當有一個子表達式被拖着走了很長時間
      那麼可能就應該給這個子表達式以名字
      或者把這個子表達式所代表的條件敘述於論證的語境中
      以避免重複

    - 另外
      如果
      當用一個抽象的名字掩蓋起來某個對象的內部細節之後
      論證還是能夠正常進行
      那就說明這段論證根本與被掩蓋起來的內部細節沒有關係
      這樣就能幫助我們進行正確的抽象
      其次 推遲對名的展開 其實是在控制複雜性

    - 另外
      蟬語[或 forth]中的 re-factoring
      其實就是重新命名的過程
      所以也可以稱之爲 re-naming
      這裏 通過改變命名方式
      我們對某個算法[函數]的理解
      可能完全被改變

    - 推遲對名的展開
      在蟬語中也是常見的
      尤其是當從上倒下地來寫一個函數的時候

    - 這種對名的逐漸展開還具有引導性
      數學論證方面 還有 蟬語方面都一樣
      考錄一個大函數
      和一個被良好因子化了的函數就知道了

    - 另外
      要注意這裏的論點其實都是
      圍繞某些典型的例子來總結的

    - 命名錯誤的對象
      這種情況的例子是
      如果函數 f 總是 以所用於值 a 的面貌出現
      即 f.a
      那麼就不應該用兩個名去分別命名 函數與參數
      而應該直接用一個名去命名這個表達式

    - 另外一個設計數學證明時的設計決策是
      去使用 集合
      還是去使用 生成這個集合的謂詞
      本書的作者的觀點是謂詞好
      因爲命題演算中的等式比集合論的等式更容易進行變形
      - 但是爲什麼會有這種現象?
        集合運算 和 命題演算
        同屬於 抽象的 bool 代數
        而 命題演算 是最簡單的 非平凡 bool 代數
        所以 它的性質要正規的多
        [同時它的性質也比較貧乏]

    - 最後一個論點是關於下標和上標的
      要知道矩陣運算的發明
      完全是爲了避免書寫過多的線性方程組
      後者是不方便書寫的
      因爲其中充滿了 下標和上標

*** 關於 "易閱讀" 與 "易書寫" 的衝突

    - 其實 都是爲了 減少思想者認知上的負擔
      思想者 就 既包含了 寫者 與 讀者

* on the use of formalism

*** note

    - 其實這裏的某些論點都是歷史性的
      現在形式主義已經處主導地位了
      尤其是考慮到計算科學對形式化的要求
      這種主導地位的正確性就更加明顯

    - 計算科學給形式主義所提出的新的要求
      不光是具有精確性和簡潔性
      更重要的是
      用來給算法和證明以形式的數據結構本身
      也要能夠被算法和證明來處理

*** 啓示

    - 我應該試着用我設計的語言表達一些標準算法
      並且在這個過程中觀察我語言的實用性質是否如我所願

*** 關於中綴表達式

    - 具有類型 set --> value
      的函數
      都是由具有結合性的運算所生成的
      - 考慮 ewd 的記號系統就知道了
      反之也一樣
      當一個運算具有結合性的時候
      就可以用它來生成
      有序集 --> value
      當它又具有交換性的時候
      就可以用它來生成
      無序集 --> value

    - 並且這個所生成的函數作用於空集時
      就得到這個運算的單位元
      [這其實又是一次生成]

*** 作爲數據結構的形式語法

    - 在設計形式語法的時候
      注意
      - 語法解析的可能性
      - 對稱性
        以二項式係數爲例子

    - 函數作用具有很多形態的形式記法
      運算[作用]優先級被認爲是很高的函數
      就會被以上下標 或 括號等方式記錄
      - 我顯然要避免使用這種記錄方式

    - 一定要把運算律表達爲對公式的變換
      [而不要使用其他奇怪的表達方式]

    - 算數運算中的等號
      還有 謂詞演算中的等號
      使用了不同的符號
      這是因爲沒有使用運算符重載

    - 使用運算符重載的缺點是
      每當一個函數作用的時候
      爲了明確其意義
      都必須知道被作用的參數[可能是一個約束變元]的數據類型是什麼

    - 這就給蟬語中的運算符重載提出了一個難點
      因爲在一個函數定義中調用了一個動態的消息傳遞
      消息傳遞給一個約束變元
      如果約束變元的類型是不確定的
      那麼對這個函數作用的返回值的控制
      就超出了函數定義的能力範圍
      也許
      合理的是
      此時爲了讓一個數據類型能夠被某個函數處理
      必須把這個函數登記到這個數據類型下
      在做登記的時候
      你同時擁有兩方面的信息
      此時你才能確定這個函數作用與這個參數之後會不會形成有效的操作
      也就是說一個函數體被重用以處理多種數據結構了
      在登記的時候
      如果 你必須保證這種處理能夠有效進行
      - 上面的討論其實說明了
        我對這種消息傳遞的考慮還是不夠充分的
        考慮其他語言對這種問題的處理方式就知道了
        比如 ocaml 和 haskell

    - 關於推演規則的選擇
      注意如何形成輔助性的推演規則
      [就像輔助函數的使用一樣]
      [推演規則和對等式的變換規則是一樣的]

    - 關於表達證明的格式
      形成 證明[尤其是形式證明] 的感覺類似於
      在森林裏尋找一條從條件到結論的路
      但是又有區別 比如 條件可以是很多個
      有時兩個條件才足夠讓你達到一個結論
      [所使用的圖論模型必須捕捉到這個性質]
      所以
      有點像是 在一個有向圖中
      給定了一些點
      需要從這些節點出發
      用有向邊達到目的節點
      [目的節點 將作爲最終形成的有向樹的根[注意定向]]
      但是某些有向邊能夠行走[這些有向邊的存在]
      是以某些點的存在爲前提的
      [有向邊就代表了推理規則]
      這個模型就對了
      - 可以發現這一定是一個無限的有向圖
        對這個有向圖的操作
        一定是以對這個 無限有向圖 的特殊編碼[良好編碼]爲基礎的
      - 證明幾乎就是純粹的遊戲
        這說明了
        如果設計一個輔助證明系統
        那麼它的用戶界面一定要設計地像一個遊戲一樣
      - 在這裏由已有的推演規則可以形成輔助性的推演規則
        就像輔助函數一樣
        每個推演規則的語義都是
        [每個推演規則所捕捉的概念都是]
        一種形成有向邊的模式
      - 一定是 格 嗎???
      - 需要實際的經驗以檢驗上面的模型的可行性

    - 重要的認識是有向圖有層次
      比如
      命題演算中的推演規則
      被認爲是在一個有向圖中做遊戲
      而
      命題演算本身作爲 抽象的 bool 代數
      也是一個有向圖 [bool 格]
      所以
      在各個層次 都有有向圖

    - 邏輯推演 與 運算又有什麼區別呢?
      既然機器輔助證明系統存在
      那麼 邏輯推演 與 運算 就沒有區別

*** 疑惑

    - 說 X -> Y 與 X and Y = X 等價 是什麼意思??
      是說 它們 的真值表 相同??
      是說 它們 作爲[二元]函數 是相同的函數??
      是說 (X -> Y) = (X and Y = X) 永真??
      如果這上面的三個定義是 "等價" 的
      那麼 "等價" 在上面那句話中又是什麼意思???

    - 真假不重要
      重要的是函數相等不相等
      但是對 "函數是相等的" 這句話的肯定
      卻會返回一個 真假 值

    - 這裏的困難在於我不知道思想的根基是什麼

    - 而我認爲思想的根基可以[應該]被取爲基本等詞
      但是這又需要命題演算了
      因爲我必須能夠說 "等詞爲真"

    - 只要解決了命題演算這個數學結構
      我就能獲得其他數學結構所需要的基本等詞了
      也就是說
      我需要假設人們能夠區分 true 和 false
      這樣
      一個等詞 就是一個到 true 和 false 的[二元]映射而已
      但是當我說我能夠區分 true 和 false
      就是說我能夠判斷它們是否相等
      這裏又需要一個基本的等詞
      我必須假設這個等詞是公理性的
      這個基本的等詞不能用 其到自身的映射來解釋
      因爲只有當我們能夠區分映射的結果的不同的時候
      這種映射作爲等詞才有意義
      然而 爲了區分映射結果的不同
      我們又需要一個等詞
      這樣就循環了

    - 事實是
      我選取了這個基本的等詞爲公理性的東西

    - 而一種重要的認識就在於
      對公理的選擇是任意的
      我完全可以選擇一個三元集合爲公理性的東西
      我也可以選擇有向圖爲公理性的東西
      我也可以選擇三維流行爲公理新的東西

* guarded-command programs

  - 用對全局[局部]變量的謂詞
    把一段程序夾起來
    在函數編程範式下
    兩個謂詞就是對程序的參數和返回值的類型說明
