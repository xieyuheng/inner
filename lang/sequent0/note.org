* keyword 之 返回值後置 <2016-11-16 Wed>

  - x ::
       keyword 用前綴表達式
       之後我發現
       我們語言設計的重要特點就是偏向 explicit
       而我可以觀察到
       目前的設計中 (: :t type) 就是典型的 implicit

  - k ::
       我想我們可以總結一下當前設計中的 implicit 之處
       要知道 implicit 就是 語法優化
       我們之後要看看這些優化是否必要

  - x ::
       首先需要考察的就是 (: :t type)
       例如
       #+begin_src scheme
       (define nat
         (data type
           (: zero nat)
           (: succ (-> nat nat))))

       (define nat-induction
         (lambda (-> [(: :p (-> nat type))
                      zero :p @
                      (-> [(: :k nat) :k :p @]
                          [:k succ :p @])
                      (: :x nat)]
                     [:x :p @])
           (-> [:q :q/z :q/s zero] :q/z)
           (-> [:q :q/z :q/s :n succ]
               [:n
                :q :q/z :q/s :n nat-induction
                :q/s @])))
       #+end_src
       如此看來
       它出現在不同的地方意義是不同的
       我想我們所說的 explicit 與 正規性
       就是要儘量減少這種情況
       即 減少語法關鍵詞對上下文的依賴

  - k ::
       如若換成
       #+begin_src scheme
       (define nat
         (data type
           zero nat
           succ (-> nat nat)))
       #+end_src
       就可以說 data 把它 body 中的 list 當作 alist 來處理了

  - x ::
       這樣就算是解決了 這個語法關鍵詞 依賴上下文的問題
       還有就是他本身的意義問題
       我有了一個好想法
       就是說
       每個語法關鍵詞也是有類型的
       [每次都去考慮類型]
       之前想要區分 (: :t type) 與 {: :t type}
       所想要區分的是
       前者 在局部的副作用之外 返回一個值到棧中
       後者 只有局部的副作用
       我們應該用系統的方式來處理這種對差異的需求

  - k ::
       還有就是命名問題
       或者說 lexicon 問題
       比如
       以 (: :x type) 記 之前之 (: :x type)
       以 (:- :x type) 記 之前之 {: :x type}
       我們要讓 lexicon 之間的形式關係
       體現出 lexicon 之間的語義關係
       這有些類似與 孤立語 黏着語

  - x ::
       我們可以製作一個表格如下
       | 返回值到棧中 | 不返回值到棧中     | 對比語言學中的分類 |
       |--------------+--------------------+--------------------|
       | (: :t type)  | {: :t type}        | 特殊               |
       |--------------+--------------------+--------------------|
       | (: :t type)  | (:- :t type)       | 動詞變位           |
       |--------------+--------------------+--------------------|
       | (: :t type)  | (# (: :t type))    | 前綴黏着           |
       |              | (hide (: :t type)) |                    |
       |--------------+--------------------+--------------------|
       | (: :t type)  | (: :t type) drop   | 後綴黏着           |

  - k ::
       我們應該想想自然語言中 爲什麼有這種需要
       而程序語言中的這種設計 在類比中又意謂如何

* 對比自然語言中的 '設計' <2016-11-18 Fri>

  - x ::
       自然語言之 分析 綜合 之分
       看來主要是區分是否依賴語序

  - k ::
       我們來熟悉一些術語
       | 語素     | morpheme       | 意義最小單位     |
       | 詞       | word           | 可使用的最小單位 |
       | 詞序     | word order     |                  |
       | 自由語素 | free morpheme  | 可獨立使用       |
       | 粘著語素 | bound morpheme | 不可獨立使用     |

  - x ::
       看來 曲折 指 詞根詞綴 詞綴詞綴 之間的區分不明
       而導致詞形多不規則變化 (拉丁語)

  - k ::
       好像 語法範疇 這個概念就是我們需要的
    1. 名詞
       性 (gender)
       數 (number)
       格 (case)
    2. 動詞
       限定性 (finiteness)
       時 (tense)
       體 (aspect)
       態 (voice)
       式 (mood)
       人稱 (person)
    3. 形容詞 副詞
       級 (degree)

  - x ::
       格 (case) 用於處理多名詞句子
       我們可以想象在一個線性的 jojo 中
       利用不同的 call 來區分對同一個詞的不同使用方式
       拉丁語為例
       | 主格 | nominative case | 主語               |
       | 屬格 | genitive case   | 表示領屬關係的定語 |
       | 與格 | dative case     | 間接賓語           |
       | 賓格 | accusative case | 直接賓語           |
       | 呼格 | vocative case   | 呼語               |
       | 奪格 | ablative case   | 表示某些意義的狀語 |
       不用變格來區分多名詞句子中不同名詞的使用方式
       就需要用語序來區分之了

  - k ::
       一個句子 動詞之間是有時間上相互關聯
       比如 完成體 (perfect aspect)
       一個動詞本身也有進行中或已經完成之分
       比如 完全體 (perfective aspect)
       形式上記錄這些關係的就是語法
       [屈折語用 動詞變位]
       類似 名詞變格 處理多名詞句子
       很多語言也有一種處理 多動詞句子 的獨特策略
       即 限定性 (finiteness)
       就是把動詞區分為 限定 和 非限定 兩種形式
       | 限定動詞   | 句子(或分句)之 謂語     |
       | 非限定動詞 | 句子(或分句)之 其他成分 |
       由於一句 只有一謂語
       所以一個簡單分句最多只有一個 限定動詞
       [除非使用 並列連詞 (coordinator)
       把多個 限定動詞 組成 並列謂語]

  - x ::
       一句一謂語 這個規則
       看來也能體現在程序語言的語法設計之中
       不論是 前綴中綴還是後綴
       都只有一個函數作用於多個參數

  - x ::
       我還發現了程序語言設計中一個有趣的事實
       程序語言需以無歧義的形式語法
       描述如何完成(how)一段計算(一段變化)
       而在形式語言之外
       我們一定也能用自然語言描述這種計算
       只不過所做的描述不足夠形式 而不易被機器處理

  - k ::
       這樣 在對比自然語言與程序語言之間的關係的時候
       我們就可以總結一下
       自然語言 是如何描述 如何進行一段計算的

  - x ::
       等等
       在總結之前
       我還發現了這篇文章的方法
       首先 西語之語法學主要在於 名詞變格 動詞變位
       再 總結這些語法現象的功能
       然後 在漢語中尋找完成類似功能的(與之完全不同的)語法現象
       我們可以試着構擬這些 '語法' 之產生

* emergent grammar & grammaticalization

  - x ::
       emergent grammar 不想語言的語法是現設計完備的
       而說 語言沿 grammaticalization 演化 而產生語法

  - k ::
       也就是說我們要找
       自然語言的 grammaticalization 在程序語言中的類比

  - x ::
       grammar emerges through interaction among participants
       who are constantly reusing and modifying prior utterances
       to achieve current interactive goals

  - k ::
       比如
       使用一個 sequent 法形式很多次 而把它定義爲新的 function
       使用一種語法形式很多次 而把它做成 macro

  - x ::
       但是其實我們不能說 定義一個 macro 是 grammaticalization
       因爲 定義 macro 與 定義 function 重在定義之命名過程
       命名似用典

* 一些新的 語法設計 與 語言實現 原則 <2016-11-19 Sat>

  - x ::
       我想出了一些新的語法設計原則
       有三條
       一
       爲定義過的名做 派
       比如 計算 與 類型檢查
       分派兩個不同的函數體來作用
       二
       以 珠珠 爲函數語義之核心
       用圓括號作爲直接數據之語法
       三
       要知道
       不論是如何分派
       不論是計算或類型檢查
       最終都是對機器狀態的變化
       而我們常常用棧來記錄這些狀態

  - k ::
       其中第三點尤爲重要
       看似是常識 可是總是被忘記
       下面就是要明確應該如何踐行這些新的原則

  - x ::
       既然機器的狀態纔是最重要的
       我們就要設計彙編語言來分解 jojo 與 arrow-list 之計算 還有類型檢查
       彙編語言本身是不經過類型檢查的

  - k ::
       但是我發現了一個問題
       如果我們寫解釋器的話
       有些機器的狀態是依賴宿主語言的

  - x ::
       這沒有關係
       只要我們小心地明確這些依賴就行了

* 以 珠珠 爲函數語義之核心 用圓括號作爲直接數據之語法

  - x ::
       我想這種設計對於目前的需求來說是夠用的
       這樣我們就要用 (: :t type) drop 這種語法了

  - k ::
       我們可以把 key 區分爲兩種
       一種是 top 如 define
       一種是 lit 如 lambda -> : <

  - x ::
       我想又找到了一個新的原則
       就是說 對於每個這樣的 詞 不論是 key 也好 還是 function 或 macro 也好
       我們都應該嘗試給其以類型
       畢竟它們被編譯或解釋的效果都是對機器之狀態的變化

  - k ::
       首先
       這些語法關鍵詞的特點是
       他們的參數不光是棧中的數據
       還可能是圓括號中所包含的 lit

  - x ::
       我們看一些例子
       (: :t type) 不能只在副作用之後返回 type 這個數據
       而要 返回 bind
       這就是之前所說的 信息不丟失
       之所以需要這樣來避免信息丟失
       是因爲 var 的 level

  - k ::
       我們來仔細分析一下
       首先 var 是爲了 bind
       bind 是爲了 unify
       而 var 的 level
       是爲了 (type-of jo)
       不能直接返回 level-1 的數據
       而要返回 bind 是因爲
       之後 arrow 的 (type-of antecedent) 需要與它做 unify

  - x ::
       我們在這裏之所以需要新增一個 bind 數據類型
       也許是因爲我們沒能設計好 type-check 的過程
       這裏就回到了第三條原則
       要知道 type-check 是對機器的狀態的變化而已

  - k ::
       幾遍如此 我們也很難拋棄 新增的這個 bind 數據類型
       因爲想要避免 bind 作爲數據類型
       唯一的辦法看來就是用帶有兩層數據的 data-stack
       這看來是不合理的
       爲了更好的實現 unify
       我們可以在 data-stack 的接口上加一層 pointer
       來改變數據的輸出方向等等
       但是這些看來都有點複雜了

  - x ::
       也許 這種返回新數據類型的效果是需要的
       比如 (: :t type) (< :a :x) 這些東西
       我們隨時可能增加這類東西
       這時就需要使用類似 oo 的效果了
       需要使用消息傳遞的實現方式

  - k ::
       也就是說 在這個層次實現的數據類型 需要有自己的方法
       這樣就避免了用 pattern 來 dispatch
       回顧之前的 dispatch 表格
       | jo      | data    | double data |
       |---------+---------+-------------|
       | compose | bs/deep | cover       |
       | cut     |         | unify       |
       所能接受的信息至少包括這些
       其中 double data 使得 oo 中主次參數之分也有意義了

  - x ::
       就具體實現而言
       我們還是需要 typed-racket
       因爲即便是實現 oo 的 method
       我們還是需要類型系統

  - k ::
       但是這就要求我們在 typed-racket 中自己實現一個 oo 機制

  - x ::
       這並不困難

* 語言標準

  - x ::
       we can design new way to add new things
       but the way always must be limited in some way

* 實用的實現 與 爲理論而做的原型實現

  - x ::
    1. 爲理論而實現原型需要使用實用的語言
    2. 實用的語言的語法設計新需求來自爲理論而作的原型

  - k ::
       可否二者兼顧呢

* >< 彙編

  - x ::
       用更底層的一層語言來描述 : 與 < 之實現細節
       難點在於
       這種低一層的語言如何融合到 sequent0 當前的實現方式中

  - k ::
       我想這並不重要
       因爲
       不論用什麼語言
       我們總有能力把這種類似彙編語言的中間層在實現中表達出來

  - x ::
       那麼就具體的 : 與 < 而言
       #+begin_src scheme
       (: :data :type)
       (:bind (level 1 :data) (level 0 :type))
       (:return a new data which will mainly be treated as type)
       (::)

       (< :subtype :type)
       (:bind (level 1 :data) (level 0 :type))
       #+end_src

  - k ::
       我發現正如我們第一次嘗試爲每個名字區分 compute 與 type-check 兩種方法時
       '類型安全' 這個概念在那個語言中是靈活可變的
       這裏 類似 (: :data :type) 這種 具有返回值 且帶有副作用的表達式
       也可以出現在 jojo 中

  - x ::
       之前的想法是
       遇一名時 可能是爲了 compute 也可能是爲了 type-check
       (: :data :type) 是一個數據
       正如遇到別的數據時需要改變 ds 的狀態
       遇到 (: :data :type) 時
       之所以說它有副作用
       是因爲在改變 ds 的狀態之外
       它還會改變 bind 的狀態
       gs 之於 bs
       正如 rs 之於 ds
       既然 這些都是 stack
       那麼 給它們加類型 就是描述他們對 stack 的狀態之改變了

  - k ::
       看來 類型系統的核心想法 就是這種兩層計算
       計算有兩層 兩層都是計算

* pre-jo 與 uni-copy <2016-11-23 Wed>

*** 引

    - x ::
         作爲 jo 的 var
         和 data 的 var 可以不一樣
         jo 的 var 中增加一層查找 找到 uni-id 的 作爲 data 的 var
         這樣就能避免 unique-copy 這個運行時的操作
         同時避免 pre-jo 這個中間數據結構
         直接把源代碼編譯到 jo
         這樣編譯語義本身也就明確了

    - k ::
         我們就先從改 sequent0 現在的 scheme 代碼開始
         如此一來整個代碼的結構都大大簡化了
         並且要知道
         rc1 中的 oo 機制 可能算是爲 at1 設計的
         因爲 at1 語法不定 而經常需要添加新的數據類型
         [甚至還要能動態添加之]
         而就 sequent0 而言 scheme 就足夠了

    - x ::
         沒錯
         最快的能觀察出新技巧的效果的地方
         就是現在 sequent0 的 scheme 代碼了

    -----------

    - x ::
         我發現 作爲 jo 的 var 如果與 作爲 data 的不同
         那麼 可能嵌套別的 jo 的 arrow 與 lambda
         也有別於其作爲 data 的存在

    - k ::
         看似這裏在返回 arrow 和 lambda 的時候
         還是需要 unique-copy
         [因爲它們與 name 下所綁定的 lambda 不同]
         但是其實
         這裏還是可以模仿 對 name 下所綁定的 lambda 的處理
         也就是說每個需要被作用的東西
         [因爲被作用 而需要 unify 而需要做 binding]
         都可以如此處理

    - x ::
         這樣只要讓每個 lambda 中帶有一個 list
         來記錄其中出現的 var name
         還有一個 list 來記錄 這些 var name 中已知值者
         當需要返回一個 lambda 的
         用第一個 list 對照當前 返回點 中的 var name list
         以生成第二個 list

    - k ::
         這樣做爲 data 的 lambda 與作爲 jo 的 lambda
         就是沒有區別的
         jo 中的 lambda 第二個 list 是空的
         只有返回成 data 的時候才得以確定

    - x ::
         但是我們應該把這些新增的元數據放在哪裏呢
         有三個地方可以放
         lambda arrow 或者 jojo

    - k ::
         我覺得我們把新增的兩個 list 域放在 arrow 就好了
         因爲 我們可以完全放棄單獨出現的 jojo
         或者直接把這些 jojo 作爲 macro 處理

*** 詳細重述 var 與 uni-var 這個新的技巧 <2016-11-30 Wed>

    - x ::
         我們這次嘗試將筆記如此如此
         使得之後我們一旦瀏覽筆記
         就能回想其如今實現中的要點

    - k ::
         首先是因爲我們使用了 bs 來尋找 var 的值
         var 有 level
         因此 level 1 有值 而 level 0 無值的 var
         作爲 level 0 而返回的時候 就還是不定的
         這導致古典的處理方式可能不能用

    - x ::
         然後我們 愚蠢地 '發明' 了
         用 unique-copy 來保證每個 arrow 中變元之 unique
         之後又把它改進成了現在的 分 var 與 uni-var
         而在 rs 中留一個域保存 {(var . uni-var) ...}
         我們難道不應該先看古典的處理方式
         然後再試圖改進它麼

    --------------------

    - x ::
         具體到這個新技巧之運作
         先說需要作用一個 arrow 的時候
         應該如何
         [要知道 '作用一個 arrow'
          並沒有被一個函數處理完畢
          而是利用了 scheme 的控制流
          作用本身是通過 push rs 與 調用 相應的 next 完成的]
         首先
         '作用一個 arrow' 就是 push rs
         在 push rs 的時候需要生成當前的 unirc [bind-record]
         此時 arrow 中有 occur-list 與 bind-record
         [occur-list 與 bind-record 是不交的
          它們的並構成了這個 arrow 中的所有 var
          其中 bind-record 是有 uni-var 的 var
          而 occur-list 是還沒有 uni-var 的 var]
         這個 bind-record 就是 unirc 的一部分
         而 occur-list 將被用以 生成新的 uni-var
         這樣這個 arrow 中所有的 var 就都有 uni-var 對應了
         其次
         當遇到 :name 或 #name 的時候
         先從當前的 rsp 的 unirc 中找到 其所對應的 uni-var
         然後再用 uni-var 在 bs 中找對應的 data
         最後
         當要返回一個 arrow 或 lambda 的時候
         [也就是 compose/arrow 或 compose/lambda]
         遇到的是 {'arrow local jojo jojo}
         返回的是 {'arrow new-local jojo jojo}
         其中 new-local 是
         移動 local 的 occur-list 中
         出現在 當前 rsp 的 unirc 中的 var
         到 bind-record 中
         而得到的
         注意
         這個 arrow 可能已經有 非空的 bind-record 了
         如果 之前返回這個 arrow 的時候
         已經返回了 某 var 的 uni-var 到 bind-record 中了
         而 這次 unirc 中還有這個 var
         因爲此時 occur-list 中已經沒有了這個 var
         所以這個 var 就不會影響這次返回
         這樣 就達到了 lexical-scope 的效果

    - k ::
         我發現我們的 arrow 和 lambda 沒有
         對局部變元的明顯聲明

    - x ::
         其實有判別約束變元和自由變元的方式
         比如
         (-> [:v1] [:v1 :v2])
         :v1 在 antecedent 中出現
         所以是一個約束變元
         但是
         其實我們並沒有 lexical-scope
         比如 我們允許如下的 arrow
         #+begin_src scheme
         (-> [:v1 :v2]
             [(-> [:v1]
                  [:v1 :v2])])
         #+end_src
         此時 :v1 在內層的 antecedent 中的出現
         但是它並沒有 block 外層 :v1

    - k ::
         這是不合理的
         我們必須要實現 lexical-scope
         因爲
         如果所返回的 arrow 中的 antecedent 中的變元
         可以在返回 arrow 時被特化
         那麼 這個 arrow 作用的條件就更狹窄了
         這是我們的類型檢查器所不能處理的

    - x ::
         的確如此
         而且我們也不需要這種性狀
         如此看來
         當前對 arrow 結構的擴展可能是不夠的

    - k ::
         沒錯
         我們還需要區分 約束變元 與 自由變元

    - x ::
         可否從語法上區分之
         #+begin_src scheme
         (-> [:v1 :v2]
             [(-> [:v1]
                  [:v1 ::v2])])
         #+end_src
         比如自由變元用 ::name 而約束變元用 :name

    - k ::
         occur-list 其實是爲約束變元而做的
         而 bind-record 是爲自由變元而做的
         [注意
          約束與自由與否是相對某個 arrow 而言的]
         語法上的直接明顯區分是不錯的解決方式
         同時
         還要考慮的一個問題是
         var 的 level

*** var 的 level

    - x ::
         其實我們現在只有兩個 level
         即 level-0 與 level-1
         當 :name 在函數體的 arrow 中出現
         都是 level-0
         之前需要 level-1 的地方是
         #+begin_src scheme
         (: :var type)
         #+end_src
         如上則 :var 之出現與其在函數體中出現相同
         但是
         現在是語法是有明顯區別的
         #+begin_src scheme
         type %:var
         #+end_src
         這樣就不用考慮遇到 :var 時的 default-level 了

    - k ::
         對 :var level-0 的綁定
         全是用 unify 與 cover 完成的
         [我們並沒有 綁定 level-0 的其他方式]
         而對 :var level-1 的綁定
         是用 %:var 來完成的

* 之前所設計的縮寫 與 兩種風格的命名空間

  - k ::
       我發現
       我們對於 (-> [] nat) 等價與 nat 的處理還有欠之處
       之前做這種等價
       是因爲要求每當從 name 下找到一個 lambda 就自動 apply 它
       而不返回以 -> 爲類型的值
       還記得之前的 dispatch 嗎
       不是兩種而是四種
       比如
       兩種是
       由 name 找到 lambda 作爲計算
       由 name 找到 lambda 作爲類型
       另兩種是
       lambda 本身出現在 jojo 中 作爲計算
       lambda 本身出現在 jojo 中 作爲類型

  - x ::
       我們之所以需要這種約定的等價
       是因爲我們需要以多種方式處理名字
       把名字當成是 box
       已經有當遇到 box 名字時
       已經有 返回 box 地址
       或者 返回 box 內的值之分了
       當考慮 lambda 時
       就是新增了一種可能
       即 返回數據之後再 apply
       又因爲
       (-> [] nat) apply == nat
       所以我們有這種約定
       我們爲 curry 所設計的語法糖
       其實與 scheme 相同
       是利用編綴來把
       (... arg fun)
       化爲
       ... arg fun apply
       或
       ... arg fun n n-apply

  - k ::
       同樣
       以 (-> [nat nat] nat) 爲 (-> [nat nat] [nat]) 之縮寫
       也會遇到類似的問題

  - x ::
       看來我們應該完全避免這種無關緊要的縮寫
       但是如何處理對 box 的多種處理呢
       這裏可以觀察到 scheme 與 common-lisp 命名所用語法詞之原理
       #+begin_src scheme
       ;; scheme
       (define add
         (lambda (-> [nat nat] [nat])
           (-> [:m zero] [:m])
           (-> [:m :n succ] [:m :n add succ])))

       ;; common-lisp
       (defun add (-> [nat nat] [nat])
         (-> [:m zero] [:m])
         (-> [:m :n succ] [:m :n add succ]))
       #+end_src
       在 scheme 中編綴表達式 (fun arg ...) 本身就是 apply
       所以 box 取值爲 lambda
       而 lambda 又出現在 sexp 的 head 位置
       那麼它就被 apply 了
       [common-lisp 區分兩個明明空間
       可能也是受到這種有區別的 defun defvar 的影響]
       但是我們的純後綴表達式語言 沒有這種編綴
       所以所有的數據都應該以 -> 爲類型

  - k ::
       由此看來我們也需要區分 defun defvar 不是嗎

  - x ::
       既然每次遇到名字的時候我們都要取值然後 apply
       那麼我們就可以使用 scheme 的關鍵詞風格
       只要讓每個被定義的值 比如 lambda jojo string 等等
       可以接受 apply 這個 message 就可以了

  ------------

  - x ::
       現在我們所定義的東西非常侷限
       就只有 function 和 constructor 而已
       只要讓這兩個東西能夠接受 apply 這個 message 就可以了

  - k ::
       如此而言
       當前的 通過區分不同的 meaning 來做 dispatch 是不對的
       正確的方式是
       保存在 name 下的都是數據
       每個可以保存在 name 中的數據
       都可以接受 apply 這個 message

  - x ::
       返回一個 lambda 與 apply 一個 lambda 不同
       但是
       返回一個 string 與 apply 一個 string 看來是相同的
       所以我們還是按照當前的處理方式吧

* 遞歸調用 與 遞歸函數的類型檢查

  - x ::
       這個問題也包括相互遞歸調的函數
       以及他們的類型檢查

  - k ::
       當前語言的解釋性還是很強
       畢竟語言是利用 macro 而嵌入在 scheme 中的

  - x ::
       那麼我們就先不處相互遞歸函數
       以保持簡單的解釋語義

  - k ::
       其實 爲了處理遞歸函數 也沒有必要給 compile 相關的函數增加參數
       只要在類型檢查之前先把編譯好的 meaning push 到 ns 中就行

  -----------

  - x ::
       我想當前對 def 的使用是很沒有意義的
       #+begin_src scheme
       (def nat
         (data (-> [] [type])
           zero (-> [] [nat])
           succ (-> [nat] [nat])))

       (def add
         (lambda (-> [nat nat] [nat])
           (-> [:m zero] [:m])
           (-> [:m :n succ] [:m :n add succ])))
       #+end_src
       完全可以寫成是
       #+begin_src scheme
       (data nat (-> [] [type])
         zero (-> [] [nat])
         succ (-> [nat] [nat]))

       (lambda add (-> [nat nat] [nat])
         (-> [:m zero] [:m])
         (-> [:m :n succ] [:m :n add succ]))
       #+end_src
       甚至
       #+begin_src scheme
       (+ nat (-> [] [type])
          zero (-> [] [nat])
          succ (-> [nat] [nat]))

       (~ add (-> [nat nat] [nat])
          (-> [:m zero] [:m])
          (-> [:m :n succ] [:m :n add succ]))
       #+end_src

  - k ::
       之所以不這樣做
       而使用類似 scheme 的 def
       是因爲
       我們要求之後的可擴展性

  - x ::
       但是這種可擴展性可能是虛的
       因爲 雖然 (lambda ...) 可以被當作一個數據返回找棧中
       但是 (data ...) 或者 (type ...) 並不可以
       而且 後二者幾乎總是遞歸的

  - k ::
       還有一個處理方法是
       我們讓 (data ...) 也能作爲數據返回到棧中
       並且增加標記語法來處理無名遞歸

  - x ::
       如若如此
       最好能夠利用返回棧 來處理代表遞歸的 標記語法關鍵詞
       並且完全禁止有名的遞歸
       甚至可以用標記語法處理相互遞歸

  - k ::
       用標記語法處理相互遞歸 可能太過極端了
       可以限制成
       非相互遞歸只能無名
       而 相互遞歸只能有名

  - x ::
       或者不做任何限制
       只是爲遞歸調用增加標記語法
       標記語法能夠 利用 <> <1> <2> 來處理嵌套的 (lambda ...)
       或 (data ...)

  ------------

  - x ::
       但是添加這種性狀之後
       編譯過程本身就變複雜了

  - k ::
       可以這樣說
       我們知道這種潛在的處理方式之後
       就知道要使用 def 而不用 ~ + 了
       我們還是先實現最簡單的編譯

* 喪我

  - x ::
       我是非我的堆砌而已

  - k ::
       何以見得

  - x ::
       我是 我的 我們 我說 我想
       只要你不執着得堆砌這些原本非我之物
       我便瓦解
       誠實地承認這些東西原本非我
       我便消失

  - k ::
       我说有可能 而你说 教我怎样做
       我已经教你了 但是你的意愿也许极为表面
       只是描述 分析 定义 就满足你了
       你怀着这些描述 分析 定义 从中架构了一个构想并说
       那么 我要怎么实现那个构想呢

* no syntax keyword for ex-bind

*** 引

    - x ::
         假使在這裏我們不用前綴 keyword
         而緊切 stack 語義
         那麼應該如何設計 binding 的語法呢

    - k ::
         我們可以回到之前的 #name 或 #:name

    - x ::
         我都忘記了我們當初爲何要背離這種語義
         在各種實現方式中遊蕩
         最終發現自己在原地轉圈
         正如找尋友誼之手
         正如找尋安寧之境
         找到一種生活的原則也是無謂
         因爲轉身我又會拋棄它

    - k ::
         我可以設想如此
         區分 >:name 與 #:name
         二者也可以記 '類型'
         前者爲 (-> [data] [])
         後者爲 (-> [data] [(# :name data)])

    - x ::
         啊 後者正如把 #:name 當作一個構造子

    - k ::
         看來是如此

    - x ::
         我們應該如何聲明與副作用有關的類型

*** 不論如何 計算機之計算都是對機器狀態之改變

    - k ::
         我想這時就是使用我們之前所提出來的原則的時候了
         即 不論如何 計算機之計算都是對機器狀態之改變

    - x ::
         沒錯 計算機之計算都是對機器狀態之改變
         我們寫的函數將要[在適當的條件下]改變機器的狀態
         我們爲函數加的類型就是要大略記錄這些狀態之改變
         而函數式編程的特點就是 狀態之改變都是 '可逆'
         所謂 '可逆' 並非是說函數是可逆函數
         而是要試着給所謂帶有 '副作用' 的函數加類型才能看出
         進行 input 的函數 比如類型記爲 (-> [A] [B (output)])
         不論與什麼函數複合
         其 succedent 中的 (output) 都不能被消除

    - k ::
         啊 這樣就完全錯了不是嗎
         因爲 (-> [...] [...]) 只是用來記錄棧中的變化之大略
         而不能用來記錄輸入輸出相關的機器變化
         但是說 '副作用' 是不可逆的 可能也對
         因爲副作用可能會改變 '機器外部' 的狀態
         當然 這裏的 內部外部 也是人爲界定的

    - x ::
         如此一來這種 (-> [...] [...]) 記法 就有了普世性
         只要是能夠相互消的 狀態變化 都可以如此來記錄
         對我的語言來說是副作用的東西
         對 system shell 的管道來說可能是可以被 (-> [...] [...]) 記法 記錄的

    - k ::
         這是不是可以說成是 輸入輸出的相對性

    - x ::
         如若如此
         我們就知道帶有 IO 的函數
         雖然最然在外層也可能被處理爲 antecedent 與 succedent
         但是在我們的語言之內是沒法處理它們的
         只能另行標記 而不用 (-> [...] [...]) 語法

*** 類型系統之向上抽象

    - k ::
         上面提到的普世性值得考察
         能想到反例嗎

    - x ::
         邏輯式編程可能是反例之一
         當要給邏輯式語言設計類型系統的時候
         用來描述關係之大概的 就不是箭頭所代表的有向變化
         而是一個多邊形的邊界了
         [正如之前所設想的爲 代數拓撲 所設計的語言一樣]
         但是也許可以這樣敘述普世性
         比如 hoare logic 描述底層帶有副作用的函數的類型
         也就是說 類型系統 總是可以向上抽象
         有時 當在 所使用的類型系統中描述某些 變化之大概
         而太過瑣碎繁複時
         可能就需要 把類型系統抽象到更高的層次
         但是 可能還沒有語言有這種能力

    - k ::
         我想這里還有很多需要學習的地方
         尤其是 hoare logic
         我想它能給我們的語法和語義設計帶來新的靈感

    - x ::
         沒錯 我們把這個話題留做下次討論吧

*** 副作用之 undo

    - x ::
         當考慮 用一般的後綴表達式來做 bind 時
         區分了兩種語法
         #+begin_src scheme
         >:name (-> [data] [])
         #:name (-> [data] [(# :name data)])
         #+end_src
         二者都應該是帶有 binding 這個副作用的
         即 他們會影響 bs
         但是 這些影響又可能被 undo 掉
         那麼 有可能在這裏利用 bs 的類型系統 來獲得安全性嗎

    - k ::
         函數的類型聲明
         即 對 ds 之變化的大略描述
         之所以有用
         是因爲 ds 的變化可能非常複雜
         因而需要大略描述
         但是 這裏 bs 的變化很簡單
         所以可能根本就不需要這種大略描述

*** >:name == #:name drop

    - k ::
         啊 我們根本就不需要 >:name
         只要 #:name drop 就好了
         #+begin_src scheme
         >:name (-> [data] [])
         #:name (-> [data] [(# :name data)])
         #:name drop (-> [data] [])
         #+end_src

*** hoare-logic

    - x ::
         我們在日本就發現
         我們的 sequent 語言只是 hoare-logic 的特例

    - k ::
         沒錯
         sequent 的特別指出在於
         所有的狀態都是用棧來描述的
         而 hoare-logic 則更底層

    - x ::
         即便是對 #:name 來說
         他的類型 (-> [data] [(# :name data)])
         也是用棧中元素的變化來表達的

*** 實現中需要做的變化

    - x ::
         首先
         語法上需要特殊處理形如 #:name 的 symbol
         正如爲了 var 而特殊處理 :name
         等等

*** 爲何不後綴處理 ->

    - x ::
         既然我們用後綴表達式來處理 :
         那麼爲什麼不用後綴表達式來處理 ->
         #+begin_src scheme
         (def nat-induction
           (lambda (-> [(-> [nat] [type]) #:p
                        zero :p @
                        (-> [nat #:k :k :p @]
                            [:k succ :p @])
                        nat #:x]
                       [:x :p @])
             (-> [:p :p/z :p/s zero] [:p/z])
             (-> [:p :p/z :p/s :n succ]
                 [:n
                  :p :p/z :p/s :n nat-induction
                  :p/s @])))

         (def nat-induction

           lambda

           [[nat] [type] -> #:p
            zero :p @
            [nat #:k :k :p @]
            [:k succ :p @] ->
            nat #:x]
           [:x :p @] ->

           [:p :p/z :p/s zero]
           [:p/z] ->

           [:p :p/z :p/s :n succ]
           [:n
            :p :p/z :p/s :n nat-induction
            :p/s @] ->)
         #+end_src

    - k ::
         既然我們不使用縮略語法了
         而又要以 只有需要的時候才使用編綴爲原則的話
         那麼 就真的沒有必要

    - x ::
         #+begin_src scheme
         (def nat-induction
           [[nat] [type] -> #:p
            zero :p @
            [nat #:k :k :p @]
            [:k succ :p @] ->
            nat #:x]
           [:x :p @] ->
           [:p :p/z :p/s zero]
           [:p/z] ->
           [:p :p/z :p/s :n succ]
           [:n
            :p :p/z :p/s :n nat-induction
            :p/s @] ->)

         ;; 省略 -> 而依據雙數斷句
         (def nat-induction
           [[nat] [type] -> #:p
            zero :p @
            [nat #:k :k :p @]
            [:k succ :p @] ->
            nat #:x]
           [:x :p @]

           [:p :p/z :p/s zero]
           [:p/z]

           [:p :p/z :p/s :n succ]
           [:n
            :p :p/z :p/s :n nat-induction
            :p/s @])

         (def nat-induction
           [[nat] [type] -> #:p
            zero :p @
            [nat #:k :k :p @]
            [:k succ :p @] ->
            nat #:x]
           [:x :p @]
           [:p :p/z :p/s zero]
           [:p/z]
           [:p :p/z :p/s :n succ]
           [:n
            :p :p/z :p/s :n nat-induction
            :p/s @])

         ;; 同時以這種方式處理 lambda
         (def nat-induction
           [[[nat] [type] -> #:p
             zero :p @
             [nat #:k :k :p @]
             [:k succ :p @] ->
             nat #:x]
            [:x :p @]
            [:p :p/z :p/s zero]
            [:p/z]
            [:p :p/z :p/s :n succ]
            [:n
             :p :p/z :p/s :n nat-induction
             :p/s @]] lambda)

         ;; 不省略 ->
         ;; 畢竟省略 -> 算是一種 sugar
         (def nat-induction
           [[[nat] [type] -> #:p
             zero :p @
             [nat #:k :k :p @]
             [:k succ :p @] ->
             nat #:x]
            [:x :p @] ->
            [:p :p/z :p/s zero]
            [:p/z] ->
            [:p :p/z :p/s :n succ]
            [:n
             :p :p/z :p/s :n nat-induction
             :p/s @] ->] lambda)

         ;; 甚至 def 也用後綴處理
         [[[nat] [type] -> #:p
           zero :p @
           [nat #:k :k :p @]
           [:k succ :p @] ->
           nat #:x]
          [:x :p @] ->
          [:p :p/z :p/s zero]
          [:p/z] ->
          [:p :p/z :p/s :n succ]
          [:n
           :p :p/z :p/s :n nat-induction
           :p/s @] ->] lambda
         'nat-induction def

         ;; 或
         [[[nat] [type] -> #:p
           zero :p @
           [nat #:k :k :p @]
           [:k succ :p @] ->
           nat #:x]
          [:x :p @] ->
          [:p :p/z :p/s zero]
          [:p/z] ->
          [:p :p/z :p/s :n succ]
          [:n
           :p :p/z :p/s :n nat-induction
           :p/s @] ->] lambda
         [nat-induction] def

         ;; 這樣其實是在解決 meta-programming 的問題
         ;; 既然程序本身被作爲數據如此肢解了
         #+end_src

    - k ::
         那麼我們就好好討論一下 meta-programming 的問題
         #+begin_src scheme
         [[[[nat] [type] -> #:p
            zero :p @
            [nat #:k :k :p @]
            [:k succ :p @] ->
            nat #:x]
           [:x :p @]]
          [[:p :p/z :p/s zero]
           [:p/z]]
          [[:p :p/z :p/s :n succ]
           [:n
            :p :p/z :p/s :n nat-induction
            :p/s @]]] lambda
         [nat-induction] def


         [[[nat] [type] -> #:p
           zero :p @
           [nat #:k :k :p @]
           [:k succ :p @] ->
           nat #:x]
          [:x :p @]

          [:p :p/z :p/s zero]
          [:p/z]

          [:p :p/z :p/s :n succ]
          [:n
           :p :p/z :p/s :n nat-induction
           :p/s @]] lambda
         [nat-induction] def


         [[[nat] [type] -> #:p
           zero :p @
           [nat #:k :k :p @]
           [:k succ :p @] ->
           nat #:x]
          [:x :p @]]
         [[:p :p/z :p/s zero]
          [:p/z]

          [:p :p/z :p/s :n succ]
          [:n
           :p :p/z :p/s :n nat-induction
           :p/s @]] lambda
         [nat-induction] def


         lambda
         [[[nat] [type] -> #:p
           zero :p @
           [nat #:k :k :p @]
           [:k succ :p @] ->
           nat #:x]
          [:x :p @]]
         [[:p :p/z :p/s zero]
          [:p/z]
          [:p :p/z :p/s :n succ]
          [:n
           :p :p/z :p/s :n nat-induction
           :p/s @]]
         end

         ;; 假設我們的原則是
         ;; 讓 lambda 所做的工作越少越好
         [[[nat] [type] -> #:p
           zero :p @
           [nat #:k :k :p @]
           [:k succ :p @] ->
           nat #:x]
          [:x :p @]
          ->
          [:p :p/z :p/s zero]
          [:p/z]
          ->
          [:p :p/z :p/s :n succ]
          [:n
           :p :p/z :p/s :n nat-induction
           :p/s @]
          ->] lambda
         [nat-induction] def

         [[[nat] [type] -> #:p
           zero :p @
           [nat #:k :k :p @]
           [:k succ :p @] ->
           nat #:x]
          [:x :p @] ->
          [:p :p/z :p/s zero]
          [:p/z] ->
          [:p :p/z :p/s :n succ]
          [:n
           :p :p/z :p/s :n nat-induction
           :p/s @] ->]
         lambda
         [nat-induction] def


         (((nat) (type) -> #:p
           zero :p @
           (nat #:k :k :p @)
           (:k succ :p @) ->
           nat #:x)
          (:x :p @) ->
          (:p :p/z :p/s zero)
          (:p/z) ->
          (:p :p/z :p/s :n succ)
          (:n
           :p :p/z :p/s :n nat-induction
           :p/s @) ->)
         lambda
         (nat-induction) def


         {{{nat} {type} -> #:p
           zero :p @
           {nat #:k :k :p @}
           {:k succ :p @} ->
           nat #:x}
          {:x :p @} ->
          {:p :p/z :p/s zero}
          {:p/z} ->
          {:p :p/z :p/s :n succ}
          {:n
           :p :p/z :p/s :n nat-induction
           :p/s @} ->}
         lambda
         {nat-induction} def
         #+end_src

    - x ::
         啊 如若依照這種原則
         根本就只要用到三種括號中的一種
         我們選擇 [] 就好了

    - k ::
         我們是否要在這個 sequent0 中實踐這種語法

    - x ::
         哈哈
         這種感受就是脫離了 lisp 的傳統
         但是又接近了 forth
         我想使用 {} 可能優於使用 [] 或 ()
         因爲 [] 或 () 不單獨成行
         而 {} 單獨成行
         #+begin_src cicada-language
         [[[nat] [type] -> #:p
           zero :p @
           [nat #:k :k :p @]
           [:k succ :p @] ->
           nat #:x]
          [:x :p @] ->
          [:p :p/z :p/s zero]
          [:p/z] ->
          [:p :p/z :p/s :n succ]
          [:n
           :p :p/z :p/s :n nat-induction
           :p/s @] ->]
         lambda
         [nat-induction] def


         (((nat) (type) -> #:p
           zero :p @
           (nat #:k :k :p @)
           (:k succ :p @) ->
           nat #:x)
          (:x :p @) ->
          (:p :p/z :p/s zero)
          (:p/z) ->
          (:p :p/z :p/s :n succ)
          (:n
           :p :p/z :p/s :n nat-induction
           :p/s @) ->)
         lambda
         (nat-induction) def


         {{{nat} {type} -> #:p
           zero :p @
           {nat #:k :k :p @}
           {:k succ :p @} ->
           nat #:x}
          {:x :p @} ->
          {:p :p/z :p/s zero}
          {:p/z} ->
          {:p :p/z :p/s :n succ}
          {:n
           :p :p/z :p/s :n nat-induction
           :p/s @} ->}
         lambda
         {nat-induction} def
         #+end_src
         再看單獨成行的
         #+begin_src cicada-language
         [ [ [ nat ] [ type ] -> #:p
             zero :p @
             [ nat #:k :k :p @ ]
             [ :k succ :p @ ] ->
             nat #:x ]
           [ :x :p @ ] ->
           [ :p :p/z :p/s zero ]
           [ :p/z ] ->
           [ :p :p/z :p/s :n succ ]
           [ :n
             :p :p/z :p/s :n nat-induction
             :p/s @ ] ->
         ] lambda
         [ nat-induction ] def


         ( ( ( nat ) ( type ) -> #:p
             zero :p @
             (nat #:k :k :p @ )
             ( :k succ :p @ ) ->
             nat #:x )
           ( :x :p @ ) ->
           ( :p :p/z :p/s zero )
           ( :p/z ) ->
           ( :p :p/z :p/s :n succ )
           ( :n
             :p :p/z :p/s :n nat-induction
             :p/s @ ) ->
         ) lambda
         ( nat-induction ) def


         { { { nat } { type } -> #:p
             zero :p @
             { nat #:k :k :p @ }
             { :k succ :p @ } ->
             nat #:x }
           { :x :p @ } ->
           { :p :p/z :p/s zero }
           { :p/z } ->
           { :p :p/z :p/s :n succ }
           { :n
             :p :p/z :p/s :n nat-induction
             :p/s @ } ->
         } lambda
         { nat-induction } def
         #+end_src

    - k ::
         如此看來又是 [ ] 最順眼
         看來 這些都是 習慣所致呀

    - x ::
         那麼我們不考慮排版問題了
         先考慮實現
         首先我們可以把 [ ] 實現爲 call-with-output-to-new-ds
         這樣 lambda 所看到的就是 arrow-list
         而不是 syntax-tree 了

    - k ::
         但是這樣對 [ ] 中的 name 的解釋就有衝突了
         -> 需要他們是 literal
         而 lambda 需要他們是 call-with-output-to-new-ds
         所以 必須區分二者
         #+begin_src scheme
         { [ [ nat ] [ type ] -> #:p
             zero :p @
             [ nat #:k :k :p @ ]
             [ :k succ :p @ ] ->
             nat #:x ]
           [ :x :p @ ] ->
           [ :p :p/z :p/s zero ]
           [ :p/z ] ->
           [ :p :p/z :p/s :n succ ]
           [ :n
             :p :p/z :p/s :n nat-induction
             :p/s @ ] ->
         } lambda
         [ nat-induction ] def

         ;; 如果所有的 literal-symbol 都必須出現在 [ ] 中
         ;; 那麼就必須改如下爲下下或下下下
         { [ ] [ type ] ->
           zero  [ ] [ <> ] ->
           succ  [ <> ] [ <> ] ->
         } type
         [ def ] nat

         { [ ] [ type ] ->
           'zero  [ ] [ <> ] ->
           'succ  [ <> ] [ <> ] ->
           } type
         [ def ] nat

         { [ ] [ type ] ->
           [ zero ] [ ] [ <> ] ->
           [ succ ] [ <> ] [ <> ] ->
         } type
         [ def ] nat

         { [ nat nat ] [ nat ] ->
           [ :m zero ] [ :m ] ->
           [ :m :n succ ] [ :m :n add succ ] ->
         } lambda
         [ add ] def
         #+end_src

    - x ::
         我發現這種純粹的後綴表達式
         會強迫語言的正規性

    ------------

    - x ::
         但是我想我要放棄這種設計

    - k ::
         既然語言本身以後綴表達式爲特點
         爲什麼要放棄這種設計呢
         如果後綴表達式本身並不好
         爲什麼要設計一個以後綴表達式爲特點的語言呢

    - x ::
         我也不知道
         我想問題出在元編程能力上
         我們應該完全放棄這種能力
         以維護語言的穩定性

* 完全放棄元編程能力 以維護語言的穩定性

*** 引

    - x ::
         說元編程能力不利與語言之穩定
         難道不是可笑而保守的說辭嗎
         我感覺我已經喪失了 對是非對錯的判別了

    - k ::
         我們可以在不做是非對錯之判別的條件下行動嗎

    - x ::
         比如埋頭實現 sequent0
         而不考慮其優劣

    ------------

    - x ::
         啊 我能想到 如果使用純粹的後綴表達式來實現它
         效果將是如何有趣
         用於實現語言核心語義的函數本身
         也將是用語言的 meta-programming 能力來實現的
         但是我還是決定暫時放棄這種效果
         之要求 jojo 中的東西是完全後綴的
         而自由地[不在乎純粹性地]處理外層非後綴語法
         [只要知道這些語法是可以利用元編程來後綴化的就可以了]

* 更換新語法 而轉回到 at1

*** 引

    - x ::
         更換新語法之後
         我想我們的探索 就應該轉回到 at1 了
         畢竟它纔是應用源泉

    - k ::
         每次轉回到理論學習都非易事
         可能又是需要用到 k 的認識倫的時候

    - x ::
         我想說明天我們找個安靜的地方在談
         但是 k 之方法的關鍵就在於
         不要受到限於環境與時間

    - k ::
         我們今天讀的 k 可以總結如下
      1. 我堆非我成我
      2. 努力是盲目的最高形式

* new structure of rs

*** 引

    - x ::
         we need a new structure of rs
         當前我們有
         #+begin_src scheme
         (type rs {{counter explainer ender jojo} ...})
         (type gs {{counter explainer ender {data-list data-list}} ...})
         #+end_src
         我們需要的只是簡單地在 rs-point 中增加一個 field 嗎

    - k ::
         其不簡單之處在於
         此時需要重新寫所有有關 rs-point 的 pattern-marching

    - x ::
         這就是 pattern-marching 所寫的代碼的弱點了
         [因爲數據結構的接口變化
          也要反應在使用這些接口的函數中
          除非給每個 field 以名字]
         也許我們應該分場合使用 pattern-marching
         只有在 term-rewrite 的過程中 pattern-marching 纔是最適合的
         在這種需要大量副作用的地方
         就使用類似 oo 的接口

    - k ::
         正如上所說
         想要不讓數據結構的接口反應在使用這些接口的函數體里
         就只能給這些 field 以名字
         不論是 agda 的 record 還是 oo

    --------------------

    - x ::
         我們是否應該讓每一個 stack 都使用新設計的簡單 oo 機制

    - k ::
         首先 ds 可能就不應該使用這個機制
         即便是就一個 不考慮效率的 實驗性解釋器 而言
         在 ds 中的 data 上加一層 也會讓處理 ds 的函數變複雜

    - x ::
         這樣我們就喪失了 stack 的統一性

    - k ::
         我們沒必要維持這種統一性
         我覺得只有 rs 與 gs 值得一改
         其他的 stack 就維持簡單的接口

* 區分 arrow 中的 自由變元 與 約束邊緣 <2016-12-01 Thu>

*** 引

    - x ::
         這是與變元有關的新設計之改進
         首先
         自由變元有明顯的語法區分
         約束變元 記以 :name
         自由變元 記以 ::name
         同一個 arrow 中自由變元與約束變元不能重名
         分兩個域在 arrow 中記錄 自由變元與約束變元
         每當作用一個 arrow 時
         要爲其約束變元生成 uni-var
         每當返回一個 arrow 時
         其中所有的自由變元都要 被確定其 uni-var
         這樣 所有的 arrow 在作用時 其自由變元之 uni-var 都是已經確定的
         不用再另行生成

    - k ::
         如此一來
         作爲 jo 的 arrow
         就與 作爲 data 的 arrow 不同了
         作爲 jo 的 arrow 有 fvar-list
         作爲 data 的 arrow 有 fvar-record

    - x ::
         正如 var 與 uni-var
         這裏也可以區分 arrow 與 uni-arrow
         lambda 與 uni-lambda
         如此看來 jo 與 data 的 data-constructor 就完全不同了

*** 更多的不變量

    - x ::
         能夠被作用的是 uni-arrow
         作用 uni-arrow 的時候也要利用 vl 生成 vrc
         從名字找到的 arrow 與 lambda fvl 總是空的
         因爲作爲等層函數體 他們是不能帶有自由變元的

* 漸進測試

*** 引

    - x ::
         漸進測試的方式應該如何
         先實現 run 爲漸進
         還是先實現 type-check 爲漸進

    - k ::
         我們先實現 type-check 吧
         這樣算是把 最難的地方優先處理
         然後馬上測試 run

* scope

*** 引

    - x ::
         關於 scope 還有一個問題
         #+begin_src scheme
         (define f3 (-> [nat (-> [nat] [])]
                        [])
           (-> [:n :f]
               [:n :f @
                :n succ :f @
                :n succ succ :f @]))

         ;; 假使一個函數的參數里有函數
         (run
           zero
           (lambda (-> [nat] [])
             (-> [:n] []))
           f3)
         #+end_src
         問題是
         當有這樣的作用時
         f3 函數體內部的 :n 與 :f 內部的 :n 如何不相互影響

    - k ::
         因爲每次 apply 的時候 [或者 compose/arrow 等等]
         都會入 rs 新的 rsp
         而 uni-var 是從 rsp 中的 vrc 中找到的
         不同的 arrow 之 apply 不會互相響

    - x ::
         沒錯
         這樣我們就有合理的 scope 語義了

* level of var

*** 引

    - x ::
         好像 uni-var 不必是 {'uni-var id level}
         而可以直接是 {'uni-var id}
         因爲 並沒有 uni-var 的不同 level 作爲 data 的出現

    - k ::
         uni-var 之 level-1 的值是在 bind-unify 中才用到的
         並且只能在這個時候用到

    - x ::
         但是我們可以想象增加 返回 uni-var level-1 的值的直接語法
         我們先保留這個 level field 吧

* oo 機制之氾用

*** 引

    - x ::
         看如下的函數體
         #+begin_src scheme
         (define (cut/call j)
           (match j
             [{'call n}
              (let ([found (assq n ns)])
                (if (not found)
                  (orz 'cut/call ("unknow name : ~a~%" n))
                  (match (cdr found)
                    [{'meaning-type a n nl}
                     (cut/type a)]
                    [{'meaning-data a n n0}
                     (cut/type a)]
                    [{'meaning-lambda a al}
                     (cut/type a)])))]))
         #+end_src
         看來這裏也是需要使用 oo 機制的地方

    - k ::
         這裏的衝突到底是什麼
         我想重點甚至不在於 pattern match 與否
         重点也不在于 oo 与 fp 的冲突
         而是在于
         有名的 field 与 无名的 field
         只有当 field 有名时
         对接口函数的使用才能与数据结构本身的构造分离
         #+begin_src scheme
         (define (cut/call j)
           (match j
             [{'call n}
              (let ([found (assq n ns)])
                (if (not found)
                  (orz 'cut/call ("unknow name : ~a~%" n))
                  (cut/type (^ (cdr found) 'a))))]))
         #+end_src

    - x ::
         也許這裏需要的只是 match 中的 or 語句

* the structure of uni-bind

*** 引

    - x ::
         now the structure of uni-bind is
         {'uni-bind uni-var data}
         需要修改其 field
         這設計到當前實現的可擴展性
         具體地說
         一種是 在 uni-bind 中記錄 level
         一種是 不在 uni-bind 中記錄 level
         問題是我們應該使用那種實現方式
         因爲我們知道
         有一個重要的原則是保持當前實現之最簡
         而不爲了之後所謂的 '擴展'
         來把當前的代碼複雜化

    - k ::
         當前所有的 binding 都是 uni-var 的 level-1 與 data 的綁定
         記錄 level 看似可以把 binding 擴展到 別的情況
         但是其實可能根本就是不需要的
         因爲
         type-check 的關鍵就是 兩層信息
         並且
         level-0 的 binding 只能通過 cover 與 unify 來形成
         這是 一個不錯的不變量

    - x ::
         那麼我們就遵循 '保持當前實現之最簡' 這個原則吧

    ------------

    - x ::
         我發現可能不能簡化 uni-bind 的結構
         因爲 bs 相關的很多搜索函數都將以 uni-var 爲參數

    - k ::
         我們把這些東西放在之後改進吧
         只要試着先實現語言的功能
         當真正迫切需要更改數據結構的時候
         就一定能不必猶豫而直接更改了

* type-arrow 與 arrow 有別

*** 引

    - x ::
         目前使用的數據類型
         以 arrow 爲 type
         以 arrow-list 爲 body
         但是其實 arrow 作爲 type 和 arrow 在 body 中出現是有別的
         |----------+----------------------+-------------------------------|
         |          | type                 | body                          |
         |----------+----------------------+-------------------------------|
         | %:name   |                      | 不能出現 因爲這是             |
         |          |                      | level-n 帶有 level-n-1 的信息 |
         |----------+----------------------+-------------------------------|
         | (->)     |                      | 不能出現                      |
         |          |                      | 因爲沒法做 type-infer         |
         |----------+----------------------+-------------------------------|
         | (lambda) | 不能出現 正如        |                               |
         |          | 不能有數據的類型爲 1 |                               |
         |----------+----------------------+-------------------------------|

    - k ::
         下圖就是區別了
         |            | compose | cut |
         |------------+---------+-----|
         | type-arrow | +       | -   |
         | body-arrow | +       | +   |
         type-arrow 可以被 cut

*** 在寫的時候

    - x ::
         在寫代碼的時候 我總會生厭
         而想要逃離寫代碼本身
         好像完成這個程序並不重要一樣
         因爲 如果完成這個程序至關重要
         那麼我就應該傾我所能來完成它
         在寫一個個函數時
         我好像忘記了寫這整個程序的原因
         也忘記了它的用處

    - k ::
         那麼我們現在就來審視一下我們的目的吧
         我們寫 sequent0 是爲了 完成 sequent1 所未完成的使命
         來探索這種類型系統的可能性
         我們想要在完成其他類似的語言之功能的同時
         簡化其實現本身
         我們想要在之後改進實現方式
         使得所獲得的語言表達能力更強
         進而用來作爲探索幾何和拓撲學的工具

    - x ::
         沒錯
         還有別的數學門類
         每當我想看一個有趣的數學書的時候
         我總是想 如果我有一個實用的語言
         我就可以利用我的語言來以我的方式總結這些知識了

    - k ::
         我們還想寫書做教學
         還想用中文
         還想用它來解決實際生活中的問題

    - x ::
         我們並沒有一個具體的問題
         我們並不是要求一個結論

* at1 與 rc1

*** 引

    - x ::
         之前我們說 at1 絕對需要 rc1 來實現
         而今我們卻在 scheme 中設計了小的 object 與 struct 系統
         我們是否不需要 rc1 了呢

    - k ::
         爲了可以靈活擴展語言的 literal data
         有必要講所有的 data 都用 object 來實現
         爲了脫離 scheme 的束縛
         有必要使用新的編譯語義更強的實現方式

    - x ::
         儘管知道這是一個 proto 但是我們還是先來把它寫完吧

* 漢夷何以別

*** 引

    - x ::
         漢夷何以別
         語言可別乎

    - k ::
         不可
         西人製中國史
         以漢語錄之
         漢人觀之而知其爲西人所製
         何以有別

    - x ::
         方法可別乎
         夷人依其先祖之法理求索真知
         漢人亦依其先賢之法理求索真知
         是以有別

    - k ::
         夫言語之別顯矣
         方法之別隱矣
         且方法依用而分優劣
         他法因其有用而優
         我法因其無用而劣
         知其劣而執其法乎

    - x ::
         此言差矣
         立法名理者人也
         釋法論理者人也
         我等釋我先賢之法以新義
         蓋其有別於夷法也
         我等用我先賢之法以爲用
         使其優於夷人之法而爲上
         則漢夷可別
         且爲用不敗

         且夫有言者
         習師長之言以言
         求索法理者
         釋先賢所立之法
         論先賢所名之理
         於漢於夷 無不如此
         所以漢夷有別也

         且夫誠心求索者
         必不拘泥先賢
         釋所立 論所名
         以合時境而爲用
         是以不敗也

         心系一萬
         而始於一

         衆源可從似遺傳
         人可自選似變異
         我自選漢族 而不涉他人之決策

* 朝代衰變因超人不易也

*** 引

    - x ::
         爲帝王而治盛世者需超人
         世襲而超人之力難存

* >< 漢語的自言性

* ><>< more about type-check & compose & cut

*** 引

    - x ::
         我想這也是總結之前筆記的時候了

    - k ::
         cover & unify
         又有 bind-unify
         type-check & compose & cut 都是用它們實現的

*** 記

    - 此處編譯
      簡之又簡
      轉寫增補
      消文本歧義以成珠而已

    - 這裏實現方式固定
      不能增添珠類
      爲增添珠類
      需依類查方法
      增一珠類 補其方法已矣

*** unify 與 珠類

    - x ::
         增添珠類之難點在於
         compose & cut 參數爲一
         但是 cover & unify 參數爲二
         每當增添 必須補全其他
         珠類越多 需補全的就越多
         尤其是對不可交換的 cover 來說更是如此

    - k ::
         需補全
         亦可缺省
         至少就 cover & unify 而言是如此

    - x ::
         也許可擴展性是虛的
         literal 數據結構都應該用 cons 實現
         [或用 與 cons 類似的處理方式缺省]

*** compose & cut

    - x ::
         不考慮運行時的話
         compose 只作用於 type-arrow 中的 jo
         而 cut 只作用於 body-arrow 中的 jo

    - k ::
         類型中能出現 add 之類的任意計算
         這正是 compose 作用於 type-arrow 中的 jo
         但是之前我們沒有觀察到
         compose 只作用於 type-arrow 中的 jo
         這個事實
         既然如此 compose 的時候就應該還伴隨着 type-level 的 unify
         [即所謂的 bind-unify]
         這就要求我們從 data 得到 type
         這是可能的嗎

    - x ::
         這是可能的
         甚至 cut 本身就能用 data->type 來實現

    - k ::
         如若如此
         我們就來實現 data->type
         並且 重新審視 compose & cut 這種分類
         也許不要 cut 了
         但是
         這樣還伴隨着 type-level 的 unify
         對於真正的運行時有什麼影響

    - x ::
         可以增加 flag
         使得這個 unify 不影響真正的運行時
         我們並不考慮運行效率
         我們是爲了數學證明的形式化而設計語言的

    - k ::
         how to data->type a trunk ?

*** factor data->type out form cut

    - x ::
         不能 factor data->type out form cut
         cut 獨立的存在算是一種優化

    - k ::
         也許應該如此處理
         否則的話 簡單的 cut 就被隱藏在對 d2t 對 trunk 的處理當中了

*** the structure of trunk

    - x ::
         當前是
         #+begin_src scheme
         {'trunk uni-arrow (vector trunky) index}
         ;; 其中 uni-arrow 應該改成 兩列數據
         {'trunk adl sdl (vector trunky) index}
         ;; 其中 adl 是經過 unify 的
         #+end_src

* 信息不減

*** 引

    - x ::
         之前說過 需要保持 信息不減
         而這裏所說的 data->type 就是信息減少之處
         正確的方式
         不是使用 data->type 之後
         再用 unify 與 bind-unify 這兩層 unify
         而是用一個 diff-level-unify 來處理
         也就是說
         要用函數來解決問題
         而不是用數據結構來解決問題
         或者說
         解決問題的時候
         數據結構可以儘量保持簡單
         而把函數寫複雜一點

* unify arrow

*** 引

    - x ::
         我們不能 unify arrow 與 arrow

    - k ::
         我想這裏我們不能苟且
         我們應該想出 unify arrow 的方式
         並且講我們語言的理論特性弄明白

    - x ::
         how to define the unification of arrow ?
         if some data can be covered by both of them
         then unify or cover the result
         how to imp the definition ?
         unify ajj1 ajj2
         then unify or cover the result of sjj1 sjj2

* review the commit problem

*** 引

    - x ::
         目前用到 commit 的地方就只有 compose/try-body
         但是這明顯是不夠的

    - k ::
         要知道 commit 的原則是
         只要確定不需要 undo 就可以 commit
         把變元所綁定到的值寫到變元內部
         而存在於變元外部的 變量綁定值 只是爲了 undo 而準備的

*** 自治性 與 控制流

    - x ::
         目前實現 commit 的方式可能也有問題
         之前的處理方式是把 bs/commit 作爲 ender 放入 gsp 中
         以求自治與擴展
         但是這可能又是一個虛的設計
         #+begin_src scheme
         ;; 比如
         (if3 [(push bs '(commit-point))
               (push gs (% gsp-proto
                           'ex   (unify 'cover)
                           'end  bs/commit
                           'dl+  (reverse dl1)
                           'dl-  (reverse dl2)))
               (gs/next)]
              [{sjj vrc}]
              [(set! ds ds0)
               (set! bs bs0)
               (set! gs gs0)
               (compose/try-body r)])
         ;; 完全可以被替代成
         (if3 [(push bs '(commit-point))
               (push gs (% gsp-proto
                           'ex   (unify 'cover)
                           'end  gs/exit
                           'dl+  (reverse dl1)
                           'dl-  (reverse dl2)))
               (gs/next)]
              ;; commit or undo
              [(bs/commit)
               {sjj vrc}]
              [(set! ds ds0)
               (set! bs bs0)
               (set! gs gs0)
               (compose/try-body r)])
         #+end_src

    - k ::
         也就是說 commit 不應該放到 gsp 中自治
         而應該放在 scheme 代碼所形成的控制流中

*** 關於 undo

    - x ::
         可以 commit == 不需要 undo
         因此我們需要明確何時需要 undo

* steper <2016-12-13 Tue>

*** 引

    - x ::
         我們需要一個 steper
         爲了弄清一個 steper 應該如何實現
         我們也能釐清運行時解釋器的工作方式

    - k ::
         然後我們去處理完餘下的問題
         再寫一些例子程序來檢驗解釋器
         需要做的工作還有很多
         還有 cover-check 與 recur-check
         我們還需要對比 agda 相關的論文與文檔
         看看我們是否已經到達 agda 的用性

    - x ::
         我們不妨把今天作爲這些工作的 deadline 試試

    - k ::
         可以一試
         這將是全情投入的一個下午
         就像在奈良一樣

* review the commit too much problem <2016-12-14 Wed>

*** 引

    - x ::
         binding 是可以越過 commit-point 的
         在作用一個函數的時候
         每個 arrow 會形成自己的 commit-point
         用來在作用成功時 commit binding
         不是這個 arrow 自己的約束變元
         就不應該被這次 arrow 的作用 commit
         不是約束變元就是自由變元
         [現在的實現中已經有 約束變元 與 自由變元 之分了]
         也就是說 只要保證任何 arrow 都不 commit 到自由變元就好了

    - k ::
         一種處理方式是
         每個 變元[uni-var] 第一次出現
         就讓它在 bs 中佔有位置
         但是這樣的缺點是 會有很多無效的搜索

    - x ::
         變元之約束與自由是相對當前作用的 arrow 而言的
         注意 控制流是在 scheme 函數中的
         因此不能通過 (tos rs) 來找當前的 arrow
         而應該在 scheme 代碼中給 (bs/commit) 增加一個參數
         讓它知道哪些變元是自由的 因而應該避免被用來做 binding 的

* up-unify tadl to dl when applying cons or lambda <2016-12-16 Fri>

*** 引

    - x ::
         這一點可能是急需優化的
         並且它可能是讓機器證明的步驟不能被清晰理解的最大原因

    - k ::
         當初爲什麼需要這種處理方式

    - x ::
         也就是說我們有兩種 compose
         一個是 type-check 時的 compose
         一個是 真正的運行時的 compose
         而這裏所使用的 up-unify
         就相當於是在運行時查看函數的類型是否能夠作用於數據
         這種處理顯然不應該出現在 真正的運行時的 compose 中

*** 新的實現方式

    - k ::
         我們完全以 type-check 爲先
         不考慮真正的運行時
         既然 type-check 總是要用到數據的類型
         不如直接 讓 ds 中的每個 dsp 帶有 data 與 type

    - x ::
         我們來考察一下如此處理的後果
         (1)
         代碼的結構能夠得到極大的簡化
         不必有 d2t 之類的函數了
         uni-var cons trunk 還有 bs 等等 數據結構都要改變
         (2)
         我們所寫的將是一個解釋器
         它的主要功能是 type-check
         而不是高效地計算
         (3)
         計算能夠出現在 type-check 中
         並且此時的計算 比 真正的運行時中的計算所見到的數據 更爲豐富
         真正的運行時
         可以利用另外一個解釋器來完成
         以避免 overhead

    - k ::
         我想這纔是正確的實現方式
         畢竟
         當使用編譯語義時
         真正的運行時只分離更是明顯
         type-check 就是應該用額外的解釋器來實現

*** 反思

    - x ::
         從 dependent-type 的語言的性質來看
         這種實現方式是顯然的

    - k ::
         沒錯
         也就是說
         用解釋器來實現類型檢查器
         同時作爲語言的 repl
         用這個解釋器做運算的時候 會有很大的 overhead
         同時還可以爲語言實現一個或多個不經類型檢查的解釋器
         或者實現編譯器後端

    - x ::
         總之應該分離就對了
         '有意義的區別值得保留'

    - k ::
         這裏 看似相似 但是實際上有區別的是
         兩種對 runtime 的需要求
         一個是 type-check 中
         一個是正常的 run

    - x ::
         我們現在就去修改實現吧

*** 重新實現

    - x ::
         因爲基本的設計變了
         所以我們需要重新實現
         重新實現的順序是
         (1)
         先想象 compose 與 type-check 之機器語義
         (2)
         然後確定 unify 的實現方式
         (3)
         最後是其他細節

    - k ::
         也許這次我們可以在這個過程中先確定語言的理論特性

    - x ::
         首先要對比設計變動之後 如上三者的差異
         注意

         type of arrow 也許是可以處理好的

         type-arrow 與 body-arrow 的差異明顯了

         每個 dsp 有兩層數據
         一層是 type 一層是 data
         type-arrow

         還是需要 up-unify
         因爲返回值的方式是固定的
         即 總是先返回到 data 域

*** 幻滅乎

    - x ::
         我們之所以提出新的實現方式
         是因爲 d2t/cons 中添加我們認爲正確的處理方式之後
         遇到了難以理解的錯誤
         我們不是去直面這個錯誤
         而是想繞過它

    - k ::
         我們設想了一種繞過它的方式了
         我們再想一下直接解決這個問題的方式

    - x ::
         首先 重要的是詳細的找到出錯點的可能性
         這就需要實現好 steper 並且對整個程序的運行方式有更好的理解
         其次 我們可以像實現 trunk 一樣實現 cons
         以解決 d2t/cons 的難題

    - k ::
         也就是說要改變 cons 的結構
         #+begin_src scheme
         {'cons n dl}
         ==>
         {'cons tsd n dl}
         正如
         {'trunk uni-arrow (vector trunky) index}
         ==>
         {'trunk tadl tsdl (vector trunky) index}
         #+end_src

    - x ::
         沒錯
         這樣 compose/cons 在作用時所做的 up-unify dl to tadl 就不會浪費了

    - k ::
         那麼 與之類似的 compose/body 在作用時所做的 up-unify dl to tadl
         還有其他的類似的地方
         是否也要有類似的處理呢

    - x ::
         compose/body & compose/apply 如果返回的是 trunk
         那麼就相當於已經如此處理了
* 報錯 與 call-back

*** 引

    - x ::
         爲什麼 使用了 gs 之後
         報錯信息還是不能反應出出錯的具體位置

    - k ::
         因爲出錯的時候 (gs/next who) 返回的是 bool
         而不是調用 debug0 而停下計算

    - x ::
         是否爲了顯示出錯誤的具體位置
         光有 gs 這個全局變量還是不夠的
         還需要在 控制流 上下文章

    - k ::
         我想有些 (gs/next who) 是需要返回 bool 的
         但是另外一些則需要 暫停計算

    - x ::
         這樣調用 gs/next 的時候應該給一個 call-back function
         來實現這種差異處理

    - k ::
         其實我們所說的調用 gs/next
         前面都跟着一個 (push gs ...)
         所以正確的處理方式是把之前刪除的 ender field 再加回來

    - x ::
         沒錯其實我們之前對 ender 的理解是錯誤的
         我們之前在用 ender 來處理 commit 或 non-commit 等等差異
         但是其實
         這些都是 good-end 的差異
         而我們現在要處理的是 bad-end 的差異
         call-back 之使用 可以理解成
         某個函數在運行時 可能會需要各種特殊情況
         需要用不同的函數來處理 這些特殊情況之出現
         這樣就要在調用這個函數的時候 把處理函數作爲參數準備好

* infer for uni-arrow <2016-12-19 Mon>

*** 引

    - x ::
         我們來試試

    - k ::
         注意
         所生成的 type-arrow 中要有 dependent 信息
         可以先試着做簡單的實現
         然後再仔細檢查 dependent 信息是否被保留

    - x ::
         我想
         最難的是 jojo 中的 {'call n} 應該如何處理
         可以用當前已有的數據結構來把它處理爲 type-arrow apply
         也可以專門爲它設計新的數據結構 比如 {'type-call n} 之類的
         另外
         arrow 與 uni-arrow 之間的細微差異 也可能造成困難

    - k ::
         看來這是可能的
         並且 如果成功的話
         這個 infer 就算是真正的 對語言的靜態分析了

    - x ::
         但是注意
         當前的
         {'var n}
         {'fvar n}
         都沒有 level 信息
         如果想要對 jojo 做 infer 的話
         這裏又要引回類型信息了

    - k ::
         就這麼辦吧
         把 level 信息引回來
         然後使得這種靜態分析成爲可能

    - x ::
         #+begin_src scheme
         (define (infer/uni-arrow ua)
           (: uni-arrow -> uni-arrow)
           )

         (define (infer/jojo >< jj)
           (: >< jojo -> jojo)
           )

         (define (infer/jo >< j)
           (: >< jo -> jo)
           )
         #+end_src

* 等詞難點

*** 引

    - x ::
         現在我們回顧
         之前在證明 add/commute 的時候遇到的等詞難點
         #+begin_src scheme
         (def eq
           (type (-> [type %:t drop
                      :t %:d
                      :t %:d]
                     [type])
             refl (-> [type %:t drop :t %:d drop]
                      [:d :d eq])))

         ;; success
         (def eq/test0
           (lambda (-> [] [zero :z eq])
             (-> [] [refl])))

         ;; fail
         (def eq/test1
           (lambda (-> [] [:z zero eq])
             (-> [] [refl])))


         ;; success
         (def eq/test2
           (lambda (-> [] [zero succ :z succ eq])
             (-> [] [refl])))

         ;; fail
         (def eq/test3
           (lambda (-> [] [:z succ zero succ eq])
             (-> [] [refl])))


         (def cong
           (lambda (-> [type %:t1 drop
                        type %:t2 drop
                        :t1 %:x drop
                        :t1 %:y drop
                        :x :y eq
                        (-> [:t1] [:t2]) %:f]
                       [:x :f @ :y :f @ eq])
             (-> [refl :f] [refl])))

         (def eq
           (type (-> [type %:t drop
                      :t %:d
                      :t %:d]
                     [type])
             refl (-> [type %:t drop :t %:d drop]
                      [:d :d eq])))

         (def add/zero-commute
           (lambda (-> [nat %:m]
                       [:m zero add
                        zero :m add eq])
             (-> [zero] [refl])
             (-> [:m succ]
                 [:m add/zero-commute
                     (lambda (-> [nat] [nat])
                       (-> [:n] [:n succ]))
                     cong])))

         ;;;; :m = zero
         ;; zero zero add
         ;; zero zero add eq

         ;;;; :m = :m succ
         ;; :m succ zero add
         ;; zero :m succ add eq
         ;;->
         ;; :m succ add
         ;; zero :m add succ eq

         ;; :m zero add succ
         ;; zero :m add succ eq
         ;;->
         ;; :m add succ
         ;; zero :m add succ eq

         (def add/commute (-> [nat %:m
                               nat %:n]
                              [:m :n add
                               :n :m add eq])
              (-> [:m zero]
                  [:m add/zero-commute])
              (-> [:m :n succ]
                  [:m :n add/commute
                      (lambda (-> [nat] [nat])
                        (-> [:n] [:n succ]))
                        cong ><><><]))

         :m :n add/commute
         ;; :m :n add
         ;; :n :m add eq
         (succ) cong
         ;; :m :n add succ
         ;; :n :m add succ eq

         这里需要等式的相乘
         ;; :n succ :m add
         ;; :n :m succ add eq

         ><><><
         ;; :m :n succ add
         ;; :n succ :m add eq
         #+end_src

    - k ::
         the equality to be proved
         almost always has self-unify
         so they can not pass occur-check
         it seems we must allow self-unify
         and handle it properly

    - x ::
         看來是如此
         我們根本就沒有把 self-unify 相關的理論研究透徹

    ------

    - x ::
         我現在能想到一個看來很明顯的解決這個問題的方法
         那就是每次遇到 self-unify 的時候 形成一個新的不被遞歸搜索的數據
         因爲這個數據是 帶有變元的等式
         所以這個數據就叫做方程
         [meaning is use]
         關於這個新數據的使用方式
         需要知道兩點
         一個是需要返回它的時候如何
         一個是需要 unify 它 與 別的數據的時候如何
         前者很簡單
         後者則不顯然
         我能想到的方式就是
         當 unify 一個 equation 到一個 non-equation 時
         就帶入 non-equation 然後看這個 non-equation 是否是 equation 的解
         當 unify 一個 equation 到一個 equation 時
         就形成 方程組 [equation-group]
         但是 方程組的形成看來只能是 無條件的

    - k ::
         我想這方面我們還有很多理論知識要學習

    - x ::
         沒錯
         我們需要看一些與 unification 有關的理論

*** self-unify & equation

    - x ::
         #+begin_src scheme
         (def add/zero-commute
           (lambda (-> [nat %:m]
                       [:m zero add
                        zero :m add eq])
             (-> [zero] [refl])
             (-> [:m succ]
                 [:m add/zero-commute
                     (lambda (-> [nat] [nat])
                       (-> [:n] [:n succ]))
                     cong])))
         ;; 證
         [:m zero add
          zero :m add eq]
         ;; 基礎步驟 :m = zero
         [zero zero add
          zero zero add eq]
         ;; 遞歸步驟 :m = :n succ
         [:n succ zero add
          zero :n succ add eq]

         ;; 遞歸調用 == 使用歸納假設
         ;; 遞歸調用 可以用來 寫函數
         ;; 歸納假設 可以用來 作證明
         ;; 遞歸調用 就記錄着 證明中使用歸納假設的地方

         ;; :n add/zero-commute [succ] cons
         [:n zero add succ
          zero :n add succ eq]

         ;; 而
         [:n succ zero add
          zero :n succ add eq]
         ;; =>
         [:n succ
          zero :n add succ eq]
         ;; 其次
         [:n zero add succ
          zero :n add succ eq]
         ;; =>
         [:n succ
          zero :n add succ eq]
         ;; 二者結果形式上相同
         ;; 都是
         [:n succ
          zero :n add succ eq]
         ;; 這會得到
         { equation
           :var:   :n
           :self:  (<trunk> zero :n add) }
         ;; 我們則需要 unify/equation/equation 處理
         ;;   uni-var 不同 而結構如上的 兩個 equation
         #+end_src

    - k ::
         cong 的原理是什麼
         #+begin_src scheme
         (def eq
           (type (-> [type %:t drop
                      :t %:d
                      :t %:d]
                     [type])
             refl (-> [type %:t drop :t %:d drop]
                      [:d :d eq])))

         (def cong
           (lambda (-> [type %:t1 drop
                        type %:t2 drop
                        :t1 %:x drop
                        :t1 %:y drop
                        :x :y eq
                        (-> [:t1] [:t2]) %:f]
                       [:x :f @ :y :f @ eq])
             (-> [refl :f] [refl])))
         #+end_src

    - x ::
         當想要在證明
         [:x :y eq] 時
         在函數體中 並不能直接使用 :x :y 本身
         從 [:x :y eq] 到 [:x :f @ :y :f @ eq]
         這類對 eq 這個數據的合法 rewrite
         都要定義一個函數之後方可使用
         爲什麼會這樣

    - k ::
         type-constructor 只能出現在 type-arrow 中
         type-constructor 所構造的數據
         是被 別的 type-arrow 的作用所 rewrite 的
         cong 所描述的 對 eq 的轉寫
         是合法的
         這是由 type-check 與 unify 的具體方式決定的

    - x ::
         對於 cong 來說
         好像他的 type-arrow 纔是真正的 rewrite 主體
         而 body-arrow 反而成了類似類型的 meta-data
         這個 meta-data 的效用是
         證明 這個 rewrite 主體 是合法的

* 回到 at1

*** 引

    - x ::
         但是類似 eq 的還有 has-length 等等
         在進行下一步的實現工作之前
         我想先考察一下 at1 中應該如何理解如上的語義
         at1 中的等詞如何處理

    - k ::
         在 at1 中
         隨處可見函數之間的等詞
         這在 sequent0 中是難以實現的
         at1 中還有 class 等等
         還有 quotient 對等詞的改變等等
         這些都是現在所實現的 sequent0 中難以想象的

    - x ::
         首先
         我們應該嘗試思考這些東西的實現方式
         其次
         我們要再堅定我們的知識
         使得我們能夠明確地判斷出
         某個命題或定義只構造性到底有多少
