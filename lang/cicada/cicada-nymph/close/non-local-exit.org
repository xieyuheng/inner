* 題解
  * 用以實現異常處理
* 討論 <2015-06-11>
  - x ::
       之前的異常處理機制是不完備的
       導致了很難找到的錯誤
       我們來重新設計
       這次
       我已經明確了我所需要的性狀
    1. 首先是對類型的安全判斷
       這在當前遇到的 bug 中已經體現了
    2. 其次
       對於所出現的 異常情況
       需要能夠有不同的處理方式
    3. 最後是傳遞
       當異常出現時
       它應該能夠把事故現場的慘狀通過參數傳遞給處理函數
    4. 還有
       需要能夠在異常處理函數中出現異常處理
       也就是說異常處理必須能夠嵌套
  - k ::
       這次遇到的錯誤確實可怕
       絕對不應該容忍這類不安全因素
       因爲 當它們所引起的錯誤 在後續的工作中出現時
       是很難找到的
  - x ::
       之前的錯誤來源於遍歷 返回棧對位置的尋找
       這是錯誤的
       因爲 函數體 中 什麼東西都有 是非常不正規的
       把函數體本身做爲數據結構 很難實現良好的處理函數
       顯然應該有一個 專門記錄非局部退出點的棧
       之前 返回棧 中 無爲的標記
       現在 應該成爲處理 記錄非局部退出點的棧 的函數
  - k ::
       沒錯
       首先有了棧 遞歸就能夠正確實現了
       把特殊的東西分離
       就能讓各個數據結構都變得正規 而好處理
       首先
       我們來給這個棧起一個名字
       然後
       你說一下基本的實現思路
       最後
       覈對你所舉出的四個性狀是否實現完備
  - x ::
       哦
       不對
       我可能不能用棧
       因爲 棧 之本意就在於順序
       即 記住現在還不能處理而之後要處理的東西
       之後按部就班地處理它們
       然而
       非局部退出 之本意就在於打亂順序
  - k ::
       但是
       其實順序還是在的
       只不過不是一步一步退出
       而是退回一大步
  - x ::
       沒錯
       每次總會有很多 非局部退出點 在等待着
       我需要保證的是 當我發出一個 非局部退出信號的時候
       應該能夠找到對應的 非局部退出點
       問題就是
       這種對應關係是如何建立的
       我想
       建立對應關係的方式只能是用 jo 的地址
  - k ::
       也就是說
       棧還是需要的
  - x ::
       棧中記錄 退出點在 返回棧 中的位置
       同時還有 非局部退出信號的名字
       順序是必要的
       就像我對 (load) 和 (import) 所做的那樣
       (load) 設置非局部退出點
       (import) 遇到異常情況時 非局部退出信號
       每個 非局部退出點 可以識別某些信號
       識別同樣 信號的點 會覆蓋之前的點 對同樣信號的識別
  - k ::
       沒錯
       那麼回到起名字的問題上來
  - x ::
       non-local-exit-piont
       non-local-exit-signal
       用否定前綴 non
       所形成的 消極詞組 non-local-exit
       應該被一個 積極的詞所代替
       但是
       我們還是先來總結一下實現方式
       因爲好的命名需要知道事項方式之後才能作出
       即 才能找出生動的比喻來描述
       但是
       如果沒有這些名詞 我們如何來描述實現方式呢
  - k ::
       可以先想像其實現方式
       然後在所得到的幾何比喻中找出合適的名詞
* 討論 <2015-06-12>
  - x ::
       | 期待 [非局部退出點]   | expect [make non-local-exit-piont] |
       | 動意 [非局部退出信號] | motion [non-local-exit-signal]     |
       structure of expectation in expecting-stack
       | expectation | function       |
       |             | return-stack   |
       |             | argument-stack |
       |             | motion         |
       對於所出現的 異常情況
       已經可以有不同的處理方式了
       每個 function 就代表了對 motion 的不同處理方式
       嵌套 也行了
       [之前嵌套不行 是因爲 保存 argument-stack 的方式不對]
       還需要考慮 傳遞
       當異常出現時
       它應該能夠把事故現場的慘狀通過參數傳遞給處理函數
       有參數傳遞的地方
       對參數類型檢查
       但是這裏檢查是被省略的
       因爲一個 motion 被那個函數處理是不確定的
       而 motion 所傳遞的參數也是不確定的
       可以選擇的用來傳遞動意現場信息的方式
       是 expecting-stack
       或 argument-stack
       兩種處理方式的接口將不一樣
       之前使用的是 argument-stack
       現在又有了 expecting-stack 這個選擇
       但是還是使用 argument-stack
       每個 function 可以從兩個地方取參數
       先是 動意現場
       後是 期待現場
  - k ::
       可以着手實現了麼
       還有什麼沒考慮到
  - x ::
       還有 motion 的存在方式
       用一個類型的 jo 顯得有些浪費
       能有 name 就好了
       但是 name-hash-table 是要在解釋器中才能出現的
       也就是說
       有兩種方式
       我們可以比較一下它們
    1. 用珠
       一個 動意 是一個特殊類型的珠
    2. 用名
       一個 動意 是一個對名的特殊處理
       用名則
       可以不必提前定義某個動意
       用珠則
       必須提前定義某個動意
       用珠時
       如果是沒有珠珠的珠
       那麼就浪費了豐富的數據結構
       使珠退化了
       如果能夠想到有什麼數據應該在 動意 中保存
       那麼就有理由用珠了
  - k ::
       之前是把 這種類型的珠的 珠珠 做爲處理函數的
       但是現在
       我覺得不應用珠
       因爲它其實就是個信號
       不應該有別的數據儲存在裏面
       並且
       如果用珠的話
       就有對珠的重複定義的問題需要考慮
       這種重複定義是不複合人們對信號的理解的
       而且當不想用名的時候
       所考慮到的是解釋器和匯編代碼之間的銜接問題
       要知道這種考錄只會拖後腿
       因爲之後匯編代碼是要被拋棄的
  - x ::
       沒錯
       那麼就用名
       這也就是說
       整個 期待動意機制 都必須在解釋器中實現
       那麼匯編代碼中就不能使用這種機制了
       這可行麼
  - k ::
       目前 在匯編代碼中使用 非全局的地方只有一個
       就是定義函數到一半的時候發現不能定義好
       然後就 (!undo-make-jojo)
       只要把這個地方想別的辦法處理好就行了
  - x ::
       另外還要注意
       在很多 make-jojo 的語法擴展中也用到了 (!undo-make-jojo)
       我發現這些都是需要在解釋器裏被重新實現的東西
       所以 解決辦法可以相對隨意一些
       有一個重置 expecting-stack 的函數 [也許就用 drop-expecting-stack]
       (expect) 需要把這個函數放在調用 (expect) 的函數的 jojo 底下
       應該說
       是把 一個 return-point 放在調用 (expect) 的函數的 return-point 底下
       但是注意 return-point 中除了 jojo 中的地址之外
       還有跟局部變元有關的地址
       這些地址用來在退出時重置 根局部變元有關的指針
       return-point 中的這些地址應該
       應該和 調用 (expect) 的函數的 return-point 保持一致
  - k ::
       但是
       關於 處理返回棧
       你目前沒有足夠的 素函數 來完成相關的工作
  - x ::
       沒錯
       應該設計更多的根返回棧處理有關的素函數
       使得足以用來實現 (expect)
  - k ::
       這並不是什麼難事
       而且很多以前的匯編代碼可以拋棄了
* 討論 <2015-06-13>
  - x ::
       我找到了新的名字
       | 待 | await |
       | 覺 | awake |
