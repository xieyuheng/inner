(define ?
  (lambda (x)
    (and (list x)
         (not (null? x))
         (eq? (car x) '))))

;; 希望给出比较不平凡的例子作为测试
;; 以使所有的递归在基本的测试中都能被跑到
(define example-graph
  ;; memory == O(|V|+|E|)
  ;; 点中保存与自己相邻的边 边中保存与自己相邻的点
  '(
    ;; 在下面的表示中 每一个点边元素都用方括号
    
    ;; vertex-list (0-dimension-geometry-object-list)
    ;; 每个点中有一个列表储存着所有以这个
    (#2=[(vertex-2 #2# (:value 222))
         (edge:2-->3 #4#) (edge:3-->2 #6#)]
     #3=[(vertex-3 #3# (:value 333))
         (edge:2-->3 #4#) (edge:3-->2 #6#)])

    ;; edge-list (1-dimension-geometry-object-list)
    ;; 注意边和点的储存方式是一致的
    (#4=[(edge:2-->3 #4# (:edge-type black-arrow))
         ;; 两个点在下面的列表中储存的顺序
         ;; 体现着这条边连接它们的方式
         (vertex-2 #2#) (vertex-3 #3#)]
     #6=[(edge:3-->2 #6# (:edge-type black-arrow))
         (vertex-3 #3#) (vertex-2 #2#)])
    
    ;; 可以发现图的几何语义限制了上面的列表的样子
    ;; 在图的语义下:
    ;;   2-dim几何体 能且只能 与两个1-dim几何体相连
    ;;        并且其邻接列表是有序的
    ;;   1-dim几何体 能 与0个或1个或多个2-dim几何体相连
    ;;        并且遗忘了其邻接列表的顺序

    ;; 显然在这里我们可以进行推广
    ;; 在这种实现方式下所能得到的最广泛的推广是:
    ;;   可以有n-dim几何体列表
    ;;   几何体都可以和任意维数的几何体相连接
    ;; 显然利用这种实现的推广
    ;; 只要再向上面一样添加某先限制条件
    ;; 就能够形成代数拓扑中的某些复形的语义

    ;; 但是要注意的是限制条件对语义的影响可能是相当微妙的
    ;; 几何语义的建立 可以帮助我们决定应该实现什么样的 基本处理函数
    ;; 基本的观察 与 基本的几何想像 总能把人们引向有趣而丰富的理论
    ))
