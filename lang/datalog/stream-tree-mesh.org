#+title: stream, tree, mesh

* info

- DOMAIN MODELING WITH DATALOG by Norbert Wojtowicz
  https://www.youtube.com/watch?v=oo-7mN9WXTw&ab_channel=%23pivorakLvivRubyMeetUp

* data -- stream, tree, mesh

- stream: order -- event, queue
- tree: hierarchy -- object composition, ui components
- mesh: relation & graph

** example: spotify

basic nodes:
- artist
- listener
- song

everything else are relations:
- album: artist, song
- playlist: user, song
- subscribe to playlist: user, playlist

* datalog -- entity, attribute, value

- xie: note that,
  - formal concept analysis only have: object (entity) and attribute
  - we can also add time to get: time, entity, attribute, value

** example: github

*** create some users

{ "user_name": "xie" }
{ "user_name": "yu" }
{ "user_name": "heng" }

database:

[11, "user_name", "xie"]
[22, "user_name", "yu"]
[33, "user_name", "heng"]

*** run some queries

query([11, _, _])
-> success -- because there is an entity 11

query([_, "user_name", "xie"])
-> success -- because there is an user called "xie"

query([33, "user_name", "xie"])
-> fail -- because entity 33's user name is not "xie"

*** queries that not only success or fail but also return matched result set

query([?e, _, _])
-> { e: 11 }, { e: 22 }, { e: 33 }

query([?e, ?a, _])
-> { e: 11, a: "user_name" }, { e: 22, a: "user_name" }, { e: 33, a: "user_name" }

query([?e, "user_name", "xie"])
-> { e: 11 }

query([?e, "user_name", ?v])
-> { e: 11, v: "xie" }, { e: 22, v: "yu" }, { e: 33, v: "heng" }

find([?name])
  .where([11, "user_name", ?name])
-> { name: "xie" }

find([?name])
  .where([_, "user_name", ?name])
-> { name: "xie" }, { name: "yu" }, { name: "heng" }

find([?id, ?name])
  .where([?id, "user_name", ?name])
-> { id: 11, name: "xie" }, { id: 22, name: "yu" }, { id: 33, name: "heng" }

*** add email address to users

{ "user_name": "xie",  "user_email": "x@c.com" }
{ "user_name": "yu",   "user_email": "y@c.com" }
{ "user_name": "heng", "user_email": "h@c.com" }

database:

[11, "user_name", "xie"]
[22, "user_name", "yu"]
[33, "user_name", "heng"]
[11, "user_email", "x@c.com"]
[22, "user_email", "y@c.com"]
[33, "user_email", "h@c.com"]

*** run some queries

find([?email])
  .where(
    [?id, "user_name", "xie"],
    [?id, "user_email", ?email])
-> { email: "x@c.com" }

*** introduce more concepts: repo, org, owner

{ "org_name": "cicada-lang" }
{ "repo_slug": "cicada-lang/cicada", "repo_owner": 44 }
{ "repo_slug": "cicada-lang/cicadascript", "repo_owner": 22 }

{ "repo_slug": "cicada-lang/cicada", "repo_owner": ["org_name", "cicada-lang"] }
{ "repo_slug": "cicada-lang/cicadascript", "repo_owner": ["user_name", "yu"] }

     ["org_name", "cicada-lang"] returns the unique ?id in
[?id, "org_name", "cicada-lang"]

     ["user_name", "yu"] returns the ?id in
[?id, "user_name", "yu"]

[11, "user_name", "xie"]
[22, "user_name", "yu"]
[33, "user_name", "heng"]
[11, "user_email", "x@c.com"]
[22, "user_email", "y@c.com"]
[33, "user_email", "h@c.com"]
[44, "org_name", "cicada-lang"]
[55, "repo_slug", "cicada-lang/cicada"]
[55, "repo_owner", 44]
[66, "repo_slug", "cicada-lang/cicadascript"]
[66, "repo_owner", 22]

find([?repo])
  .where(
    [?p, "user_name", "yu"],
    [?r, "repo_owner", ?p],
    [?r, "repo_slug", ?repo])
-> { repo: "cicada-lang/cicadascript" }

find([?name, ?repo])
  .where(
    or([?p, "org_name", ?name],
       [?p, "user_name", ?name]),
    [?r, "repo_owner", ?p],
    [?r, "repo_slug", ?repo])
-> { name: "cicada-lang", repo: "cicada-lang/cicada" }, { name: "yu", repo: "cicada-lang/cicadascript" }

repo_owner(?p, ?name)
  [?p, "org_name", ?name]
  [?p, "user_name", ?name]

find([?name, ?repo])
  .where(
    repo_owner(?p, ?name),
    [?r, "repo_owner", ?p],
    [?r, "repo_slug", ?repo])
-> { name: "cicada-lang", repo: "cicada-lang/cicada" }, { name: "yu", repo: "cicada-lang/cicadascript" }

*** introduce more concepts: fork

{ "repo_slug": "xie/cicadascript",
  "repo_owner": ["user_name", "xie"],
  "repo_fork": ["repo_slug", "cicada-lang/cicadascript"] }

[11, "user_name", "xie"]
[22, "user_name", "yu"]
[33, "user_name", "heng"]
[11, "user_email", "x@c.com"]
[22, "user_email", "y@c.com"]
[33, "user_email", "h@c.com"]
[44, "org_name", "cicada-lang"]
[55, "repo_slug", "cicada-lang/cicada"]
[55, "repo_owner", 44]
[66, "repo_slug", "cicada-lang/cicadascript"]
[66, "repo_owner", 22]
[77, "repo_slug", "xie/cicadascript"]
[77, "repo_owner", 11]
[77, "repo_fork", 66]

find all the repos that are forks:

find([?repo])
  .where(
    [?r, "repo_slug", ?repo],
    [?r, "repo_fork", _])
-> { repo: "xie/cicadascript" }

find all the repos that are not forks:

find([?repo])
  .where(
    [?r, "repo_slug", ?repo],
    missing(?r, "repo_fork"))
-> { repo: "cicada-lang/cicadascript" }, { repo: "cicada-lang/cicada" }
