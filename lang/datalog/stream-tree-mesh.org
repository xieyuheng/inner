#+title: stream, tree, mesh

* info

- DOMAIN MODELING WITH DATALOG by Norbert Wojtowicz
  https://www.youtube.com/watch?v=oo-7mN9WXTw&ab_channel=%23pivorakLvivRubyMeetUp

* data -- stream, tree, mesh

- stream: order -- event, queue
- tree: hierarchy -- object composition, ui components
- mesh: relation & graph

** example: spotify

basic nodes:
- artist
- listener
- song

everything else are relations:
- album: artist, song
- playlist: user, song
- subscribe to playlist: user, playlist

* datalog -- entity, attribute, value

- xie: note that,
  - formal concept analysis only have: object (entity) and attribute
  - we can also add time to get: time, entity, attribute, value

** example: github

*** create some users

create("user_name", "xie")
create("user_name", "yu")
create("user_name", "heng")

*** database

[11, "user_name", "xie"]
[22, "user_name", "yu"]
[33, "user_name", "heng"]

*** run some queries

query([11, _, _])
-> success -- because there is an entity 11

query([_, "user_name", "xie"])
-> success -- because there is an user called "xie"

query([33, "user_name", "xie"])
-> fail -- because entity 33's user name is not "xie"

*** queries that not only success or fail but also return matched result set

query([?e, _, _])
-> { e: 11 }, { e: 22 }, { e: 33 }

query([?e, ?a, _])
-> { e: 11, a: "user_name" }, { e: 22, a: "user_name" }, { e: 33, a: "user_name" }

query([?e, "user_name", "xie"])
-> { e: 11 }

query([?e, "user_name", ?v])
-> { e: 11, v: "xie" }, { e: 22, v: "yu" }, { e: 33, v: "heng" }

find([?name])
  .where([11, "user_name", ?name])
-> { name: "xie" }

find([?name])
  .where([_, "user_name", ?name])
-> { name: "xie" }, { name: "yu" }, { name: "heng" }

find([?id, ?name])
  .where([?id, "user_name", ?name])
-> { id: 11, name: "xie" }, { id: 22, name: "yu" }, { id: 33, name: "heng" }
