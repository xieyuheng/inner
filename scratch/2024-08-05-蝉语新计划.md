---
title: 蝉语新计划
date: 2024-08-05
---

# 目标

一个带有 dependent type 的实用语言。

- 默认没有完备性检查，也没有停机检查。
- 使用 explicit substitution 实现。
- 用 `T::C` 作为构造数据的语法。
- 编译到 xvm。

# 语法

坚持设计类 JS 语法的语言：

- 更贴近数学语言 f(x)。
- 有自然的语法来表达 record，这对描述抽象数学结构而言尤为重要。

用 `{ <exp> <exp> ... }` 作为 block 表达式。

- 最后一个不用 `return`。
- 不支持空的 block，`{}` 代表解空 record。

用 JSON 的语法作为 record。

- `{}` 代表空 record。
- 不支持 `{ key, ... }` 这种缩写，因为和 block 表达式相互冲突，有歧义。

用手写的 recursive decent parser 来解析语法，
不用 parser generator，方便 port 到别的语言。

# 蝉语

不管是从知识积累方面，还是从设计方向方面，
cicada 项目都已经准备好了，就差努力实现了。

在 clique 中实验，然后开始 cicada。

- 在 clique 中用 `assert-equal` 验证基于 `Exp` 的 definitional 等价关系。
- 在 clique 中验证基于 `Exp` 的递归函数之间的 definitional 等价关系。
- 在 clique 中验证基于 `Exp` 的 dependent type 类型检查器具。
- 在实现 explicit-substitution 时避免全局的 `globalFreshen`。

cicada 仍旧临时用 JS 实现，坚持 类-JS 语法。

- 几乎不设计语法，完全模仿 JS 的语法。
- {} 为 object 优化。
- 放弃用 {} 把 block 变为 exp 的想法
- function, case, arrow function 可以跟 {}
  - case, arrow function
    当需要返回单个 object 的 exp 时，
    也模仿 JS 的语法。

我经常纠结 record 的所写语法 `{a, b, c}` 和 block 的语法之间的歧义，
不如，直接就放弃缩写语法，然后用 `{1, 2, 3}` 来表示集合。

可以用高阶函数来做依赖注入，但是有多个参数的时候，
顺序很难记住，想要用 record，
但是 record 没法用 currying，
所以 currying 应该支持 record。

- 如何设计这这个功能的语法？
  - （A）直接用一个名叫 `curryRecord` 或者 `partialApplyRecord` 的函数。
     - 或 `curry` `prepare` `preset`
  - （B）设计特殊的语法。

XVM 作为容易实现的可扩展的编译器 target。

cicada 编译到 XVM。

# xvm

[xvm] 可扩展的 VM。

- 最重要的目的是为 cicada 提供 compiler target。
  注意，这个生态位是没有标准语言的，每个动态类型语言都有自己的 VM。

- 功能：

  - 用 tagged values 并支持 GC。
  - 尾递归优化。
  - closure。
  - 用 C 写，用 C 扩展。

- XVM 本身也可以是一个实用的脚本语言，这需要：
- 简单类型系统。
  - 难点是需要用 C 实现。
- 模块系统。
- array 和 record。
- 定义 datatype。

- 放弃在这个项目中对 two level monoid-like type system 的探索。

  - 我们有类型系统，只是没有 linear type，
    之所以放弃 linear type
    是因为我发现实现类型系统需要 closure 和 GC，
    而 linear type 很大一部分意义在于可以没有 GC。

  - 如果让 GC 可选，也许还可以在这里探索 linear type，
    但是不应该一次探索太多。

要保持容易实现。

- 如何保持容易实现？需要 XVM？
- 想要保持容易实现，就必须用 stack-based 构架，这样就必须要求 XVM。
  - 因为只有在 stack-based + postfix 语法中，尾部递归等等概念才能简单。
  - 因此我们实现的不能是一个解释器，而必须是一个到 XVM 的编译器。
  - 为了学习 runtime 数据编码，还是要看 UI 的编译器课程。
