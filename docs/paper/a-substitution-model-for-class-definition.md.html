<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>paper/a-substitution-model-for-class-definition.md</title>
</head>
<body>
<pre style="white-space: pre-wrap;"># A Substitution Model for Class Definition

------
- Author: Xie Yuheng
- Date: 2019-05-07
- Keywords: Cell-complex, Data structure.
------

- This document serves as an appendix of the paper [&quot;A Recursive Combinatorial Description of cell-complex&quot;](/paper/a-recursive-combinatorial-description-of-cell-complex).

My overall class definitions are:

``` typescript
class id_t {
  dim: number
  ser: number
}

class cell_complex_t {
  cell_dic: dic_t &lt;id_t, cell_t&gt;
}

class cell_t {
  dom: spherical_t
  cod: cell_complex_t
  dic: dic_t &lt;id_t, { id: id_t, cell: cell_t }&gt;
}

class spherical_t extends cell_complex_t {
  spherical_evidence: spherical_evidence_t
}

class spherical_evidence_t {
  /**
   * [detail definition omitted]
   */
}
```

In the definition of `spherical_t`:

``` typescript
class spherical_t extends cell_complex_t {
  spherical_evidence: spherical_evidence_t
}
```

Substitute `extends cell_complex_t` by the definition of `cell_complex_t`,
we get:
- i.e. `spherical_t extends cell_complex_t` means merge the definition of `cell_complex_t` into the definition of `spherical_t`.

``` typescript
class spherical_t {
  spherical_evidence: spherical_evidence_t
  cell_dic: dic_t &lt;id_t, cell_t&gt;
}
```

And substitute the above definition of `spherical_t` and `cell_complex_t` into the definition of `cell_t`,
we get:

``` typescript
class cell_t {
  dom: {
    spherical_evidence: spherical_evidence_t
    cell_dic: dic_t &lt;id_t, cell_t&gt;
  }
  cod: {
    cell_dic: dic_t &lt;id_t, cell_t&gt;
  }
  dic: dic_t &lt;id_t, { id: id_t, cell: cell_t }&gt;
}
```

And substitute the definition of `spherical_evidence_t` into the above definition of `cell_t`,
we get:

``` typescript
class cell_t {
  dom: {
    spherical_evidence: {
      /**
       * [detail definition omitted]
       */
    }
    cell_dic: dic_t &lt;id_t, cell_t&gt;
  }
  cod: {
    cell_dic: dic_t &lt;id_t, cell_t&gt;
  }
  dic: dic_t &lt;id_t, { id: id_t, cell: cell_t }&gt;
}
```

If I do not omit the `[detail definition]` in above structure,
I will get something like:

``` typescript
class cell_t {
  dom: {
    spherical_evidence: {
      &quot;isomorphism&quot;: &quot;isomorphism between two cell-complexes A and B&quot;
      &quot;subdivision of dom&quot;: &quot;A is a subdivision of this dom&quot;
      &quot;subdivision of standard n-sphere&quot;: &quot;B is a subdivision of a standard n-sphere&quot;
    }
    cell_dic: dic_t &lt;id_t, cell_t&gt;
  }
  cod: {
    cell_dic: dic_t &lt;id_t, cell_t&gt;
  }
  dic: dic_t &lt;id_t, { id: id_t, cell: cell_t }&gt;
}
```

This means,
to construct a `cell`,
one have to **provide the evidence** that the `dom` of the `cell` is spherical.

i.e. I pushed the responsibility of making sure the `dom` is spherical to people who use my method.

It is required that the `dom` must be a spherical cell-complex,
but &quot;check&quot; can means &quot;write a program to decide whether a cell-complex is spherical&quot;.
- It is possible to write this program for dimension 0, 1, 2, 3,
- but not possible for dimension &gt;= 5.

My construction of cell-complex, does not require such program exist,
because one have to provide the `spherical_evidence` by hand (i.e. not generated by a computer program).

And this does not make the construction invalid.
</pre>
</body>
</html>
