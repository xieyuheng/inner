---
title: 线性逻辑的资源语义
author: 谢宇恒
date: 2025-01-15
---

# 资源语义

所谓资源语义，可以想象一个没有垃圾回收器的语言，
对于其中所有 value，都需要手动分配内存和手动回收内存。

为了解释一个逻辑的语义，需要解释的东西有：

- 逻辑判断（logic judgment）
- 逻辑连词（logic connective）
- 推演规则（inference rule）

# 解释逻辑判断

首先解释逻辑判断。
我们的逻辑中只有一种判断。

```
A, B |- C, D
```

这种形式的判断被称作 sequent。

可以解释为一个反应。
这个反应消耗一个 A 类资源和一个 B 类资源，
要等待这两个资源要同时到齐反应才能开始；
产生一个 C 类资源和 D 类资源，
可能会先产生其中的一个资源，
经过一段时间再产生另一个。
想象一个工厂的生产过程，此时「反应」就是加工过程，
为了提高生产效率，先产生的资源可以先拿给后续的工序使用。

设想带有类型系统的反应网（interaction nets）。
这个逻辑判断可以被理解为某个原始节点（primitive node）的类型。

```
[a: A] [b: B]
   \    /
   (node)
   /    \
[c: C] [d: D]
```

这个节点有两个主端口（principle port），分别是 a 和 b，
只有当这两个端口的数据都到齐了反应才能开始，
所谓「数据到齐」，其信号就是这两个端口所连接的，
都是别的节点的主端口了。
根据反应网的反应规律，
反应开始时主端口的连接线（wire）都会被拆除了，
当前反应的节点本身也会被删除，
两个非主端口的连接线会暴露出来，
也就是这里的 c 和 d。
反应的过程就是生成新的节点，
并且把这两个暴露出来的连接线重新连上。
就像工厂的生产过程一样，
显然重新连上 c 和 d 的时间可能是不同的，
先连上的就可以被后续的反应先用到。

# 解释逻辑连词

线性逻辑的连词表：TODO

| symbol | polarity | level |      | name (Girard) | identifier |
|--------|----------|-------|------|---------------|------------|
| A ⊗ B  | pos      | mul   | conj | times         | Both       |
| A & B  | neg      | add   | conj | with          | Choose     |
| A ⊕ B  | pos      | add   | disj | plus          | Maybe      |
| A ⅋ B  | neg      | mul   | disj | par           | Through    |
| !A     | pos      | exp   |      | of course     | OfCourse   |
| ?A     | neg      | exp   |      | why not       | WhyNot     |

| symbol | meaning                                |
|--------|----------------------------------------|
| A ⊗ B  | I have both A and B.                   |
| A & B  | I have a choice between A and B.       |
| A ⊕ B  | Someone else's choice between A and B. |
| A ⅋ B  | If not A, then B.                      |
| !A     | I can reuse A.                         |
| ?A     |                                        |

| connective | meaning           |
|------------|-------------------|
| ⊗          | have(A and B)     |
| &          | can(A) and can(B) |
| ⊕          | have(A or B)      |
| ⅋          | can(A) or can(B)  |

Notes:

- Maybe we should use `Always` instead of `OfCourse`.

- If we view linear logic as type of channel,

  - The additive conj `&` means
    we can choice to `send` different messages to the channel,

  - The additive disj `⊕` means
    we might `receive` different messages from the channel.

  Note that, sending message is the dual of receiving message, and
  conditional is done by receiving messages and pattern matching, thus
  pattern matching is the dual of method call (messages passing) in
  object oriented programming.

  - Recall Sandi Metz' anti-conditional programming.

- TODO How about type of actor?

  - Maybe it is similarly linear logic,
    because actor and channel + process can simulate each other.

  - Maybe it is not linear logic,
    because given a actor, we can only send messages to it,
    but we can not receive messages from it.

| symbol   | derive               | name (Girard) | identifier |
|----------|----------------------|---------------|------------|
| `A -o B` | `Through(Not(A), B)` | entails       | `Entails`  |

| symbol   | meaning                                         |
|----------|-------------------------------------------------|
| `A -o B` | I can construct `B`, by using `A` exactly once. |

Linear negation is involutive but constructive.

# Examples

Suppose for $5 a restaurant will provide a hamburger, a Coke,
as many french fries as you like, onion soup or salad (your choice),
and pie or ice cream (some else's choice, depending on availability).

```
dollar(5) -o Both(
  hamburger,
  coke,
  OfCourse(french_fries),
  Choose(onion_soup, salad),
  Maybe(pie, ice_cream),
)
```

# Sequent calculus rules

We study rules for propositional linear logic first.

The sequent `A, B |- C, D` means,

```
Entails(Both(A, B), Through(C, D))
```

i.e. multiplicative.

A sequent calculus infere rule consists of a set of hypothesis sequents,
displayed above a horizontal line,
and a single conclusion sequent,
displayed below the line, as below:

```
Hypothesis1
Hypothesis2
------------
Conclusion
```

# Connections to other logics

Linear logic arose partly out of a study of intuitionistic implication.
Girard found that the intuitionistic implication `A -> B`
could be decomposed into two separate connectives:

```
!A -o B
```

Girard showed that one could thus translate intuitionistic (and also classical) logic
into linear logic directly, simply appending modals to certain subformulas
and making the right choice as to which sort of conjunction and disjunction should be used.

Here we see a first glimpse of the substance behind the slogan

> Linear logic is a logic behind logics.

# 参考资料

- [A Practical Interpretation of Linear Logic](https://protovision.github.io/#!/documents/blog/linear-logic.html)
  by Mark Swoope, 2022.
