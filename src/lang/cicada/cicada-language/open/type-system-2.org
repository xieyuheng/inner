* function-body 的功能

  - 函數體內嵌套數據時
    用做轉跳的 instruction
    來實現在函數體內分配內存
    注意
    這種特殊的 instruction
    也需要被 type-apply 特殊處理

  - function-body as sequent-vector

  - 在 explain-function 裏處理 pattern-match
    做爲內部解釋器的 explain-function
    所解釋的數據更爲豐富了
    不是直接入函數體到棧裏來
    而是根據參數棧中的情況來挑選入棧的函數體
    也就是說 增加了一個挑選過程
    也就是說 分支語句被整合到內部解釋器裏面了
    注意
    在挑選過程中 explain-function 會入棧前項
    所謂 入棧前項
    其實是 把 前項 做爲匿名函數體來執行
    注意
    入棧前項 之後的匹配過程是 自治的
    所謂 自治
    就是 不是一個解釋器統一處理 解釋器只做分派工作
    就是 增加一層間接

  - 這還只描述了 function-body 的功能
    還需要設計其結構來實現這些功能

* function-body 的結構

  - 就像 古典 forth 中的字符串一樣
    使用
    |--------|
    | length |
    |--------|
    | jo     |
    | ...    |
    |--------|
    來實現 sequent 的前項或者後項
    其中 length 的單位是 byte
    而 一個 sequent 就是兩個這種東西
    注意
    生成這種樣子的數據的時候
    就是先預留一個位置 然後收集 jo
    收集結束後做一些收尾工作
    收尾工作中包含 把 length 填到前面預留的位置中

* 關於 tag 的使用

  - 注意
    tag-group 中的 tag 是不重複 且無順序的

  - 用 ':' 來做 in-line tag-group

  - 所搜索的 tag-group 前綴只能是 探測到的 或提供給的
    maybe 是一個類型
    maybe:apply 用一般的 apply 實現
    那麼
    在 maybe:apply 的函數體裏 apply 就有歧義了
    tag-group 前綴 從多到少 和 從少到多 不同

  - 解法之一是
    不要使用全局的 apply
    而用 function:apply
    這樣 就能不顧順序而區分開兩個 apply 了

  - 另外一個問題是
    in-line tag-group 的語義
    應該是添加到搜索前綴中
    而不是全局的
    全局的 就是搜索前綴爲空的情況

  - 注意
    搜索前綴的集合是無序的
    減少元素的過程中需要遍歷其冪集
    此時在 tag-group 的某個 tree 表示中
    每個節點都可能包含數據 和 子節點
    某個節點函數的函數體 所能看到的節點就是所謂祖先節點
    在加上所有祖先節點的一級子節點
    name1:name2 就能延伸到二級子節點
    只不過 名字是確定的
    注意
    搜索的時候 是不能依賴順序的

  - 但是上面的處理方式是不對的
    因爲
    由於沒有順序
    此時找到一個 名字的時候 不知道是從那個前綴裏找到的
    解法就是
    雖然 tag-group 本身是沒有順序的
    但是 聲明搜索 tag-group 的時候
    要求所做的聲明是按照順序遞減的
    也就是每次都去掉後頭的 name
    這樣是合理的
    因爲這樣就給了編碼者更多明顯聲明的能力
    而避免了機器對冪集的遍歷
    [不要讓機器假裝自己很聰明]

* 觀察 tag-group

  - tag-group 做爲名字
    使得 名字之間形成簡單的偏序關係
    並且
    每個 tag-group 中所保存的類型和函數體
    又使得 空間中的 各個 之間得以關聯
    正是這些關聯 用幾何結構編碼了你的算法
