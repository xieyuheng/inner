* 回顾

  - 實現決策已變

* 題解

  - 術語表格
    | 動態類型 | 類型編碼於值                     |
    | 靜態類型 | 類型不編碼於值                   |
    | 類型檢查 | 定義函數時 檢查函數              |
    |          | 看 所聲明 與 所算得 類型是否匹配 |
    | 類型推導 | 避免 直接寫 函數類型聲明         |
    |          | 讓機器根據函數所作用於的值來推導 |

  - 決策
    1. 靜態類型
    2. 類型檢查

  - 評論
    在運行時 類型信息不被編碼在值中
    而是被記錄在 函數中
    做爲函數的元數據

* 靜態類型中類型的編碼
  - 類型有編碼
    只是編碼不保存在這個類型的數據當中
    而保存函數當中
    類型編碼只能用 name 和 數組 進行
    而不應該用字符串

* 問題
  - 聲明類型的語法如何
  - 與 代碼生成機制 之綜合

* 討論 <2015-06-17>
  - x ::
       我們發現 類型檢查機制 必須與 代碼生成機制 綜合起來討論
  - k ::
       那麼我們就先考慮二者之間相互影響的部分
  - x ::
       在此之前
       我本想去實現函數來問詢文件大小
       誰知道 它卻引我 實現 代碼生成機制 機制
       進而 來到最刺激的 類型檢查機制
       我以爲 去實現函數來問詢文件大小 只是實現 類型檢查機制 之前的消遣而已
  - k ::
       此謂計劃之必失
  - x ::
       類型檢查機制 是我認爲最有趣的機制之一
       首先說其特點
    1. 可選擇開啓與否
    2. 需要更改很多代碼工作量很大
    3. 關乎代碼優化 即 編譯時期提前作用
       之前看來
       其難度在於類型編碼
       現在有了 name-hash-table
       這已經有望解決了
  - k ::
       我們可以回顧一下之前關於類型的筆記
  - x ::
       但是那有是浪費鋒芒
       不是嘛
  - k ::
       也許吧
  - x ::
       我們嘗試鋒芒畢露一下
       快速羅列一些要點
    1. 可計算性 可計算的不限於傳統的類型 也可以包含副作用
    2. <type> 可以做爲一個 variable-jo 存在
    3. 不必處理局部變元
    4. 全局變元也需要有類型聲明
    5. 孤獨者用 name 編碼
       因複合而嵌套者通過就地嵌套 name 的向量編碼
    6. 所謂 因複合而嵌套者 有以下各種
       1. 同類型的數據所組成的向量
       2. 不同類型的數據所組成的向量 [匿名結構]
       3. 高階函數
       對於嵌套的類型編碼 高階函數語法上用掉 {}
       向量重載 []
    7. 需要處理 scope 就像局部變元的 scope-stack 一樣
       也許應該共用一個 scope-stack
    8. 多類型函數返回值的函數也被處理
       比如以 find 爲後綴的函數
       只要一種類型能行即可
       但是這可能嘛
       對於 find 而言是可能的
       因爲多出來的 類型可以被 if 消去
    9. 類型變元
  - k ::
       我想我們可以嘗試把想像具體化了
       並且舉幾個具體的例子
  - x ::
       首先是類型編碼
       根據複合與否有兩類
    1. 素類型
       其編碼用 形如 <type> 的 name
       {<number> -- <number>}
    2. 複合類型
       其編碼用 用 素類型 的數組
       目前我能想到三種類型
       1. 同類數組
          {[<number>*] -- }
       2. 異類數組
          { -- [<number> <gamber> <string>]}
       3. 函數
          {{<number> -- <number>} -- {<number> -- <number>}}
       比如
       {<number> -- <number>}
       做爲數組是
       | {        |
       | length   |
       | <number> |
       | --       |
       | <number> |
       | length   |
       | }        |
       這樣就能夠前後遍歷了
       類型變元就是 不帶 <> 的 name
       比如 {a a -- a}
       這樣 類型就是 一等公民了
       並且使用新的類型的時候也不需要定義
  - k ::
       其次是對類型的計算
  - x ::
       沒錯
       我可以嘗試窮舉所需要處理的情況
    1. 函數複合
       [平凡的]
    2. 全局變元
       [平凡的]
    3. 函數作用
       [古典的]
    4. 類型變元
    5. 分支
  - k ::
       (4) (5) 比較困難
  - x ::
       的確
       我們來讓問題變得更具體
       所謂計算有輸入值和輸出值
       用於計算類型函數本身也可以被加上類型標籤
       {<string> <type> -- <bool>}
       也許返回值不應該如此單薄
       畢竟我們要做詳細的報錯
  - k ::
       先看難點 (4)
  - x ::
       這並不難處理
       假設我給 類型變元 以額外的語法
       比如 +type-variable+
       那麼這種東西就可以出現在類型中的任何地方
    1. 同類數組
       {[+aaa+*] -- }
    2. 異類數組
       { -- [<number> <gamber> <string> +aaa+]}
    3. 函數
       {{<number> -- +aaa+} -- {<number> -- <number>}}
       變元在於賦值
       只要知道賦值如何發生即可
       比如棧中有
       {<number>}
       有類型爲 {+aaa+ -- <string>} 的函數作用於棧
       那麼 +aaa+ 就會被賦值爲 <number>
       又比如
       棧中有 {+aaa+}
       有類型爲 {<number> -- <string>} 的函數作用於棧
       就會失敗
       因爲 +aaa+ 不一定爲 <number>
       不過看來我需要形成更好的數學模型
       來討論類型系統的一般性質
       上面這些舉例並不能保證其設計良好
  - k ::
       還有 (5) 呢
  - x ::
       這又引發了額外的問題
       比如
       {<string>
        -- <string> true
        -- false}
       有 <bool> literal 在棧中
       這就要求類型中能夠出現 literal
       此時
       產生分歧 後面一定要有 if
       if 會處理分歧
       如果假設 if 是唯一的產生分支的語法
       那麼處理完這種情況之後
       就完備了
       但是
       如果今後增添處理 if 的關鍵詞
       那麼就必須擴展類型計算以處理新的語法關鍵詞
       也就是說
       每增添一個語法關鍵詞
       如果想要它在 REPL 中能用就要爲解釋器重新實現一遍
       如果想要它在 類型檢查 中能用就要在類型檢查器中重新實現一遍
       沒有別的辦法了
  - k ::
       這裏 literal 應該如何處理
       語法如何設計
       編碼如何
  - x ::
       比如 我將一般的 沒有 <title> 前綴的 詞做爲 literal
       這樣就能處理 數字 還有 bool
       這種素 literal
       複合數據的 literal 還不行
       尤其是考錄到 內存就地分配的問題
       我明白了
       我們必須先設計完備的 向量處理機制
       然後把 type 用向量來實現
       這裏要求的性狀是
       每個向量中都能夠就地保存各種類型的 素數據 或 複合數據
  - k ::
       如果這樣 處動態類型標籤一定要被保存在 向量中了
       這樣不就成了動態類型語言
  - x ::
       我們來仔細考察一下向量這個東西
       首先
       我假設
       所有向量處理函數 如果改變了向量的長度
       那麼就一定要 生成新的向量 而不是在原有的向量上做副作用
       其次
       向量之在 棧中的存在如同 <string>
       而向量在內存中的存在必須包含其長度
       也就是說
       向量這個數據結構必須要有豐富的元數據
       因爲它將是 cicada-nymph 的主要數據結構
       所有的東西都依賴與它
       最主要的元數據是向量的長度
       這個長度需要被包含到向量的開頭和結尾
       以實現兩個方向的遍歷
       用來遍歷向量的函數 就如目前用來處理 <string> 的類似
       通過不同的接口函數可以以不同的語義來理解向量
    1. 最簡單的語義是 cell
    2. 類型系統所需要的語義是 element [暫且命名如此]
  - k ::
       然而
       如果可以嵌套
       那麼獲取 element 的函數所能取得的值就可以能是 <name> 和 <vector>
       也就是說 <vector> 這個數據類型 不是同質的
       不光能夠有 vector of <number>
       即 [<number> *]
       還能有 vector of <number> or <vector>
       即 [<number>|<vector>]
       這樣
       之前所說的 異質向量類型
       [<number> <gamber> <string>]
       其實是不存在的
  - x ::
       首先在設計決策上
       我放棄所謂類型的絕對安全
       這樣上面的異質向量就是可以容忍的
       但是
       是否可能
       因爲這算是又出現了一種類型分歧
       我可以通過定義新的類型來包含 <number> 和 <vector>
       以使得 上面的向量 變爲同質的
       而直接的 [<number>|<vector>] 相當於是匿名的類型
       其實
       所有複合類型的出現都可以看成是匿名類型
       但是
       如果說上面的 <number> 和 <vector> 可以被定義爲一個新的類型的話
       這無疑是說 類型不是簡單的 name 了
       類型之間是有關係的
  - k ::
       沒錯
       其他語言的類型系統也是如此
       這樣使用類型之前就必須要明顯定義了
  - x ::
       如果大量使用匿名類型的話
       可否避免這種情況
  - k ::
       不可以
       這又回到了
       名與匿名之間的平衡
       命名是一種抽象方法
       複雜的匿名類型不能總以全稱出現
       必須有方法以命名它
  - x ::
       不過
       上面的把異質的向量變成同質
       看似是絕對需要定義新複合類型的地方
       比如 定義 <vexp> 爲 <name> | <vector>
       那麼處理 <vexp> 的函數又該如何
       是使用 <vector> 爲前綴者
       還是使用 新的 <vexp> 爲前綴者
       還有
       [<number>]
       其實是 vector of <number>
       也就說是一種類型構造子
       這種類型構造子的使用能否一般化
       比如 {<number> -- <gamber>}
       其實是 function of <number> -- <gamber>
       也是一種類型構造子
  - k ::
       這樣就有兩個層次的可以自由定義的東西了
       一個是 類型構造子
       一個是 類型本身
  - x ::
       我現在想類型系統對與 cicada-nymph 來說
       是否可能
  - k ::
       注意
       我們不需要完全的類型安全
  - x ::
       但是這是什麼意思
       那些地方是可以不安全的
  ----------------------------------
  - x ::
       我回顧了一下之前的筆記
    1. 類型構造子這個概念必須被引入
       每個類型構造子對應於
       一組類型解構子
    2. 類型推導
       所有函數必須都有類型前綴
       這些類型前綴在推導器的幫助下
       可以被完全省略
       類型信息之使用
       是爲了進行推導
       以回覆類型前綴
       從而找到需要被編譯到函數體中的函數
    3. 類型檢查
       不要求名每個函數都有類型前綴
       類型信息之使用
       函數體中必須使用函數的全名
       在於檢查所聲明者
       是否與所計算者相互匹配
  - k ::
       如上二者對類型信息的使用方式不同
       但是對類型的計算方式可能完全相同
  - x ::
       沒錯
       現在需要知道的問題是
    1. 類型構造子 如何用向量實現
       類型結解構子是什麼
    2. 定義新的類型意謂着什麼
    3. 如何處理 異質 向量
       必須要命名碼
       是否能用類型構造子匿名
       既然 [<number>] 代表匿名的類型
       那麼
       類型構造子其實就是一種匿名機制
       既然匿名 其內信息就必須完整出現
  - k ::
       需要兩個機制
       一個是匿名
       一個是命名
       匿名需要用到類型造子
       命名需要用到代入語義 即 區分 素與複合
       一個類型名字 <type> 可能是一個素類型
       也可能是一個複合類型的名字
       每個複合類型都是用各種類型構造子來構造的
       類型構造子可以用戶定義
       每個類型構造子都對已一些類型解構子
       我來簡化下問題
       這在於去除語法糖
       要知道 如果考慮類型構造子的話
       那麼 {} 和 [] 其實都是特殊的語法糖
       所以爲了簡化問題
       必須設計 不帶語法糖的一般語法
  - x ::
       以 {} 類型構造子之邊綴
       之前的
       [<number>]
       對應於
       {vector: <number>}
       之前的
       {{<number> -- <number>} -- {<number> -- <number>}}
       對應於
       {function: {function: <number> -- <number>} -- {function: <number> -- <number>}}
       或者
       {function:
        {{function: {<number>} {<number>}}}
        {{function: {<number>} {<number>}}}}
       它們都是特殊的嵌套的向量
       其實所謂嵌套
       就是把向量的長度包含進去 然後將向量的接口做特殊處理 以利用這些長度信息
  - k ::
       這種語法看來並不令人滿意
  - x ::
       我明白了
       所謂構造子與解構子
       其構造子可以直接被實現爲嵌套的 name 的 vector
       而解構子是對這種類型的數據的模式匹配
       上面的語法並不令人滿意
       其實
       {{<number> -- <number>} -- {<number> -- <number>}}
       應該保持其簡潔
       這種模式的 name vector 所代表的是棧中元素類型的變化
       這是最主要的模式
       其他的模式以 [] 爲邊 比如 [aaa:]
       默認者 [] 可以做爲一種省略情形
       (apply) 的類型是
       {+a1+ ... +an+ {+a1+ ... +an+ -- +b1+ ... +bn+} -- +b1+ ... +bn+}
       我明白了
       每個函數的類型聲明其實也是一個函數
       只不過是在編譯時期作用
       因 這類函數很特殊
       而 用特殊的語法寫成
  - k ::
       可以將這個概念一般化嘛
  - x ::
       還有對其他副作用的計算等等
       都可以用這種編譯時期的作用來理解
       還有優化也是
       還有代碼生成也是
  - k ::
       我認爲這是非常有趣的理解方式
       認識方式比處理手段更重要
       可以說現在我們已經獲得最重要的東西了
  - x ::
       沒錯
       我對整個系統的理解方式都改變了
       需要好好反思以調和新認識方式所帶來的衝突

* 討論 <2015-06-18>
  - x ::
       我的意思是
       函數中保存類型信息的方式
       可以不是一個有待一般解釋器解釋的語法
       而是一個被編譯好的代碼
       比如 {<number> -- <number>} 可以被編譯成
       [ << '<number> -- '<number> >>
         '<number> equal? if
           '<number>
           end
         then
         'error awake ]
       而不被處理爲一個有待解釋器解釋的 name 的 vector
       但是其實不應該這樣
       因爲被編譯好的代碼 易於執行 但是不易於閱讀
       也就是不適合做爲函數的類型元數據
       正確的做法是使用 name 的數組
       用專門的解釋器來解釋這個數組
       爲了更豐富的處理
       可以在計算時不使用 參數棧
       而另行開闢類型棧
       有待解釋的是 type-vector
       解釋的過程中
       會處理 type-stack 中的 type-record
       type-record 做爲數據結構 其域可以不只包含 name
       還可以有各種擴展
  - k ::
       如此已經確定
       下面就看對 type-vector 的解釋應該如何進行
  - x ::
       有兩個類似解釋器的東西
       注意
       每個 <type-vector> 代表在 type-stack 中
       以 <type-record> 爲單位的計算
       或者說 rewrite
       注意 rewrite 和 計算 是 同義詞
       比如 用 argument-stack 做計算
       即使就是對 argument-stack 的 rewrite
    1. (<type-vector> interpreter)
       * 用途
         匹配 type-stack 失敗時通過 awake 報錯
         成功時形成對 type-stack 的 rewrite
       * 參數
         <type-vector>
       * 副作用
         type-stack
    2. (type-checker)
       * 用途
         檢查所聲明的 <type-vector>
         是否與 用函數體所算得的 <type-vector> 相互匹配
       * 參數
         <type-vector>
         <string> 函數體
       * 注意
         檢查不匹配時 需要報錯
         報錯時要非常詳細並說明出錯位置
       * 實現方式
         就像 (basci-REPL) 在一個循環中調用 (word-interpreter)
         (type-checker) 在一個循環中調用 (<type-vector> interpreter)
  - k ::
       語法關鍵詞所導致的特殊情形 如何處理
       構造子 和 模式匹配 如何處理
       用已有的類型定義新的類型 即 類型之間的關係如何處理
  - x ::
       首先看最後一個問題
       類型之間的關係
       素函數複合而形成複合函數
       素類型形成更複雜的類型的方式就是構造子
       按照之前所言
       類型構造子之定義是相當任意的
       就像語法擴展一樣可以隨時添加隨時減少
       所有的複合類型都應該能夠被類型構造子來實現
  - k ::
       包含 literal 的類型 也應該被類型構造子實現
  - x ::
       假設其行
       構造子 和 模式匹配 用類似語法擴展的機制來實現
       而 特殊的語法關鍵詞就是語法擴展
       那麼就剩下類型之間的關係了
       這在於給用類型構造子所構造的類型命名
       命名素類型不必分說
       但是
       命名複合類型之後
       解釋器應該如何處理他們呢
       簡單的代入語義麼
  ----------------------------------
  - x ::
       我發現抽象模型還很薄弱
       必須充分考慮從抽象理論
       然後才能計劃實現
       之前我想
       類型限制函數的複合方式
       但是
       在實際的計算中
       對複合的限制其實是通過對函數作用的檢查而來的
  - k ::
       也許正如之前所說
       只有重新發明一個理論
       人才能夠良好理解一個理論
       如果不考慮所有複雜情形的話
       其實我們已經在重新發明簡單的類型論了
       之後就看如何發展這個簡單的理論
  - x ::
       所謂的簡單理論
       我可以總結如下
       [可以先不考慮 (type-checker)]
       利用 *type-stack* 中的 <type-record> 來做計算
       編碼計算的是 <type-vector>
       求職 <type-vector> 的是 (<type-vector> interpreter)
  - k ::
       也許類型之間沒有關係
  - x ::
       有兩種認識
    1. 類型之間的關係是
       去命名用類型構造子所構造的複合類型
    2. 類型之間的關係是爲了不重新 alias 接口函數
       使得同樣的接口函數可以作用於不同類型的數據
       也許我想要做 alias 以集成一些接口
       而不是使用原來的接口的名字
       並經類型前綴改變了
       我還發現
       所謂的 dependent type
       所說的是
       <type-vector> 中所能包含的不只是 形如 <type> 的 name
       還能包含類型變量 +aaa+
       還能包含值的變量
       還要能夠包含 literal
       同樣的函數接受的參數不同 返回的值的類型也不同
       就像
       {<string>
        -- <string> true
        -- false}
       中的 true 和 false 一樣
       這些 literal 是最複雜的情形
       依法上不容易設計
       語義上
       有兩方面
       首先 要豐富 <type-record> 的域
       其次 要使得數據結構能夠直接分配到向量中
       後者是在要求動態類型
       這可能是沒法接受的
  - k ::
       也許限制這種類型標籤只能出現在 <type-vector> 中就行
  - x ::
       是否要求 <type-vector> 中所保存的也不單單是單薄的 name
       而是 <type-record> 呢
       這樣 上面的兩種情形就劃歸爲一種了
       並且因爲數據結構變豐富
       更多的性狀也易行了
       我想正應該如此
       畢竟 <name> 要和 <type> 有區分
       <type-record> 可以直接被更名爲 <type>
       <type-vector> 其實也是 <type> 只不過是帶有構造子的
       如果使用遞歸定義記號的話
       <type> := <type-atom> | <type-vector>
       <type-atom>
       | name |
       | ...  |
       <type-vector>
       | length |
       | vector |
       | ...    |
  - k ::
       之前提到新的認識方式
       這裏我們可以回到 joy 的純粹函數語義中試試
  - x ::
       這樣 現有的系統本身 還是類型系統可以被理解爲 兩次計算
    1. 用 argument-stack 計算
       以 value 爲單位
    2. 用 type-stack 計算
       以 type 爲單位
       後者 遇到分支語句時 會遍歷每個分支
       前者 遇到分支語句時 只會進入一個分支
       兩種計算都是對 stack 的轉寫
  - k ::
       繼續回顧古典的知識
       我發現類型系統是個非常豐富的領域
       就像橋樑一樣它把各種其他理論鏈接起來
       古典的解釋是值屬於類型
       然而你這裏的類型似乎沒有值與類型之間的關係
  - x ::
       其實聲明一個函數的類型
       就是值與類型之間的關係
  - k ::
       是這樣
  - x ::
       這裏的特點是每個值屬於類型之聲明都形如 {<number> -- <gamber>}
       沒有 1 : <number> 這類聲明
  - k ::
       其實應該有
       不是嘛
       要知道 { -- } 只不過是特殊的類型構造子而已
  - x ::
       <type-vector> 和 <type-atom> 同時保存在 *type-stack* 中會有衝突
       正確的方式是把 *type-stack* 本身理解爲一個 <type-vector>
       只不過只有 -- 之前的部分
       其實
       沒有 1 : <number>
       但有 1 : { -- <number>}
       或者 既然 值本身能夠存在與 類型向量中的話
       那麼 1 : { -- 1}
       在語義上保存在 <type> 這個數據結構必須要足夠豐富
       以至於橫鉤保存 類似 1 這類的 佔用一個 cell 的原子數據
       還要能夠保存 佔用一片內存的複合數據
       並且在語法上 上面的 1 : { -- 1} 是不充分的
       即 語法所表達的信息是不充分的 不足以初始化 <type> 這個數據結構
  - k ::
       想好語法之後我們就能用我們的語法來表達古典的知識了
  - x ::
       沒錯
       那麼將是很好的學習機會
       一個 <type> 可以是四種東西
    1. 類型 <number>
    2. 類型變元 .type-variable
    3. 某個類型的值 (<number> 1) (<bool> true)
    4. 一般變元 (<bool> .b)
       這樣就有
       {<string>
        -- <string> (<bool> true)
        -- (<bool> false)}
       這樣
       dependent type 就是
       {(<number> .type-variable) -- (<number> .type-variable)}
       所謂依賴
       一定是 -- 前面的變元在後面重複出現
       重複出現方式中 最簡單的情形就是在 棧中重複
       而複雜的情形是被代入類型構造子中
  - k ::
       我想我們應該讀更多的古典東西
       在這個過程中檢驗並修正我們的語法和語義
  - x ::
       關於具體實現
       當計算類型時遇到了函數體中的一個常量 1
       我們應該得到類型 (<number> 1)
       而不是 <number>
       否則就浪費了信息
       有就是說
       信息的具體化程度是有層次的
  - k ::
       我發現
       之前的 <title>
       現在和類型名稱的語法重載在一起
       也許不是到的性狀
  - x ::
       只有發現這種性質極端不好時我才會分裂語法

* 討論 <2015-06-19>
  - x ::
       我發現理論方面
       做爲不同認識方式
       重不在聲明差異和強調優越
       而在於建立關係
       以揭示理解方式之間如何相互轉換
  - k ::
       其實在模仿嘲鳥的筆記裏
       你已經在構建相關的聯繫了
       不是嘛
  - x ::
       沒錯
       即 語法爲函數複合優化的組合子邏輯
       外加棧語義
       而之後
       我又有了局部變元語義
       現在我需要構建爲函數複合而優化的類型聲明語法
       之後理論之間的對飲關係就完備了
  - k ::
       所以古典的知識是相當必要的
  - x ::
       所以我們來回顧它們
       筆記要做圖所以我在紙質筆記本上記了

* 討論 <2015-06-21>
  - x ::
       我嘗試了理論基礎方面的探索
       但是完備而簡潔的理論遠非朝夕之功
       不妨先信其行
  - k ::
       在這個過程中你設計了新的語法不是嘛
  - x ::
       沒錯
       #+begin_src cicada-nymph
       {
       <類>
       +類+
       (<類> 值)
       (<類> :變)
       [構 (<類> 值)]
       {<類> -- <類>}
       --
       +類+
       [構 (<類> :變)]
       [構 +類+]
       }
       #+end_src
  - k ::
       新的語法並不足以讓你來觀察古典的結構嘛
  - x ::
       不足
       考慮範疇論 就知道新語法所代表的結構與古典差異很大
  - k ::
       那麼我們在回來考慮實現問題
       所謂 先信其行
       有兩個難點
       一是
       <address> <length> as <string>
       一是
       任意 <address>
  - x ::
       先考慮 {} 的實現問題
       這在於複雜化 type-stack 的接口
       使得其中的值本身可以是變長的
       每個變長 <type> 前後要有 <type-delimiter>
       有三種需要 <type-delimiter> 的地方
       構造子 []
       高階函數 {}
       其他結構化的值 (<類> 值)
       而 (<類> :變) 中也要保存位置

* 討論 <2015-09-05>
  - x ::
       思維散漫
       形式體系 證明論
       構造主義 構造主義的分析學
       攝影幾何 雙曲幾何 有理三角學
       我們好像已經忘記設計類型系統這個目標了
       漂泊忙亂
       我們現在需要重新調整作息時間
       適應新的環境 把經歷重新集中起來
  - k ::
       沒錯
       從 整理筆記 安排新計劃開始吧
  - x ::
       我還記得 bishop 的啓蒙
       我們應該 以計算語義爲主
       按照語義來設計形式系統和數學結構
       這樣才能使得理論實用
       新的計劃將以
       則式 的模式匹配 所形成的代數結構 爲主
       這個代數是範疇論的推廣
       這種推廣強調了可構造性和計算
       我將以此爲主線 重新整理筆記
  - k ::
       今天先休息吧
       讓新的探索在新的一天開始
  - x ::
       好的

* 放棄對編譯好的函數的動態改變
  - 動態改變 編譯好的函數的各種性質 和函數體本身
    這種性質是可以想像的
    但是在設計主要的函數語義時 我放棄這個性狀

* 討論 <2015-09-06>
  - x ::
       新一
       首先是閱讀和整理之前的筆記
       這次以語義爲中心
       因爲明確基本語義之後
       所形成的形式理論自然具有良好的構造性
       語義有二
    1. 類型檢查
       所謂檢查 就是你來聲明
       機器來檢查所聲明者 與依據函數體所計算出來者 是否匹配
       比如 定義函數時 聲明其類型爲 (A B -> C D)
       則 具體的類型檢查行爲如下
       - A B 入 類型棧
       - 作用函數體中各個函數的類型
       - 在此過程中
         若 類型棧中的當前類型
         使得函數體中的下一個類型無法作用 的情況
         [包含 棧中缺少值的情況]
         那麼 函數體本身的定義有問題
       - 若 函數體中所有類型已經作用完
         類型棧中的類型 可以被 C D 吃掉
         - 若 恰好吃掉
           那麼 這次的 類型聲明 的剛剛好
         - 若 其實可以吃掉更多
           那麼 這次的 類型聲明 還可以更緊張
       - 若 函數體中所有類型已經作用完
         C D 吃不掉 類型棧中的類型
         那麼 類型聲明與函數體不匹配
    2. 類型推導
       所謂推導 就是你在寫函數定義的時候省略函數類型信息
       機器儘量通過你明顯寫出的信息
       來推到你所省略的信息
       - 比如你省略了對 所定義的函數 的聲明
         那麼由函數體中所計算出來的類型
         就可以用以補全你所省略的信息
         把函數體中的類型複合起來很簡單
         [我保留這個性狀]
       - 比如你省略了對 函數體中某個位置的函數的類型 的聲明
         函數類型之複合爲一代數
         此時就要解方程了
         [我放棄這個性狀]
  - k ::
       觀察到 用來記錄類型信息的語法
       與 函數體的語法完全不同
       也許
       這裏也應該使用 單純的後綴表達式 來記錄嵌套的結構
  - x ::
       這裏 兩種處理語法的方式
       同時也代表了不同的類型系統的語義
    1. 其一爲編譯
       A B C 2 1 ->
       適合 類型檢查
       [除非 有對函數體的良好處理 否則很難 實現 類型推導]
       易擴展 [想要擴展只要定義新函數就行]
       難做爲數據處理 [類型 是 特殊的 函數體]
       再利用 語法擴展機制實現 (A B -> C)
       定義新的類型構造子 就是定義新的函數
       因爲 不同的模式匹配行爲
       可以在函數體內
       以任意方式自由定義
       [注意 intro 與 elimi rule 的 所謂 和諧性]
       [和諧性 被解釋爲 某種[結構化的]可逆性]
    2. 其二爲解釋
       (A B -> C)
       適合 類型推導
       易做爲數據處理 [類型 name 的數組]
       難擴展 [需要設計額外的擴展機制]
       對 類型棧 的操作
       是通過另外一個專門的解釋器完成的
       [這個解釋器與 後綴表達式 的解釋器很不同]
       不同的類型構造子做爲數據只是 name 而已
       但是被解釋器以不同方式解釋

* 討論 <2015-09-08>
  - k ::
       此處
       兩種實現方式 之間的選擇非常重要
       這可以說是蟬語設計以來
       所做的最重要的設計決策了
  - x ::
       比較兩種實現方式之後
       我選擇 爲類型檢查而優化的語義
       此時 處理起來有難度的是
       類型推導 之兩種語義中的第一個
       難點在於
       需要對函數體進行 恆等變形
       [這裏涉及到最重要的 函數體的等詞 的定義]
       [而 類型檢查 中根本不需要知道函數的名字]
       難點在於
       從函數體地址來查找 函數名字 的操作非常慢
       定義 函數體的等詞 時
       可否不用 函數名字
       而直接使用 函數地址
  - k ::
       先不考慮 類型推導
       只考慮 類型檢查
       我預計 在做好 類型檢查 之後
       類型推導 也不會遇到任何困難
  - x ::
       語法方面
       我考慮不再使用 <type> 這種東西了
       而是限制相同 name 的出現
  - k ::
       如果能這樣就最好了
       這樣語法就非常簡潔了
       但是
       這種語法簡化可能根本不行
       因爲
       語義上需要區分者
       必須能被區分
       如若不以語法區分
       則必由上下文推導之
       機器閱讀文本
       沒有人之變通
       所以不行

* 關於分支結構
  - x ::
       說
       定義新的類型構造子 就是定義新的函數
       因爲 不同的模式匹配行爲
       可以在函數體內
       以任意方式自由定義
       但是
       當分支結構在自由地在新定義的函數中出現時
       函數體做爲數據結構可能就難以處理了
  - k ::
       考慮純粹的 後綴表達式 線性而不帶括號
       這些問題將會如何體現

* 語法變更
  - x ::
       不如 類型 什麼都不用
       而 類型構造子 用 <imply> 等等

* 討論 <2015-09-09>
  - x ::
       發現 A B C 2 1 <imply> 這種東西是沒有意義的
       所謂的 "爲編譯 A B C 2 1 -> 適合 類型檢查"
       也是錯誤的
  - k ::
       那麼退回原來的設計
  - x ::
       除了定義新類型的部分
       語義已經明確了
  - k ::
       那麼我們先重述一下基本語義
       然後設計關於定義的語義
  - x ::
       每個函數的類型都是 則式
       則式 是特殊的複合類型 其構造子爲 (... -> ...)
       類型檢查 就是 匹配以分解 再構造以返回
       關於定義的語義涉及到實現方式
       複合類型 用向量實現
       素類型 用 name 實現
  - k ::
       我發現了一個重要的事
       即 我們應該把證明論中的語義對照進來
  - x ::
       好的
       類型檢查過了 就說明一個命題[所聲明的類型]被證明了
       函數的運行是另外一回事
       | 函數       | 參數棧中計算 類型棧[命題棧]中證明 |
       | 類型       | 命題                              |
       | 類型構造子 | 命題連詞                          |
       一次匹配 就是 一次 cut

* 定義語義
  - x ::
       | 素 函數       | 複合 函數       |
       | 素 類型       | 複合 類型       |
       | 素 類型構造子 | 複合 類型構造子 |
       類型構造子
       可以簡單的只是 記錄數據
       也可有複雜的 匹配 解構 構造 行爲
  - k ::
       重要的是要知道
       匹配的時候命名如何處理
       是否每次都把命名展開到最底層
  - x ::
       如果每次展開命名的話
       就有很多重複計算
       效率就太低了
  - k ::
       可以留一個域把已經展開的結果保存起來
       我覺得
       只有有具體的例子 才能做有意義的討論
  - x ::
       理論上
       假設沒有定義語義
       那麼 在類型構造子 還有與類型構造子相關的規則下
       所有的類型形成一個偏序集
       對匹配與否的判斷
       就是對這個偏序集裏序關係的判斷
       而 加入定義語義之後
       要保持這種對序關係的判斷依然能夠進行
       對於素的類型和類型構造子
       比較的方式是直接的
       而當有定義語義時
       有的比較就是間接的
       有等價關係
       一定只有展賴成素之後才能做比較
       所以你上面提到的就是我能想到的唯一的解法了

* 語法
  - x ::
       類型就直接用 name
       類型構造子也直接用 name
       單個命名空間 讓 類型構造子 和 類型 不能重名
       類型 和 類型構造子 都可以帶 title
       並沒有函數和計算會在 則式 中出現
  - k ::
       依賴關係怎麼辦
  - x ::
       用 <:x 和 :x 和計算語義中的有名局部變元類似

* 關於命名空間
  - x ::
    1. common-lisp 區分命名空間
       這樣 一個 symbol 在 sexp 中不同位置時
       所搜索的命名空間不一樣
       (f f f)
       第一個 f 搜索函數命名空間
       後兩個 f 搜索變元命名空間
       好處是 可以節省 命名的思想壓力
    2. scheme 不區分命名空間
       sexp 中某些位置爲特殊
       但是其所搜索的命名空間一樣
       既然 搜索空間 無所異
       那麼
       對一個括號中的位置的處理就可以更靈活
       這就得到了 蟬語 的 類型構造子 的語法

* 實現上的難點
  - x ::
       需要更改的代碼非常多
       需要回顧的設計也很多
  - k ::
       因爲這涉及到函數語義的接口[之一]
       即 定義函數
       每次定義函數的時候需要做類型檢查
  - x ::
       定義函數的時候多出來兩個步驟
    1. 類型檢查
    2. 檢查成功時 把所聲明的類型元信息 編譯到函數體內
  - k ::
       就要看用什麼數據結構實現這些功能了
  - x ::
       用可以嵌套的 symbol 的向量
       但是就像 返回棧 中不能只保存 jojo 一個域一樣
       這裏 類型棧 中的一個類型 不能單單是一個 symbol
  - k ::
       所以應該說是 嵌套的 type 的向量
  - x ::
       沒錯
       這個 type 至少有一個域是 symbol
       還需要有一個域來保存 被完全展開的 素類型
  - k ::
       而且可以發現 類型棧 本身 就是一個 type
  - x ::
       但是它是特殊的
       因爲 檢查的時候 需要把 則式 的前半部分放進去
       這種特殊性可能需要被強調
  - k ::
       那麼
       現在可以去實現這些數據結構了嘛
  - x ::
       我想不行
       還有依賴關係
       如果用 <:n :n 這種語法的話
       他們在 類型 中的存在是什麼
  - k ::
       與對 局部命名 的處理方式完全一樣 邪
  - x ::
       我想這裏的 <:n 可以出現在 -> 之前或者之後
       這樣二者的處理方式就不一樣了
       但是又很相似
  - k ::
       之前是吃掉值 >:n 並保存在局部分配的內存裏
       現在是貼標籤 <:n 不會有對命名的更新
       一旦不匹配就需要報錯
  - x ::
       沒錯
       (number -> vector)
       (number <:n -> (length-vector :n))
       需要區分 <:n 與 :n
       因爲 前者代表一個命名
       而 後者代表一個名稱的一次出現
       一個類型命名 不可能出現兩次
       比如
       (number <:n number <:n -> (length-vector :n))
       應該寫成
       (number <:n :n -> (length-vector :n))
  - k ::
       那麼
       (number <:n -> (length-vector :n))
       可不可以寫成
       (:n -> (length-vector number <:n))
  - x ::
       不行
       因爲
       命名不能出現在 (length-vector ...) 這個類型構造子裏面
       命名 <:n 只能出現在 (... -> ...) 這個類型構造子這個層次
       處理的時候也是相對線性的
  - k ::
       還有重要的 命名的 scope 問題
       (number <:n -> (length-vector :n) (number <:n -> (length-vector :n)))
       這種東西
  - x ::
       允許這樣的東西出現
       多實現一個函數來計算 scope 就行了
  - k ::
       考錄數據結構的實現吧
  - x ::
       首先
       <:n :n 在編譯時並不被處理
       也做爲 name 來存儲
       到需要 作用 一個 則式 的時候
       才解釋這些 命名
  - k ::
       我發現這與函數體的 編譯 與 作用 很不相同
    1. 函數體存儲的是地址 此時靜態
       類型中存儲的是 name 此時動態
       新定義的類型[如果允許的話] 會覆蓋就的類型的定義
    2. 函數體中出現的 局部命名
       是在編譯時期計算好的
       而 則式 中的局部命名 是在解釋時期處理的

* 具體數學結構與抽象數學結構
  - x ::
       回顧之前材料我才想起來我差點忘了 數學結構 了
       類[type] -- 具體數學結構
       種[class] -- 抽象數學結構
       這樣就能利用 class 來限制 polymorphism 的範圍了
       polymorphism 只有這樣實現才有意思
  - k ::
       但是我們可以考慮完全放棄 polymorphism
       而使用 dependent type
    1. 當所 dependent 的是 value 的時候
       就是一般的 dependent type
    2. 當所 dependent 的是 type 的時候
       就是 用 dependent type 所模擬的 polymorphism
       因爲反正我們不想省略跟類型有關的語法
  - x ::
       polymorphism 是爲了寫抽象的函數
       這些函數能夠作用於相似的[有相同函數接口的]數據類型
       class 是爲了控制抽象的函數所都能作用於的值
    1. polymorphism with class
       #+begin_src cicada-nymph
       : square
         (<number> a => a -> a)
         dup mul
         end
       ; define-function
       #+end_src
       這個函數是抽象的
       它必須作用於
       a value of a type
       which is an instance of <number> class
       真正所用於 value 的函數
       是在登記在 instance 中函數裏找的
    2. dependent type for polymorphism
       #+begin_src cicada-nymph
       : square
         (type <:a :a -> :a)
         dup mul
         end
       ; define-function

       << 使用 >>
       : example
         ()
         number square
         end
       ; define-function
       #+end_src

* 構造主義數學
  - x ::
       回來學具體的類型系統
       構造主義的影蹤隨處可見
       我們忘記了我們之前爲什麼
       從風塵僕僕的具體實現
       轉向對背後理論的學習
       又是什麼讓我們從對理論的學習轉回到具體實現
  - k ::
       我沒有忘
       第一次轉而去學習理論基礎
       是因爲發現
       沒有理論的支持根本沒有頭緒
       第二次轉回具體的實現
       是因爲讀了 Errett Bishop 的文章
  - x ::
       二者當真是不可分的
       不是嘛
  - k ::
       沒錯
  - x ::
       我們再回到基礎證明論和數學哲學中
       我們來好好總結一下 Errett Bishop 的論點
       來執導 類型系統的 設計與實現
  - k ::
       我們不應該害怕在兩個領域之間轉換
       我們應該發現轉換的節奏越來越快
       最終融會
  - x ::
       那麼從總結 Errett Bishop 的論點開始
       這次爲了減輕工作量
       我們只翻譯文章中那些真正影響我們的部分
  - k ::
       沒錯
       與單純計劃去翻譯全文相比
       能有一些翻譯成果出來分享更重要
  - x ::
       並且
       我們還可以以 Bishop 的論點爲基礎
       形成自己的數學哲學

* 類型棧沒有必要
  - x ::
       使用額外的類型棧是沒有必要的
       保存多值的 pattern 在 argument-stack 中即可
       因爲類型只不過是 name 的 vector
       另外
       考慮 dependent type
       對 term 和 type 的統一就知道了
       編譯時 的類型檢查
       和運行時 的實際計算
       並沒有本質的區別 只是實行時段不同而已

* (... arg2 arg1 fun) 語法
  - x ::
       (... -> ...)
       的意義在於
       這是對 三個邊綴的更充分利用
       還可以想像比這這種用法更充分的利用
       三個點給出兩個邊綴 [可以想像三個邊綴]
       每個邊上可以放任意個數的點
       但是
       可能的缺點是
       我們不能 lambda 它
       尤其是當 key 可以分散的時候
       如果換成是單純的後綴 就能解決這個問題
       (... arg2 arg1 fun)

* 素函數的類型
  - x ::
       素函數的類型
       是不能被檢驗的
       因爲素函並不是由其他函數複合而成的
       說着說
       因爲素函並不是以 可檢驗 的方式構造製作出來的
       製作素函數的時候沒有小心維護 可檢驗性
  - k ::
       素函數只是不可檢驗函數的一部分
       不可檢驗的函數還有別的
  - x ::
       沒錯
       當你[用匯編來]優化一個以正常方式定義的函數的時候
       它可能就沒法被檢驗了
       但是你可以保存函數的兩個版本
       優化過的和沒優化過的



* 數據結構
  - x ::
       在 agda 中所有的數據結構都是 嵌套的 name 的 vector[或 list]
       這種處理方式蟬語是否可以繼承

* 構造子
  - x ::
       構造類型並不難
       只要讓函數作用於參數就行了 :x :y kikiki
       但是想要構造某個類型的數據
       就要使用這個類型的構造子了
       就像 kikiki 做爲函數一樣
       它的構造子做爲函數也是 信息不減 的
       哦
       其實不是的
       其實
       某個類型的數據的構造子
       與 涉及這個類型的其他函數
       區分這二者 是一種公理化行爲
       其實在實現中
       總會有一些函數被處理爲 primitive-function
       回想 邏輯連詞的引入律與消去律
       再想 其和諧性
       引入律 就是 元素構造子
       消去律 就是 模式匹配 元素構造子 而定義的函數

* 如何實現類型這個數據結構
  - x ::
    - 則式
    - 字符串
    - 匹配 [關於等詞]
    - 計算時 沒有動態類型標籤
    - 就地分配 會複雜化接口
      這就是假想 類型棧的原因
      但是現在統一使用參數棧了
      所以接口不可能複雜化
      但是
      不就地分配就會把 數組處理 變成 鏈表處理
      然而 我沒有 鏈表處理
      因爲 我沒有 cons 的 heap
  - k ::
       我們要實現就地分配
       因爲我們要做的是數組處理而不是鏈表處理
       這是爲了 經常複製 並且 快速複製
       我們還需要能夠讓每個數據結構的實例
       都做爲一個地址而存在
       這是爲了簡化棧上面對它的操作
       此處大量使用之前設計的局部內存機制
       類型這個數據結構內部的接口可能很複雜
       但是參數棧本身的接口還是簡單的
  - x ::
       考慮 原子性的類型 比如 fixnum
       它是一個函數
       當調用它時 返回的是一個 id
       通過這個 id 可以 query 到 fixnum 這個類型的屬性
       比如名字
  - k ::
       那麼複合類型的
  - x ::
       哦
       複合類型和非複合類型必須以一致的方式處理
       因爲這裏的需要匹配它們
       而匹配需要等詞
       而此時實現等詞時還沒有類型系統可用
  - k ::
       如果我們不要求計算在參數棧中進行
       是不是就能避免等詞的難題
  - x ::
       我想這是正確的方式
       這樣就能更靈活
       在實際的計算過程中也能方便地啓動 類型檢查器
       考慮 則式
       它也一定要被實現爲一個類型
       並且要儘量減少其特殊性
       當編譯函數時
       需要製作 sequent 在內存中的存在
       其數據結構
       就像是一個可執行文件格式一樣
       注意
       出現在則式中的 vector
       做爲函數 是在定義它所出現的函數的時候作用的
       檢查器只是用編譯好的類型來做匹配
       先要考慮定義時如何通過一個字符串來定義類型
       然後考錄如何用製作好的類型來做檢查
       首先是定義
       (fixnum fixnum -> fixnum)
       (fixnum -> fixnum list)
       ({type <:t} {natural <:n}
        :t :t :n vector -> :t :n add1 vector)
       ({natural <:n}
        natural :n vector natural :n vector -> natural)
  - k ::
       我發現
       我們需要一個先實現我們所承諾的
       用局部內存機制所實現的數組處理
       然後才能以這種數組處理爲基礎來實現類型這個數據類型
  - x ::
       也就是說
       要先設計蟬語的最重要的數據類型了
       這個數據類型一定要豐富靈活
       可以先不考錄速度問題
       無非是數據與元數據
       元數據至少要包含長度
       元數據不能包含類型信息
       整個設計要方便雙向遍歷
  - k ::
       既然特點如此
       爲什麼不直以 matrix 爲基本數據結構呢
  - x ::
       但是 矩陣 之矩 在這裏是不需要的
  - k ::
       那麼就是特殊矩陣
  - x ::
       不對不對
       應該使用基本的數組來實現 matrix
       同時也使用基本的數組實現 type
       matrix 規整
       而 type 變長
       變長者
       可以實現爲
       |--------+------------------|
       | header | number of fields |
       |        | offset of field1 |
       |        | offset of field2 |
       |        | ...              |
       |--------+------------------|
       | field1 | ...              |
       |--------+------------------|
       | field2 | ...              |
       |--------+------------------|
       | ...    |                  |
       |--------+------------------|
       又可雙向遍歷
       |--------+------------------|
       | header | length           |
       |--------+------------------|
       | field1 | length of field1 |
       |        | ...              |
       |        | length of field1 |
       |--------+------------------|
       | field2 | length of field2 |
       |        | ...              |
       |        | length of field2 |
       |--------+------------------|
       | ...    |                  |
       |--------+------------------|
       | footer | length           |
       |--------+------------------|
       二者都可嵌套
       前者複製時需要計算 offset
       後者很好複製
       後者很有趣 像是文本編輯
       後者是不行的 因爲遞歸中並不知道總長度
       所以應該是
       |--------+------------------|
       | field1 | length of field1 |
       |        | ...              |
       |--------+------------------|
       | field2 | length of field2 |
       |        | ...              |
       |--------+------------------|
       | ...    |                  |
       |--------+------------------|
       | null   |                  |
       |--------+------------------|
  - k ::
       這就回到了類似 lisp 的鏈表

* 沒有垃圾回收器
  - x ::
       沒有垃圾回收器
       的條件下
       用上面的數據結構實現類型檢查器
       是可以接受的
       但是某些其他的算法就不行了

* >< 完全性
  - x ::
       agda 有對 pattern 的完全性的要求
       idris 沒有
       cicada 可能也沒有

* 構造子的公理化
  - x ::
       構造子的公理化很重要
       因爲限制了生成數據的方式
       就可以在 pattern match 中分類證明了

* >< 模式匹配
  - x ::
       模式匹配要在早期設計
       而不能在後期補救
       注意模式的區分
       其區分者使用的還是謂詞
       但是這裏的謂詞不詢問數據類型
  - k ::
       有三種跟謂詞有關的東西了
    1. 做爲函數的謂詞
    2. 做爲類型[命題]的謂詞
    3. 做爲模式的謂詞
  - x ::
       每一個 模式 其實就是一個真正的 runtime 的謂詞
       所以說 比如上面的對等詞的不同處理方式
       其實是
       runtime 的謂詞
       和 complie time 的謂詞
       之間的平衡
  - k ::
       這樣三者之間的關係就明瞭了
       而建議就是 把 explicit 的 函數型的謂詞
       處理成 type 和 pattern match
  - x ::
       比如 with 在 agda 中的使用
       也可以被看成是
       隱式的謂詞[pattern match]
       與 現式的謂詞 之間的平衡

* >< 模式匹配 改變了 類型檢查時 簡單的對棧的處理
  - x ::
       我們需要總結一下這一點
       沒有模式匹配時 類型檢查 就是簡單的不涉及局部命名的對棧中元素的變換
       有模式匹配時 類型檢查 涉及了局部命名
       還涉及到分支結構
       因爲 每種模式 都是一個分支

* >< 隱式參數的來歷
  - x ::
       隱式參數有的時候是虛的
       也就是說某些時候 有別的處理方式來完成同樣的功能
       比如
       ({type #type} -> :type list)
       可以寫成 (-> <type> list)
       其中 <type> 表示 type 類型中的一個元素
       此時的命名 #type 完全可以省略
       但是
       某些時候 隱式參數的使用是無可替代的
       就是當某次命名多次出現的時候
       就是用標記語言來表明依賴關係的時候
       就是用標記語言來繪製有向圖的時候



* >< 重新實現
  - x ::
       重新實現之時
       可以把之前加入的各種性狀整合起來了
       觀察類型系統所帶來的衝擊
  - k ::
       我們對類型系統的研究其實還不完備
       還需要向別的語言學習
  - x ::
       沒錯
       而現在 在學習時
       我們有一個具體的模型
       來幫助我們做獨立的思考了
       簡直美妙極了
  - k ::
       重新實現的時候
       發現 模塊系統 需要與 類型系統 一起考慮
       使得 模塊系統 的能力更加強
       同時 對命名的處理也應該改變 不能每次都加類型前綴了
  - x ::
       還有 pattern 和目前的語法如何融合
       是否應該完全拋棄現在的 if else then
       而用 pattern 的 * | 來實現它們
  - k ::
       還有對高階函數的處理
       還有 scope 問題
  - x ::
       沒錯
       看來還有很多需要觀察的地方
  - k ::
       我們來總結一下之前的 模塊系統 吧
       然後和 agad 和 idris 的 模塊系統 對比一下
  - x ::
       我們之前發現
       agda 的 module system 很難和 org-mode 一起使用
       還有
       對整個文件的類型檢查
       自動展開 pattern 的分支
       等等功能 都沒法在樸素的 org-mode 中使用
       除非擴展語言以識別 org-mode
       首先模塊系統的功能
    1. 自動加載所依賴的代碼 並避免重複加載
    2. 給命名加前綴 以實現命名隔離 以避免命名衝突
       蟬語中的模塊系統其實也是利用對前綴的處理來實現的
       但是這些處理被隱藏了起來
       所以 沒有處理 (2.) 這一點
  - k ::
       是否應該加入對名字衝突的處理呢
  - x ::
       其實已經有對命名的處理了
       我不把 title: 類型的前綴處理到類型系統中
       要知道 類型系統的衝擊下
       每個名字可能只能用一次
       而 對於模塊來說
       要加載一個模塊 只有把名字衝突解決好了才能加載
       另外還有重要的一點
       就是 agda 的模塊系統可以用以聲明加載這個模塊的要求
       這樣在何種條件下才能加載這個模塊就清楚了
       這是好的特性
       我們也要實現它
  - k ::
       但是這與 類型類 所提供的抽象是否重合
  - x ::
       是重合的
       因爲類型類是爲了重用抽象的函數
       而 聲明模塊的加載前提之後
       在不同的前提下加載 模塊的效果是不同的
       但是
       不論如何
       這種加載模塊時對前提的要求都是必要的
       因爲 爲了檢查某個模塊中的類型
       需要利用這些對前提的假設
       並且
       二者的區別在於
       聲明加載前提的模塊 在前提滿足前不能加載 [只能類型檢查]
       而 抽象的函數 是可以被真正編譯的
  - k ::
       是否
       每個 聲明加載前提的模塊 都可以被實現爲 類型類
  - x ::
       二者確實很相似
       都是假設某些東西存在
       然後寫依賴這些東西的函數
       聲明加載前提的模塊 是否是 匿名的 類型類
  - k ::
       都是可以用來寫暫時無法被使用的函數
       聲明加載前提的模塊 無法編譯
       類型類 無法調用

  -----------------------------------
  - k ::
       如果模塊不單單與文件對應
       那麼 就可以簡單地在同一個文件中
       實驗 同一個命題的不同的證明方式
       而不用重新命名兩種證明
  - x ::
       既然如此
       這種嵌套的模塊就也是必須的了
       可見需要改進的地方還有很多呢

* >< 程序語言的類型系統 與 弱類型系統
  - x ::
       agda idris haskell 的類型系統是非常強的
       而 比如 typed racket 之類的語言的類型系統很弱
       我們來仔細比較一下其性質差異
  - k ::
       就像 類型信息 做爲 函數的 最重要的 元數據
       能夠幫你理解函數一樣
       一個程序語言的類型系統
       也是幫你理解這個程序語言的 最重要的性狀之一

* >< 關於 是否把縮進加入語法的問題
  - x ::
       關於 是否把縮進加入語法的問題
       我們來客觀地觀察一下二者的特點
       首先
       縮進入語法的好處
       簡潔
       其次
       用明顯邊綴標記的好處
       可以在結束之時 知道是什麼結束了
       縮進也是寫出來的 只不過沒有把縮進加入語法
       不依賴縮進
  - k ::
       所謂
       縮進也是寫出來的 只不過沒有把縮進加入語法
       這很荒謬
       完全是浪費語法上的複雜性
  - x ::
       但是這樣就簡化了實現



* >< 類型類是類型這個類型的子類型
  - x ::
       類型類 就是
       抽象的數據結構
       type 是一個類型
       每定義一個類型類
       其實都是 type 的一個 子類型
       也就是說 子類型 是比 類型類 更一般的概念
  - k ::
       爲了避免 悖論 而引入了類型的層次
       type 的類型爲 type 1
       type 1 的類型爲 type 2
       等等
       每個類型都有構造子
       那麼 type 這個類型的構造子是什麼
  - x ::
       在 agda 中
       是用以定義類型的語法關鍵詞 data
  - k ::
       但是這種定義是 副作用
       而一般的類型的類型構造子 是函數
  - x ::
       那麼
       就是說 type 這個類型是特殊的
  - k ::
       沒錯
       但是其特殊性何在
  - x ::
       既然我說
       每個 類型類 都是 type 的 一個 子類型
       那麼 type 的特殊性
       就是 類型類 的特殊性
       而且我們可以這樣想
       構造子 是一個類型的基本接口函數
       而 type 有關的接口
       是 則式 (... -> ...)
       而如果我們去實現 類型類 這個性狀的話
       一定需要在 則式 (... -> ...) 中引入新的語法
       也就是改變 type 這個類型的接口函數
  - k ::
       你這種分析 首先假設了 類型類 是完全獨立與已有性狀的性狀
       因此 才需要引入新的語法來表達它
  - x ::
       我想是這樣的
       我們來仔細分析一下
       ><><><

* >< 作用不副
  - x ::
       我需要讓我的語言能夠表達關於作用的推理
       這可以通過 在參數棧之外 增加額外的棧來實現
       比如 一個函數 字符串輸出
       當它與別的函數複合之後 所得的函數也會有字符串輸出
  - k ::
       函數對參數棧作用的效果
       可以被之後複合而來的函數消除
       然而 對其他的棧的作用 就涉及到不同的代數了
  - x ::
       沒錯
       這裏可以擴展出非常有趣的東西來
