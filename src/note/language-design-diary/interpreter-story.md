# Interpreter story

2020-09-14

今天早上看了 Design by Coding 这个视频的一小半就着急出门了。
- https://www.youtube.com/watch?v=d5Y1B1cmaGQ&ab_channel=AllenHolub

看到了他讲自上而下的编程方法论，大致的思路是：
如果先写底层代码，很容易会设计出参数太多，不好用的函数，
函数也不方便复合，导致有些方法看似多余，又不得不有。
这都是因为没有时时想着这些函数会如何被用到，
也就是忘了这些底层代码所要解决的问题。
因此不如先写上层的代码，先根本就不要实现底层。
路上一直在想其中的道理。

我以为讲的是，想要解决一个问题，
先就这个问题形成相关的基本字词，
能够表达现象中的基本概念，
然后围绕这些词来实现相关的函数，
就能有好用的，能够自然地复合的 API。

然后就想到 Forth、Joy 这类，
其语法是为函数复合而优化的语言，
因为起语法表面有了函数复合所带来的结合性，
所以能够更容易地在其中看到如何分解与组合词语。
想到要再去看 Thinking Forth。

中午看完了视频，知道了他说的是，要利用故事。
这里的「故事」就是文学中的故事，不是刻板的软件需求文档。
利用故事，应该可以很容易让人重新理解所要解决的问题，
很容易让人回忆起当时所考虑的解决方案与思路。
提取故事中主要的名词与动词，它们描述的就是现象的主要概念，
围绕这些名词去设计程序的类型，围绕这些动词去设计联系类型的函数与方法。

我们能用这种方式去写语言的解释器吗？
evaluate 本来是一个动词，
而人们总是说成 evaluator 或者 interpreter。
type check 也是一个动词，
而人们总是说成 type checker。
每个动词都可以以这种方式被名词化，
并且人们在谈论中也常常有这种倾向。
我不应该写 `Exp.check`，而应该写 `Checker.check` 与 `Checker.infer` 吗？
不应该把所有看似以 `Exp` 为核心的函数都已 `Exp` 这个名词为前缀，
而是应该用不同的额外名词，比如 `Checker`，来将这些动词分组？

这不一定是好的，因为这与函数式以及偏数学思维方式的编程方法不同。
这也不一定是不好的，因为描述语言实现与类型系统的文章与材料，
确实是偏向数学了，但是太难读了。
即便是 The Little Typer 这样的书，
在末尾使用的描述 inference rule 的语言，
还是让人觉得难读，与正文对话的简单流畅对比鲜明。

那么我们就试试吧，学学面向对象编程的方法论，
学学 user story 与 UML 之类的工具。

2020-09-15

我想我的态度应该是这样，
我知道自己目前组织代码的方式可能并不是最好的，
并且我大概知道别的可能性，
但是我假设自己目前的方式是对的，
以保持自己的行动。

即不去做上述的动词名词化，
围绕本源性的名词来组织代码。

在与到这种表达方式难以表达的问题之前，
我假设它是万能的。

## Currying type checking function

2020-10-29

上面提到了 `Exp.check` 没有被名词化为 `Check`。
在实现 lang3 的过程中，我也体会到了类型检查相关的函数不清晰。

反过来看另一个项目的架构。
我先是实现了 `Schema.detector` 与 `Schema.translator`，
然后很快意识到需要将他们名词化为 `Detector` 与 `Translator`，
并且实现 `Detector.from_schema` 与 `Translator.from_schema`。

对于 `Exp.check` 也许我们也应该将它名词化为 `Check`，
并且实现 `Checker.from_type`。

2020-10-30

也许不应该这么做。
需要学习 "combine functions into class"
以及关于 encapsulation 的 refactoring。
