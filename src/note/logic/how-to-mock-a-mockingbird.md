---
title: 嘲嘲不已 / How To Mock A Mockingbird
---

# 嘲嘲不已 / How To Mock A Mockingbird

Notes taken from "To Mock A Mockingbird" by Raymond Smullyan.

# TODO

- 文日進 而常改
- 讀益多 而錦添
- 明確 代碼之形式變換
- 明確 語圖之形式變換
- 明確 運算律
- 嘗試形成一種新的比喻
  - 是否應該
    直接使用 組合子 這個名字
    然後具體的描述其行爲
    而讓讀者自己想像其比喻呢
  - 使用可以相互結合的精靈來比喻嗎
  - 用細胞來比喻嗎

# 記

## 題記

- 主要內容來自 老頑童 Smullyan 之組合子問答集
  但是我並不用鳥來做比喻了
  鳥的比喻中只有 函數作用 這一種操作
  限制操作方式
  對於研究空間的整體性質是有價值的
  但是對於設計一般性的語言而言
  則沒有一點兒好處
- 在下文中
  稱 組合子之空間
  爲 組合子之林
  以紀念 Smullyan 的比喻
- 所以
  以明顯的方式用棧
  追求理解的簡單性和具體性
  只要有形式上的運算律
  就能夠對代碼進行變換
  而不再追求形式上的單純性
- 將獲得的最重要的特點是
  [比諸 lambda-calculus[木答演算]]
  計算的順序是被明指
  等號 在木答演算中的意義是無向路
  而這裏
  必須避免對這種迷失方向的無向路之使用

## 序

- 小寫字母以表之無類
  大寫字母或中文以表之有類
- 命名依組合子的行爲
  而 蟬語[或 lambda-calculus] 中
  對約束變元的命名是爲了標記
  以描述函數體的內部結構

## 一元化

- 首先注意這裏所有的組合子都是一元化的[即 curry]
  也就是說這裏所展示的
  只是蟬語的一個簡單部分而已
- 其 一元化 提示人們
  當看到一個組合子
  在蟬語的語法下所形成的表達式的時候
  兩個重要的觀察是
  1. 看它能否 返回 一個單一的值
  2. 看它是否要 作用於 一個單一的值

## 需處理的數據類型

- 符號
- 無名組合子

## 對數據類型的操作

### 命名

- 核心語義之一
  用以 把 匿名組合子 與 符號 綁定
  綁定之後 這個符號的語義就是 有名組合子
  有名組合子 和 無名組合子 統稱爲 組合子

### 製作匿名組合子

- 核心語義之一
  一種標記語言 以形成有向圖
  用 [ ] 這個 borderfix notation
  對應與語圖中的多邊形
  我也不確定應該如何比喻
  具體地
  它對入棧一個用雙向鏈接的鏈表實現的樹
  樹中的某些位置可以被標記語言鏈接到其他地方
  注意
  用以嵌套以形成樹的
  有三種 括號 [ ] { } ( )
  所以在實現的時候一定要加標籤
  因爲 [ ] 會直接入棧數據
  而 { } ( ) 不是直接入棧數據

### 作用

- 核心語義之一
  以 ( ) 這這個 borderfix notation
  來表示之
  其作用於 組合子 之效果
  爲
  代之以體 並 依次執行
- 有名者之作用 如 B (A)
- 無名者之作用 如
  [ (M) (F) ] { (M) (F) }
  [ (M) (F) ] [ (M) (F) ] (apply)
  [ (M) (F) ] (M) (F)
  - 如上之前二
    在語圖中並不存在對應者
    而其三 在語圖中有對應者
- 在代碼中可只以 [ ] 和 (apply) 來推導語義
  { }  =  [ ] (apply)
  ( )  =  [ ] (apply) (apply)
- 而在語圖中 總需
  以 大圈 爲 { }
  以 小圈 爲 ( )
- 這個等價變換有時循環
  比如
  (apply)
  [ apply ] (apply) (apply)
  apply (apply)
  所以這個[從到右的]變換 並不爲解釋器所用
  只爲人的理解

### 複合

- 這個操作是 製作匿名組合子 的一種特殊情況而已
  即 [ (M) (F) ]
  它並不涉及約束變元
  相比 製作匿名組合子
  複合 並不是 核心語義

### 限制製作組合子的方法

- 在問題集中
  常常需要對構造函數的方式做限制
  這都是爲了觀察在限制下空間有什麼性質
- 組合邏輯
  只允許函數作用
  古典的組合邏輯的宗旨就在於此
  即 不用複雜的製作方法來製作組合子
  並且 古典的組合邏輯 中
  給出了系統的方法來把
  木答演算 中的 木答抽象
  轉化爲[有限的幾個]組合子的作用
- 木答演算
  利用 木答抽象
  可以製作出
  用以製作遞歸函數的組合子
  木答演算的有趣之處就在於
  不用標記語言也能定義遞歸函數
- 蟬語
  提供一個標記語言
  以靈活的方式形成相互引用
  可以直接構造出遞歸函數
  因爲每個函數可以引用到自身

## 組合邏輯

### 引

- 這裏的內容來自 stanford encyclopedia of philosophy
  http://plato.stanford.edu/entries/logic-combinatory/
- 其中描述
  在歷史上
  組合邏輯 如何起源於 邏輯問題
  的部分 尤其有趣
  這些歷史性的知識是不出現在一般的介紹組合邏輯的書中的
- 這裏詳細的介紹了 組合子邏輯 這個領域[這種處理方式]
  引人感興趣的原因
  作者的某些例子非常有趣
  1. 單由 "|" 即 "nand" 就足以推演 命題演算
     [classical sentential logic] [SL]
     [classical propositional logic]
  2. schonfinkel 想要
     僅憑 "for-all" 和 "|" 而推演 謂詞演算
     [first-order logic] [FOL]
     但是 命題演算 並不需要處理 約束變元
     而 謂詞演算 需要處理 約束變元
     現在我只能說是出於個人審美方面的原因
     schonfinkel 決定消除對約束變元的使用
     - 因爲我很喜歡使用約束變元
       並且我比認爲處理它們有什麼困難
       並且我認爲
       有時用約束變元來構造新的函數比用組合子方便

### Schonfinkel

- Schonfinkel 首先所做的就是
  定義了一個組合子 它作用於兩個 謂詞
  降低兩個謂詞的定義域的維數
  [零維者即爲真值]
  顯然 Schonfinkel 知道
  只要定義一些基本的
  用以降低謂詞定義域的維數的
  高階函數
  然後指明
  如何由基本組成部分
  組合以形成複雜高階函數
  那麼很可能就能系統的消除約束變元的使用
  所以他去找了一個這樣的比較基本的東西
- Schonfinkel 發現
  單單使用一個 nextand [not-exists-and]
  [被約束變元參數化的二元高階函數]
  就能形成整個理論
- 我從程序語言的角度
  以精確易懂的語義
  來解釋一下 Schonfinkel 的發現
  TODO

### Combinatory terms and their main properties

- 不應該 依照組合子的表面形式 來爲其分類
  這是前人的錯誤
- 所有形式化方法在試圖捕捉函數這個概念的時候
  都不能形成有效的等詞來判斷
  只從輸入輸出來看 兩個函數是否完全相等
  因爲除了輸入輸出
  函數還有別的重要的區別
  比如其時間複雜度

### Church rosser theorem

- 這個定理更好的名字是
  木答演算所形成的有向圖中
  有向路的交織定理
  交織所能形成的性狀是菱形或者三角形
- 關於沒有出邊的點
  這個定理能給出有趣的推論

### 組合邏輯與木答演算的區別

- 在木答演算中
  所有的函數都是一元化的
  每次一個函數作用都能形成一步化簡
  即 都能在有向圖中行走一步
- 而在組合邏輯中
  雖然所有的函數也都被認爲是一元化的
  但是只有當[語義上的]多元函數的參數都到齊了之後
  才能進行一步化簡
- 也就是說
  就有向圖而言
  木答演算所對應的有向圖更加規整

### 對組合邏輯的批判

- 組合邏輯對約束變元的消除一定是非本質的
  因爲關於位置的信息一定會以其他的方式被編碼在表達式中
- 所以說
  從一般的標記語言
  到木答演算
  到組合邏輯
  只不過是對信息的編碼方式在發生變化而已
  沒有是非之分
- 爲了讓上面的斷言有效
  必須補充證明的一個命題是
  任何複雜的標記語言
  都能被劃歸爲木答演算所提供的簡單標記語言

## 律

### 記

- 總結運算律於此

# 嘲嘲

## 1 嘲嘲不已 戀戀然

- 若 x (M)  =  x (x)
  則 稱嘲
- 例如
  [ .x (:x) ]
  - [ .x (:x) ] =
    [ .x [ :x ] (apply) (apply) ] =
    [ .x .x (apply) ]
- 若 B (A)  =  B
  則稱 A 戀 B
- 若 林中 允許以 [ (A) (B) ] 來製作無名組合子
  則稱 此林 允許複合
- 問
  若
  知 嘲 之存在
  知 允許複合
  則 衆子皆有所戀 邪
- 衆子皆有所戀之林
  稱 戀戀然

### 解

- 然也
  解 x (F)  =  x 即可
  試觀察解的形狀
  而設 x 爲 y (x)
  而解 y (x) (F)  =  y (x)
  蓋無窮之 (F) (F) (F) ...
  儘管其非一真實組合子
  但其形似所求之解
  可以 M 造無窮 (F) 如此如此
  [ (M) (F) ] (M) (F) =
  [ (M) (F) ] (M) (F) (F)
  因
  [ (M) (F) ] (M) =
  [ (M) (F) ] (M) (F)
  更知
  [ (M) (F) ] (M) =
  [ (M) (F) ] (M) (F) =
  [ (M) (F) ] (M) (F) (F)
  故而 [ (M) (F) ] (M) 即爲 (x)
  且知 [ (M) (F) ] (M) (F) 亦爲 (x)
- 但知此解徒有形式
  而不可爲編程之用
  因其作用無窮不已耳
- 其實
  其可用與否在於語言的實現方式
  只是在蟬語的實現方式下
  它無用而已
  就這種公理性的等式[變形]
  來設計表達式轉寫器
  其實也可以實現一個語言
  但是我認爲
  用內部的 以代換語義爲核心的 有向圖
  來實現其語言
  則效果更好
- 其實
  如果在蟬語的計算語義中
  如果實現 單步地變換
  那麼這種等式就又是有用的了
- 其實
  x (F)  =  x
  這個方程很具有迷惑性
  尤其考慮到 人們對等式的語義的一般認識
  因爲在這裏的問題中戀 (F) 的性質都不知道
  所以
  1. 根本不可能
     從等號左邊
     經過一步的函數作用
     而變換到等號的右邊
  2. 那麼一定就是
     從等號右邊
     經過一步的函數作用
     而變換到等號的左邊

## 2 自戀

- egocentric narcissistic
- 問
  若
  知 嘲 之存在
  知 允許複合
  則 林子中有自戀之組合子 邪

### 解

- 解 E  =  E (M)
  由 E (M) =  E (E)
  得 E  =  E (E)
- E = [ (M) (M) ] (M)

## 3 佳之存在 戀戀然

- agreeable
- 若 x (A)  =  x (B)
  則稱 A 認同 B 於 x
- 若 A 認同 每一 組合子 於 某一 組合子
  則稱 佳
- 問
  若
  知 佳 之存在
  知 允許複合
  則 林中 戀戀然 邪

### 解

- 給 F 而求其所戀
- 設 A 爲 佳
  則 可解
  x (A) =
  x (A) (F)
  則 x (A) 爲 F 所戀
  因 A 認同 [ (A) (F) ] 於 x 耳
- 比之與 M
  [ (M) (F) ] (M) =
  [ (M) (F) ] (M) (F)
  知其簡
- 嘲即爲佳
  是故
  觀察以嘲解 x (F) = x 之過程
  弱化其條件
  而得佳

## 4 佳之親善

- 設 (C)  =  (B) (A)
  知 允許複合
  則
  C 佳 而 A 佳 也

### 解

- _ (B) (A) = _ (B) (D) 可解
  _ (A) = _ (D) 之解亦明矣

## 5 複合

- (C) (B) (A) =
  { (C) { (B) (A) } } =
  { { (C) (B) } (A) }
- 易證之於代碼之變換
- 其後二者 不可畫於語圖

## 6 容

- compatible
- 知 允許複合
- 以 M 解
  x (A)  =  y
  y (B)  =  x
- 得解者 稱 A B 容

### 解

- y (B) (A)  =  y
  以解的 y
  代回解得 x

## 7 樂

- 與己容者 稱樂
  x (A)  =  y
  y (A)  =  x
- 有所戀者 必樂
  證明之

### 解

- 設 a (A)  =  a
  以解 x y
  x y 者
  皆 a 也
  需證邪

## 8 常

- 有所戀者 稱常
- 由前知 常必樂
- 不以 嘲 尋 樂
  亦不以 嘲 尋 常
  試證
  如若有一樂 必有一常

### 解

- 知
  x (A)  =  y
  y (A)  =  x
  則
  x (A) (A)  =  x
  則
  (A) (A) 爲所尋之常也

## 9 自絕戀

- hopelessly egocentric
- A (A)  =  A 者 自戀
  x (A)  =  A 者 自絕戀
  x (A)  =  B 者
  稱 A 恆於 B
  或 A 絕戀 B
- 若 y ( x (K) )  =  x
  則稱 分
  即 x (K) 恆於 x
  K 之型意表分支也
  故名之 分
- 例如
  [ [ :x .y (drop) ] ]
- 問
  若
  知 允許複合
  何以
  以 M K 尋一自絕戀者 邪

### 解

- K 所戀者是也
- 因 X (K) = X
  而 y (X) = y ( X (K) ) = X
- 分者 絕戀者
  皆退化的組合子
  從構造方面講
  其退化彰於 (drop)
  從行爲方面講
  其退化亦可表述爲外部的性質

## 10 恆者戀者

- 如若 x 恆於 y
  則 x 必戀 y
- A 恆於 B 者
  A 絕戀 B 者也

## 11 分

- 若 K (K)  =  K
  則 K 自絕戀
- x (K) =
  x ( K (K) ) =
  K

## 12 再分

- 若 x (K) 自戀
  則 K 必戀 x

### 解

- 若
  x (K) ( x (K) ) =
  x (K)
  則
  x =
  x (K) ( x (K) ) =
  x (K)

## 13 簡單的練習

- 如若 A 自絕戀
  則 x (A)  =  y (A)

## 14 再一簡單的練習

- 如若 A 自絕戀
  則 y ( x (A) )  =  A

## 15 自絕戀是傳染的

- A 自絕戀
  則 x (A) 自絕戀

## 16 分 是可以被消去的

- x (K)  =  y (K)
  則 再作用於任意一值
  而知 x = y

## 17 恆者 必恆於一

- 如若
  x (A) = B
  x (A) = C
  則 B = B

## 18 分 之消去

- 若 K 戀 x (K)
  則 K 戀 x

### 解

- K 戀 x (K) 者
  x (K) (K) =
  x (K)
  後邊消去一 (K) 即可知之

## 19 孤獨

- 自絕戀 之 分
  必極孤獨 邪

### 解

- 此時林中獨有一個 分 也
  因爲
  x =
  y ( x (K) ) =
  y (K) =
  K
  而 x 是林中的任意一組合子

## 20 若傻爲佳 則戀戀然

- 若 x (I)  =  x
  則稱 傻
- 戀所有之組合子者 傻也
- 如若 I 爲佳
  則不必知更多條件
  而可得 林之戀戀然

### 解

- 因
  任意 y 存在 x
  x (I)  =  x (y)  =  x
  則尋得 x 爲 y 所戀

## 21 若戀戀然 則傻爲佳

- 這也由同上的等式得出
  x (y)  =  x  =  x (I)

## 22 容容然

- 若
  x (A)  =  y
  y (B)  =  x
  得解
  則 稱 A B 容
- 林中任意二子皆相容者
  稱林 容容然
- 又知
  衆子皆有所戀之林者 戀戀然也
  a (A)  =  a
- 問
  知 其林容容然
  知 有一傻
  則
  其林 戀戀然 邪
  其傻爲佳 邪

### 解

- 容容然 知
  x (B) (A) = x 可解
  就 傻而解
  得 林之 戀戀然
- 而 若戀戀然 則傻爲佳
  故傻爲佳

## 23 傻自絕戀

- 傻自絕戀則孤獨
  x = x (I) = (I)

## 24 靈

- lark
- 若
  y ( x (L) ) = y (y) (x)
  則稱 靈
- 例如
  [ [ .y (:y) (.:x) ] ]
- 問
  由 L 和 I
  可得 M 邪

### 解

- I (L) 爲 M
  y ( I (L) ) =
  y (y) (I) =
  y (y)
  知之

## 25 靈之存在 戀戀然

- 問
  知 靈之存在
  則 戀戀然 邪
- 戀戀然而常
  常而樂
- 下面各問
  直至結尾
  皆不用函數複合
  此靈之爲用矣

### 解

- F (L) ( F (L) ) =
  F (L) ( F (L) ) (F)
- F (L) ( F (L) ) 爲 F 所戀
- 若記 X = F (L)
  則簡化爲
  X (X) =
  X (X) (F)
- 正與
  記 X = [ (M) (F) ]
  而化
  [ (M) (F) ] (M) (F) =
  [ (M) (F) ] (M) (F) (F)
  爲
  X (X) =
  X (X) (F)
  相同
  只不用函數複合以構造耳
- 由 L 和 I 可得 M
  是故
  觀察以嘲解 x (F) = x 之過程
  變更其條件
  而得靈

## 26 靈自絕戀 則無不戀靈

- 由 靈自絕戀
  得 L ( x (L) ) = L (L) = L
- 由 靈之定義
  得 L ( x (L) ) = L (L) (x) = L (x)
- 而得證

## 27 如若靈不分 而分不靈 則靈不戀分

- 若 K (L) = K
  則 再作以 y
  得 y (K (L)) = y (K)
  即 y (y) (K) = y (K)
  而 (K) 可消
  故得 y (y) = y
  即林中之組合子皆自戀
- 代入以 K
  得 K (K) = K
  K 自戀則自絕戀 如下
  K = x ( K (K) ) = x (K)
  而 K 自絕戀
  則 K 爲林中孤獨組合子耳
  與 L 之存在相矛盾
- 故而 依歸謬法
  得 K (L) =/= K
  即 靈不戀分

## 28 如若靈不分 而分不靈 若而有分戀靈 則無不戀靈

- 之前以 靈自絕戀 爲條件
  而得 無不戀靈 之結論
- 而此一例
  又是以弱化的[變更的]條件 而得相同結論
- K 所戀者 自絕戀矣
  故 靈自絕戀
  而靈自絕戀 則無不戀靈
  得證

## 29 若只有靈則必有自戀者

- 此爲 以靈 由函數作用 構造 自戀者 之遊戲也
  注意 只用作用 不用複合
- 提示如下
- 所尋者 y (y) = y 之解也
- 代 y 以 x (x)
  轉而解 x (x) ( x (x) ) = x (x)
  注意
  即使有
  y = x (x)
  也未必有
  y (y) = x (x)
  因此解得 x 之後
  仍需帶回 以得原方程的解
- 靈者 其特點在於
  單由函數作用 即可 以其解出 任意組合子之所戀
  而在此空間中 只知靈之存在
  故而 能作爲 解其所戀者 之對象中
  最簡單者 即爲 L 本身
  次簡單者 爲 L (L)

### 解

- 我斷言
  此 x 爲 L (L) 之所戀者 時
  它就爲上面的方程的一個解
- 依照之前所敘述的解所戀者之法
  由 L 解出這個 x 即可
- 由
  F 之所戀爲 F (L) ( F (L) )
  而得
  x = L (L) (L) ( L (L) (L) )
  y = L (L) (L) ( L (L) (L) ) ( L (L) (L) ( L (L) (L) ) )
- 證明很簡單
  由 x 爲 L (L) 之所戀者
  知 x ( L (L) ) = x
  由此可以解除 x 的不依賴於 L 的性質
  _ (x) =
  _ ( x ( L (L) ) ) =
  _ ( x (x) (L) ) =
  _ (_) ( x (x) )
- 代 x 入 空格就驗證了上面的輔助性方程
- 另外
  由 L 和 I 可得 M 矣
  如若 由 L 可得 I
  則 單憑 L 即可得 M
  由此知靈之重要矣

## 關於本章的最後一問

- 可以發現上面的問題是有被進一步研究的可能的
  [當然更可能的是 在組合邏輯領域 很多人已經研究過這個問題了]
  即
  關於在各種組合子的空間中解方程的技巧
  還有
  其方程可解性的一般理論

# 愛神

- 知衆之所戀者 稱愛神
- 這裏處理方式略有不同
  1. Smullyan 不得不把函數複合作爲一個前綴函數來處理
     即把 與 M 的複合 即爲函數 A 的作用
     用 A M F 與函數作用求 _ (F) = _
  2. 我用 M F 與函數作用還有函數複合求 _ (F) = _ 即可
     即 對我來說 [ (M) (F) ] 顯然也在森林裏
- 其實更細化得 由 M 的性質知這裏的 A 其實爲 L
  所求爲 [ (L) (M) ]

# 豐

## 教學法

- 直到這裏
  在經歷了很多有趣的例子之後
  Smullyan 才開始引進
  對函數作用這個
  以中綴表達式表達的
  沒有結合律的
  二元運算的
  默認結合方向
- 這就要求
  我也要 從教學法的意義上
  重新排版一下 我的文本的順序
  而我已經有一個 Smullyan 所提供的
  非常好的大的框架了

## 關於語法之優劣的比較

- 在介紹了默認結合順序之後
  人們宣稱在其語法更可讀了
  在這裏我可以把兩種語法的可讀性進行一下比較
  蟬語中並不必引進默認的結合規則
  ```
  | combinator            | combinator  |
  |                       | [no space]  |
  |                       |             |
  | x y z w               | xyzw        |
  | x ( y ( z w ) )       | x(y(zw))    |
  | x ( y z ) w           | x(yz)w      |
  | x ( y z w )           | x(yzw)      |
  | z y ( z w y ) v       | zy(zwy)v    |
  | ( x y z ) w v x       | (xyz)wvx    |
  | x y ( z w v ) ( x z ) | xy(zwv)(xz) |
  | x y ( z w v ) x z     | xy(zwv)xz   |
  | x ( y ( z w v ) ) x z | x(y(zwv))xz |

  | combinator            | combinator                |
  |                       | [lisp style]              |
  |                       |                           |
  | x y z w               | (((x y) z) w)             |
  | x ( y ( z w ) )       | (x (y (z w)))             |
  | x ( y z ) w           | ((x (y z)) w)             |
  | x ( y z w )           | (x ((y z) w))             |
  | z y ( z w y ) v       | (((z y) ((z w) y)) v)     |
  | ( x y z ) w v x       | (((((x y) z) w) v) x)     |
  | x y ( z w v ) ( x z ) | (((x y) ((z w) v)) (x z)) |
  | x y ( z w v ) x z     | ((((x y) ((z w) v)) x) z) |
  | x ( y ( z w v ) ) x z | (((x (y ((z w) v))) x) z) |

  | combinator            | combinator                        |
  |                       | [no default order]                |
  |                       |                                   |
  | x y z w               | ( ( x y ) z ) w                   |
  | x ( y ( z w ) )       | x ( y ( z w ) )                   |
  | x ( y z ) w           | ( x ( y z ) ) w                   |
  | x ( y z w )           | x ( ( y z ) w )                   |
  | z y ( z w y ) v       | ( ( z y ) ( ( z w ) y ) ) v       |
  | ( x y z ) w v x       | ( ( ( ( x y ) z ) w ) v ) x       |
  | x y ( z w v ) ( x z ) | ( ( x y ) ( ( z w ) v ) ) ( x z ) |
  | x y ( z w v ) x z     | ( ( ( x y ) ( ( z w ) v ) ) x ) z |
  | x ( y ( z w v ) ) x z | ( ( x ( y ( ( z w ) v ) ) ) x ) z |

  | combinator            | cicada language                   |
  |                       |                                   |
  |                       |                                   |
  | x y z w               | w ( z ( y (x) ) )                 |
  | x ( y ( z w ) )       | w (z) (y) (x)                     |
  | x ( y z ) w           | w ( z (y) (x) )                   |
  | x ( y z w )           | w ( z (y) ) (x)                   |
  | z y ( z w y ) v       | v ( y ( w (z) ) ( y (z) ) )       |
  | ( x y z ) w v x       | x ( v ( w ( z ( y (x) ) ) ) )     |
  | x y ( z w v ) ( x z ) | z (x) ( v ( w (z) ) ( y (x) ) )   |
  | x y ( z w v ) x z     | z ( x ( v ( w (z) ) ( y (x) ) ) ) |
  | x ( y ( z w v ) ) x z | z ( x ( v ( w (z) ) (y) (x) ) )   |

  | cicada language                   | combinator            |
  |                                   |                       |
  |                                   |                       |
  | w ( z ( y (x) ) )                 | x y z w               |
  | w (z) (y) (x)                     | x ( y ( z w ) )       |
  | w ( z (y) (x) )                   | x ( y z ) w           |
  | w ( z (y) ) (x)                   | x ( y z w )           |
  | v ( y ( w (z) ) ( y (z) ) )       | z y ( z w y ) v       |
  | x ( v ( w ( z ( y (x) ) ) ) )     | ( x y z ) w v x       |
  | z (x) ( v ( w (z) ) ( y (x) ) )   | x y ( z w v ) ( x z ) |
  | z ( x ( v ( w (z) ) ( y (x) ) ) ) | x y ( z w v ) x z     |
  | z ( x ( v ( w (z) ) (y) (x) ) )   | x ( y ( z w v ) ) x z |

  | cicada language                   | combinator                        |
  |                                   | [no default order]                |
  |                                   |                                   |
  | w ( z ( y (x) ) )                 | ( ( x y ) z ) w                   |
  | w (z) (y) (x)                     | x ( y ( z w ) )                   |
  | w ( z (y) (x) )                   | ( x ( y z ) ) w                   |
  | w ( z (y) ) (x)                   | x ( ( y z ) w )                   |
  | v ( y ( w (z) ) ( y (z) ) )       | ( ( z y ) ( ( z w ) y ) ) v       |
  | x ( v ( w ( z ( y (x) ) ) ) )     | ( ( ( ( x y ) z ) w ) v ) x       |
  | z (x) ( v ( w (z) ) ( y (x) ) )   | ( ( x y ) ( ( z w ) v ) ) ( x z ) |
  | z ( x ( v ( w (z) ) ( y (x) ) ) ) | ( ( ( x y ) ( ( z w ) v ) ) x ) z |
  | z ( x ( v ( w (z) ) (y) (x) ) )   | ( ( x ( y ( ( z w ) v ) ) ) x ) z |

  | cicada language                   | cicada language           |
  |                                   | [lisp style]              |
  |                                   |                           |
  | w ( z ( y (x) ) )                 | w (z (y (x)))             |
  | w (z) (y) (x)                     | w (z) (y) (x)             |
  | w ( z (y) (x) )                   | w (z (y) (x))             |
  | w ( z (y) ) (x)                   | w (z (y)) (x)             |
  | v ( y ( w (z) ) ( y (z) ) )       | v (y (w (z)) (y (z)))     |
  | x ( v ( w ( z ( y (x) ) ) ) )     | x (v (w (z (y (x)))))     |
  | z (x) ( v ( w (z) ) ( y (x) ) )   | z (x) (v (w (z)) (y (x))) |
  | z ( x ( v ( w (z) ) ( y (x) ) ) ) | z (x (v (w (z)) (y (x)))) |
  | z ( x ( v ( w (z) ) (y) (x) ) )   | z (x (v (w (z)) (y) (x))) |

  | cicada language                   | cicada language     |
  |                                   | [no space]          |
  |                                   |                     |
  | w ( z ( y (x) ) )                 | w(z(y(x)))          |
  | w (z) (y) (x)                     | w(z)(y)(x)          |
  | w ( z (y) (x) )                   | w(z(y)(x))          |
  | w ( z (y) ) (x)                   | w(z(y))(x)          |
  | v ( y ( w (z) ) ( y (z) ) )       | v(y(w(z))(y(z)))    |
  | x ( v ( w ( z ( y (x) ) ) ) )     | x(v(w(z(y(x)))))    |
  | z (x) ( v ( w (z) ) ( y (x) ) )   | z(x)(v(w(z))(y(x))) |
  | z ( x ( v ( w (z) ) ( y (x) ) ) ) | z(x(v(w(z))(y(x)))) |
  | z ( x ( v ( w (z) ) (y) (x) ) )   | z(x(v(w(z))(y)(x))) |
  ```
- 我列表的數據之後
  我竟然不想做結論了
- 首先
  這裏的侷限性於
  1. 所用的符號都是單個字母
  2. 沒有縮進

## 1 藍

- blue
- 若 z ( y ( x (B) ) ) = z (y) (x)
  則 稱藍
- 例如
  [ [ [ .z (.:y) (::x) ] ] ]
- 若 z y x (B) = z (y) (x)
  則 稱藍
- 例如
  [ .z (:y) (:x) ]
- y ( x (B) ) = [ (y) (x) ]
  也就是說 B 是用來做函數複合用的
  在蟬語中
  函數複合的語法被優化了
  所以 B 有些沒有必要

## 2 藍 與 嘲

- 在 Smullyan 所使用的古典記號中
  在沒有 B 的前提下
  就寫不出來由 M 所找到的
  方程 x (F) = x 的解
- 然而
  我早就可以寫出來
  下面等式中的每一個都是方程的解
  [ (M) (F) ] (M) =
  [ (M) (F) ] (M) (F) =
  [ (M) (F) ] (M) (F) (F)
- 如果想要使用 B 的話
  知道 [ (M) (F) ] = M ( F (B) )
  就行了

## 3 自戀

- 由 M B
  寫出自戀之鳥
- 直接用我的符號就是
  [ (M) (M) ] (M)

## 4 自絕戀

- 由 M B K
  寫出自戀之鳥
- K 所戀者是也
  直接用我的符號就是
  [ (M) (K) ] (M)

## 5 鴿

- dove
- 若
  w ( z ( y ( x (D) ) ) ) =
  w (z) ( y (x) )
  則 稱鴿
- 例如
  [ [ [ [ .w (.:z) ( ::y (:::x) ) ] ] ] ]
- 若
  w z y x (D) =
  w (z) ( y (x) )
  則 稱鴿
- 例如
  [ .w (:z) ( .:y (::x) ) ]
- 問
  知 藍之存在
  何以鴿 D 乎

### 解

- 藍之參數有三
  鴿之參數有四
- 單用 B 所能的到的最簡單的組合子
  B (B)
  即爲所求
- 單用 B 所能的到的最簡單的組合子
  { B (B) }
  即爲所求
- 證明如下
  w ( z ( y ( x ( B (B) ) ) ) ) =
  w ( z ( y (x) (B) ) ) =
  w (z) ( y (x) )
- 證明如下
  w z ( y x B (B) ) =
  w z ( y (x) (B) ) =
  w (z) ( y (x) )
- 在 ( ) 或 { } 內的函數作用
  在參數個數還不夠 就遇到了邊界的情況下
  自動形成 curry
  並且 可以用 "|" 來製造邊界
- 注意
  如果 { } 內根本就沒有約束變元鏈接到這個殼子
  那麼 它就是沒有意義的
  去掉它也行
  但是其實可以利用這種定界來表示 curry
  當 { } 內的函數作用參數不夠時
  就返回一個因 curry  而得的函數
  這在語圖中也是可以體現的
  這樣就可以讓沒有箭頭的大圈
  在語圖中返回被curry了的函數
- 另外不會有需要
  以明顯的方式使用 (curry) 的情況
  因爲 arg fun (curry) = { arg fun }
  但是還是給出 (curry) 這個函數
  並且要知道
  它只能吸收到函數裏一個參數而返回一個函數
  當能吸收更多了的時候需要特殊處理
- 下面考慮這些新的語義在語圖中的形態
  要知道
  因爲 (apply) 是核心的語義 並且不能在語圖中使用
  而 (curry) 正於 (apply) 對應
  它也不能在語圖中使用
  必須找到相應的轉換規則

## 6 黑

- black
- 若
  w ( z ( y ( x (B1) ) ) ) =
  w ( z (y) ) (x)
  則 稱黑
- 例如
  [ [ [ [ .w ( .:z (:::y) ) (.::x) ] ] ] ]
- 若
  w z y x (B1) =
  w ( z (y) ) (x)
  則 稱黑
- 例如
  [ .w ( :z (.:y) ) (:x) ]
- 問
  知 藍之存在
  何以得 B1 乎
- 提示 可用 D

### 解

- B1 = B (D) = B ( B (B) )
- 在語圖中以求解
  就發現 引入了 curry 之後
  函數作用所能形成的
  各種個 curry 非常有意思
- 首先這裏要注意默認的參數順序
  因爲在語圖中已經失去線性的順序了
  如果用明顯的名字的話 一切就都明確了
- 但是又要注意信息的流動方式
  即 函數作用時所提供的 明顯的參數名
  是在函數作用時才指明的
  而在製作無名組合子的過程中
  在寫局部變量的時候
  可能並不知道
  被代入的函數可以使用什麼樣的參數名
- 如果在指明約束變元的地方使用明顯的參數名
  那麼就限制了能夠代入的函數的類型了
- 兩種構造組合子的線性表達式
  可能有不同的參數順序定向
  但是可能會給出同樣的語圖
  所以此時
  在語圖中
  以明顯的方式指定參數的默認順序
  而不依賴定向
  就是重要的了
- 既然已經設計出了用以形成 curry 的語法
  每個語圖寫成完全 curry 時的樣子
  就也是重要的了
  要知道把語圖化成完全 curry
  就能給參數一個序關係
- 反過來說
  在沒有被完全一元化的函數中
  也正是因爲能夠聲明一個約束變元之間的序關係
  過着能夠從線性的文本中推導出一個約束變元之間的序關係
  從而我們才能夠設計出這種靈活的使用 curry 的方法
- 以這個一題爲例
  就能很好地看出這裏所言的序關係的重要性

## 關於具體的例子

- 在設計語言的過程中
  在具體的例子中實踐所設計的語法
  就能獲得很大進步
- 對於其他問題也一樣
  在具體的例子中實踐所學
  就能獲得很大進步

## 關於就函數複合優化語法

- 我發現蟬語中某些語義的清晰性
  只是來自與明顯的把函數作用表示出來而已
  在別的語言中也能利用這種技巧
  而實現這種清晰性
- 蟬語的另一個特點是使用邊綴表達式
  這樣就以明顯的方式
  區分了一個表達式中的函數與參數
- 就別的語言而言
  如果不用邊綴表達式的話
  使用明顯的函數複合的策略有一下幾種
- 首先
  這裏在設計上所收到的限制是
  ascii 碼中可以使用的字符非常有限
- 只考慮被完全一元化的函數
  如同 haskell
  用 空格 來表示函數作用
  用 "." 來表示函數複合
  或
  用 "." 來表示函數作用
  用 "*" 來表示函數複合
  其中 函數複合的優先級高於函數作用
- 考慮使用實際多元函數的語言
  如 lisp
  然而
  由於其對括號完整的前綴表達式的依賴性
  使得在其中很難實現這種語法優化
  然而如果使用邊綴表達式的話就能解決這個問題
  即 把另外的三個括號中的一個拿出來
  作爲代表函數複合的邊綴表達式即可
  例如
  (<fun1 fun2> arg1 arg2)

## 7 鷹

- eagle
- 若
  v w z y x (E) =
  v ( w (z) ) ( y (x) )
  則 稱鷹
- 例如
  [ .v ( :w (.:z) ) ( :y (.:x) ) ]
- 問
  知 藍之存在
  何以得 E 乎

### 解

- E = B1 (B) =  B ( B (B) ) (B)
- 在語圖中做圖求出時
  發現
  在嘗試已有的相的各種組合方式時
  很直觀地就能排除掉某些組合方式
- 增加一些對某些值的計數
  在已給條件下
  解幾乎是唯一的
- 說
  解幾乎是唯一的
  其實是說
  思路是簡單的

## 8

- bunting
- v w z y x (B2) =
  v ( w ( z (y) ) ) (x)

### 解

- B2 = B1 (D) = B ( B (B) ) ( B (B) )
- 由語圖畫之

## 9

- dickcissel
- v w z y x (D1) =
  v (w) ( z ( y (x) ) )

### 解

- D1 = B (B1) = B ( B ( B (B) ) )

## 以對信息的不同編碼方式來解釋不同的模型之間的差異

- 上面這些組合子都被稱爲 複合子[compositor]
  其意皆爲在限制構造新組合子方式的[惡劣]條件下
  給參數所組成的項加括號
  所有的加括號的方式都可以被 B 給出
  即[下面的兩個表達式是古典記號]
  有了
  變 (x y) z
  以 x (y z)
  的組合子
  就能以它爲基礎
  給出所有加括號的方式了
- 因爲
  要知道
  這裏的 B 和它所能產生的各種組合
  所能影響的就只是括號而已
  甚至連參數的順序它們的影響不了
- 如果
  5 4 3 2 1 (X)
  其中 X 是 由 B 而作的項
  那麼其實 B 的作用方式 編碼了一種加括號的方式
  整個表達式的結果
  就相當於以某種方式給參數加上了括號
- 這種編碼的特點是
  解碼很容易
  但是編碼很難
  其部分原因在於
  要三個參數齊備的時候才能消除 B 的作用
  也就是說 curry 的使用在這裏造成了編碼的困難
  最終的問題就是求一個算法
  以算出
  用 B 作用的
  對加括號的方式的編碼
  其實 Smullyan 在對這組問題的解答中
  就[儘管不是以明顯的方式]給出了一個編碼算法
  但是這好像不是一種算法而是一種遍歷
  或者說是一種遍歷算法
  因爲每次解某一個方程的時候
  都需要用到之前解的方程
- 其實給出了一個非遍歷的一般算法
  但是遍歷算法好像更好一些
- 非遍歷的算法也可以被理解爲遍歷性的算法
  只不過遍歷的方式是唯一的
  而遍歷算法就在於
  每當求出一個之前的解之後
  這個解就能在之後被利用
  這就相當於多了一條在遍歷的時候可以選擇的路
  在遍歷性的算法中需要時刻檢驗的是
  在某條路上遇到那些條件之後就不應該再走下去了
- 然而
  蟬語所提供的構造新組合子的方式是豐富的
  是故
  上面各節所引進的
  用 B 構造其他 compositor 的方式並不實用
  只爲練習而已
  故而略過上面的某些例子
- 而
  所謂的用 Y 而作出遞歸函數
  只不過用 Y 來編碼自我作用矣
  想要形成遞歸
  其核心語義是能夠在函數自身之體內引用自身
  避開此核心語義而想以別的方式達到其效果的
  可能也有其具體的用處
  但是其語義勢必不易爲讀者所辨識
  因其曲折轉義耳
- 用以編碼的基本數據結構不同
  對信息的編碼方式不同
  對信息的處理方式不同
  所得到的計算模型不同

## 關於語法設計

- 我已經有使用邊綴表達式的
  用以進行函數作用的基本語法了
  爲了進行一個函數作用
  所需要的信息是
  參數的值
  函數的值
  而在設計與語法以實現這個語義的時候
  有些信息是可以省略的
  不同的語言省略信息的方式不同
  比如 scheme 就是完全不省略信息
  而把所有的值都明確地確定下來
  而別的語言
  可能有複雜的推導部分所需要的信息的方式
- 我已經有最簡單的爲形相互引用的標記語言了
  這種簡單的版本足夠用來實現函數體中的約束變元了
  但是更完善而系統的使用標記語言的方式還有待設計
- 其實所有的函數語言某種意義上都是標記語言
  考慮在其中實現遞歸函數的方式就知道了
  因爲實現遞歸函數就需要自我引用
  也就是說函數名就是標記

## 關於類型系統

- 當函數作用的時候可以使用簡化的表達
  因爲這時如何從簡化了的信息推斷出需要作用那個函數
  其方法是顯然的
  然而
  當把函數作爲一等公民來相互組合時
  只在某些根節點說明其參數的類型
  而去推斷出其他位置的函數的類型
  也是簡單的
  所以說爲了系統地使用簡化過的信息來調用函數
  完整的類型推導是必要的
  但是有些數據的類型只有在運行時才能被知曉
  此時就可以放棄類型推導
  或者利用明顯的類型聲明
  來增加推導過程中可以利用到的基本信息
- 類型推導的結果應該用一個圖示表示出來
  而不是用難讀的文本來描述
- 也就是說在蟬語中能達到的效果是
  所有的用以實現關鍵語義的語法
  都是與各個民族的語言無關的
- 運行時的類型錯誤還是有可能產生
  即當給出
  參數類型 參數名 函數小名
  這些信息之後
  沒法在函數調用數據庫中找到需要調用的函數的話
  就會產生進行時的類型錯誤
- 我是否能實現下面的性質
  即
  只有當這個 函數小名 是真正需要被動態調用的時候
  即 這個小名將可能引起對兩個以上的實際函數的調用的時候
  才去以動態地查詢數據庫的方式來實現函數調用
  當然可以做到這一點
  只要在所有地方都儘可能地使用函數的大名就可以了
- 所以進一步的問題是
  我能不能在所有的地方都使用函數的小名
  而以自動推導的方式達到手動使用大名的效果
- 另外一個可能進行的優化是
  如果我知道了這個地方確實可能調用到兩個以上的真實函數
  但是我還知道了在這裏只可能調用到有限個[比如兩個]真是函數而已
  那麼我就可以避免對數據庫的動態查詢
  而把這兩個函數的調用編譯到函數體內
  這種信息當然能夠以明顯的方式聲明
  那麼 能否自動推導呢
- 也就是說對於函數調用而言
  只有真正涉及到了像對數據庫的處理一般的
  複雜的動態調用的時候
  我才有必要使用對數據庫的查詢
  而其他時候我都能進行不同程度的優化
- 這裏的設計哲學是
  保持能夠以明顯地聲明的方式
  來控跟制程序的運行有關的各個細節的能力
  然而細心設計語法和語義
  以致
  在這所有可以被手動聲明的信息當中
  即使不手動以明顯的方式聲明
  語言的編譯器[信息推導器]也能夠推導出其中絕大部分的信息
  並且
  在這二者的平衡之間
  要找到
  最能減輕代碼的閱讀者的認知負擔的
  那一點

## 13 14 15

- warbler
- y x (W) = y ( y (x) )
- W K 以求 M
  x (M) = x (x)
- 先
  W I 以求 M
  I (W) 是也
  再
  W K 以求 I
  K (W) 是也

## 16

- cardinal
- permute
  permuting
- z y x (C) = y ( z (x) )
  C K 以求 I
  K K (C) 是也

## 17

- thrush
- y x (T) = x (y)
- C I 以求 T
  I (C) 是也

## 關於中綴表達式

- 如果按古典的記法
  x y z 其實是以空格爲中綴表達式來代表函數作用的
  然而函數作用
  作爲一個沒有不結合的運算
  根本就不應該用中綴表達式來表示
  這就是蟬語把所優化的語義從函數作用轉爲函數複合的原因
  x (F) 爲作用 (F) (G) 爲複合
  這樣就在表達式中體現了運算本身的性質
- 也就是說
  自然看來蟬語的符號應該在表達方面有優勢
  但是在關於 B 的問題中卻發現
  其實古典的符號更有優勢
- 其實也許只是觀察角度的不同而已
  在蟬語的符號
  我也可以給出對算法的推導
- 確實如此
  並且在語圖中也很有意思

## 18 交換

- commute
- 若
  x (y) = y (x)
  則稱 x y 相交換
- 問
  若
  知 林之戀戀然
  知 T 之存在
  則
  有組合子與衆組合子皆相交換 邪

### 解

- T 所戀者是也
  知之 X (T) = X
  則
  y (X) = y ( X (T) ) = X (y)

## 19

- B T M 以求 X
- 因 有 B M
  而 可求 x (T) = x 之解也

## 20

- robin
- venetian

## 語義

- 當認爲找到了基本而簡單的模型之後
  就嘗試着把所有的其他抽象語義都解釋於這個模型
  看看有什麼新的發現
- 而這裏的基本模型就是有向圖
  1. 組合子的空間所形成的有向圖
  2. lambda 的向圖
     其二者中
     作用都被理解爲在圖中移動
  3. 語圖
  4. 新的標記語言
- 在圖中的行走就代表了計算
  當把一個點視爲一個路的時候
  比如
  一個被返回的無名函數[比如curry的]
  而再次作用與某個參數的時候
  這個無名的點所對應的路
  其實是
  由以達到這個無名的點的軌跡
  即
  當千辛萬苦走到一個節點
  而想把這個接連作爲路重新作用與一個點時
  其實被用來作用的
  就是走到這個點時所經歷的歷史
  這段不完整的歷史被施加在新的節點上
  以回到某個真正的有名節點

## 分類

- 其實這裏已經有對組合子的很多分類了
  - 分配括號的由 B 產生的
    這裏 由所發現的算法
    還能得到對這裏組合子的表示
  - 置換其在古典的記號中所得到的線性順序的
  - M L W 之類讓某個元素重複的
  - K 之類消減維數的

## 變形

- 其實
  在使用了豐富的構造方式之後
  這裏很多問題的性質就改變了
  求解一個在更苛刻限制下的表達式
  就變爲了
  把風格自由的表達式
  化爲規範類型
  或者說化爲具有某種特殊性質的圖形

# Curry Paradox

# 嚴

- 我發現 Smullyan 所使用的語義有時並不嚴格
  甚至有些隨意
  因爲在前一章使用
  鳥在某一天叫 來比喻 命題的真
  而在后以章就又以
  鳥在能叫 來比喻 命題的真
  前者可能是爲了模擬集合論的語義來
  以方便的方式說明蘊含關係
