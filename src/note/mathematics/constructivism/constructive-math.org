#+title: constructive math

* >< the meaning is use -- progmatic

* constructivism

*** 無限概念之有限處理

    - 人們想像無限之物
      但是描述這些想像時所用語言確實有限的
      1. 無窮級數
         雖然有無窮多項
         然而項有規律可循
         所以用有限的語言就能指明這無窮多的項是那些
      2. 連續的幾何體[拓撲空間]
         雖然形態萬變
         但是有等價關係用以捕捉這些變化
         在某種等價關係的意義之下
         我們有對其形態的分類定理
         又揭示了 看似無線的對象中 有限的規律
      3. 實數中
         實際用於計算的
         都是以有限的方式就能構造出來的數

*** dangerous principles

    #+begin_src cicada
    principle of omniscience

    (or (-> a : A -- a P)
        (-> -- b : A, b P not))

    principle of excluded middle

    (or A not, A)

    principle of double negation

    (-> A not not -- A)
    #+end_src

* 新構造主義

*** >< 構造主義四原則 [bishop]

*** 新原則

    - 抽象的數學結構 最好從其具體例子學起

    - 沒有豐富例子的抽象結構 值得質疑其作爲數學理論的存在價值

    - 每個違背 直覺 且不利實用 的概念與定理 都值得商榷

    - 所用語言最好能揭示 計算意義 之強弱

*** 具體數學結構

    - 具體數學結構 集合 類型 爲近義詞

    - 抽象 與 具體 有別
      1. 抽象數學結構
         用公理定義 公理描述結構中關係的性質
         比如羣
         範疇論 專門研究抽象數學結構之間的關係
      2. 具體數學結構
         由具體的表示定義
         比如某個有限單羣

    - 構造主義數學中 定義集合 步驟有二
      正如在程序語言中定義數據類型
      1. 首先 說明 如何構造集合中的元素
         正如 用已有的基礎數據類型 和 構造新類型的手段
         來構造新數據類型
         - 動態類型語言
           這裏將有一個謂詞來判斷
           某個元素是否屬於這個新定義的類型
           靜態類型語言
           不必有這種謂詞
         - 當需要定義一個新數據類型時
           可能有很多種實現方式 都能達到所需要的特性
           實現方式不同
           即 基礎類型 和 構造手段 之選取不同
           實現方式決定 底層操作[operation]
      2. 其次 說明 如何判別集合中的兩個元素之相等
         即 每定義一個數據類型時
         都要輔以等詞 才算定義完備
         保持等詞的變換稱 函數[function]
         - 當寫出一個 底層操作 後
           往往需要額外討論
           才能確信它保持等詞 而爲函數

    - 等詞分層次
      等詞之間的關係總是相對的
      用 底層的等詞 定義 高層的等詞
      就像是 用 素函數 定義 函數
      畢竟等詞本身就是函數

*** 相對性原理

    - 沒有絕對的素性 [primitive]

*** 結構化的無窮小分析

    - 比如對實屬這個類型的定義
      (-> x : (<number> -> <fraction>)
      (m n : <number> ->
      (n x m x sub abs
      1 n div 1 m div add
      less-then?)))
      ==
      (-> x : <real>)

    - 定義類系時 要同時定義等詞
      (-> x : <real>
      y : <real>
      (n : <number> ->
      (n x n y sub abs
      2 n div
      less-then?)))
      ==
      (-> x : <real>
      y : <real>
      (x y real:equal?))

    - 當 計算 在命題[類型]中 出現時
      它們只是代表 真實計算 的符號
      符號組合而成命題
      符號之出現 只爲討論符號所代表的計算的性質
      這種對符號的處理 在類型棧中進行
      而真實計算 在參數棧中進行

*** >< 謂詞

    - 上面對 等詞 的定義顯示
      等詞 的 函數體
      既用於計算 又用於形式處理

    - 定義謂詞的函數體
      既是命題
      又是函數
      這與通常的
      類型對命題
      函數對證明
      並不相同

*** 實數集上的函數

    - 按照 bishop 的方式
      一個實數 被實現爲一個函數
      實數集上的函數就成了函數到函數的映射
      這是不合理的

    - 實際上
      連續函數在有理點的值
      決定了其在實數集上的值
      - 這種函數是用處最廣的
        概率論 可能用到這個範圍之外的函數
        因爲那裏要用積分計算平均值
        而函數在某一點的值並不影響其平均值

    - 超越的常數
      應該由超越函數給出

    - 在推理中
      函數之間的關係才重要
      對函數的實際計算 與計算的效率 是另外一個層次的事情

    - 推理 對 函數之間關係
      計算 對 函數之實現方式

    - bishop 在處理實數時
      當給實數以構造性的定義之後
      就爲了推理的優雅
      而直接把 ><><><
      並沒有考慮到
      這些定義還可以爲了計算和推理效率而優化

      - 這裏所謂的 優化 如何理解
        改變處理方式之後
        整個理論看來更具有更造性和實用價值了
        但是這裏我潛意識裏裏使用的判斷標準是什麼

*** 更合適的基點

    - 只描述函數與函數之間的關係
      而重新獲得算數化的無窮小分析的表達能力
      同時獲得更好的計算語義

*** 相對否定

    - 否 不做爲一個一元邏輯連詞
      因爲它不具有構造性

    - 否定總是相對的
      如果一個命題蘊含了荒謬的命題
      那麼這個命題本身就是更荒謬的

*** 謂詞的幾何性質

    - 對於 形式體系 這種數學結構
      形式語法 生成有向圖
      而 謂詞 對應於 有向圖中 某種離散的幾何體

    - 最明顯的就是 等詞 對應於 無向路

    - 對於 其他類型的數學結構
      也可能有類似的對應

*** 參數棧 與 類型棧

    - 兩個棧是自然的選擇
      就像在通常的 具體數學結構 中一樣
      我們
      有時需要操作數學結構中的元素 以計算
      有時需要討論數學結構中的元素的類型 以證明一般性質

    - 通常 程序在運行時只用到了 參數棧
      而 類型棧 只用於編譯時期的類型檢查
      而 類型檢查 就是對具體結構中元素[函數]的一般性質的證明

*** >< 不同層次的等詞和關係 如何轉換  :難點:

    - 看 dijkstra

*** 雜

***** 意義

      - 關於 意義[meaning] 的形而上學
        有很多流派
        來源有二 [以函數爲例]

        - 宏觀
          函數之意義在於
          它與空間中所有其他函數的關係
          [關係是利用函數複合這個基本關係來表達的]
          形而上者
          一個詞的意義
          在於它如何在語言中被使用

        - 微觀
          函數之意義在於
          它具體對數據進行的操作
          形而下者
          界定一個詞意義的方式
          並不是窮盡它在語言中的所有使用方式
          而是使用巧妙的編碼與構造

      - 通過 參數棧 這個交換參數的市場
        只要給出了函數微觀意義 就獲得其宏觀意義
        宏觀意義 這個概念 是用靜態類型檢查實現的

***** general proof theory

      - 以 proof 爲自足的數學對象
        每每如此時
        只爲獲得認可而已
        只得弱化其用而已

      - 所謂 consequence vs. proofs 在於
        認爲
        古典的處理方式
        以 proofs 分析 consequence
        而不以 proofs 爲基本數學對象
        其實
        當用 則詞 來展示 consequence 時
        就沒有這種衝突了

***** 等詞

      - 兩個 proof 如何相等
        兩個 function 如何相等
        這些等詞的定義都很難處理

      - 當等詞難以處理時
        就感覺數學對象虛無縹緲
        難以把握 不像實體

      - 解決辦法是
        爲更易計算的等詞
        而優化模型[具體數學結構]

*** 避免過早代入數值

    - rational trigonometry 就是如此

*** 對自然數集這個具體數學結構的觀察計劃

    - 語法方面 也許需要設計高度重載的記法
      語義方面 主要是對結構的擴展
      1. 擴張
         逆運算封閉
      2. 拓展
         序關係重新引入

    - 分析素數
      p-進數
      看看能否有新的啓發

    - 關於結構的擴展
      galois 理論

    - 結構的計算性
      初等函數的算數性質
      構造主義
      古典數值計算

    - 關於記法
      一般語言學
      可以以幾何的語法爲範例

*** dup

    - dup 類型棧中的一個則式
      就像是重複一次可重複的實驗一樣

    - intentional equality
      連個構造是否相同
      取決於人們的意願

* 數學結構

*** 認識與認識論

    - 一個人對自然的所有感受
      與思維對這些感受的處理
      是一個人存在的全部
      感受與處理就是認識

    - 在這個模型中
      人無異於一個有學習能力的機器

    - 否定觀察到的現象有其自然的絕對原因

*** 方法與方法論

    - 理性在於 用模型[結構][系統]
      來對所觀察到的現象之規律性加以總結

    - 人們認識到每個被建立起來的模型有其侷限性
      並且認爲這種侷限性並不構成對認識的限制
      因爲總可以建立新的模型

    - 否定理性所得的抽象模型是認識的目的

    - 否定某個模型具有絕對中心地位

    - 統計規律的總結 與 因果的邏輯之間有什麼關係

*** 認知行爲的基本模型 [模仿索緒爾]

    - 以思想概念爲單位 認知過程在於 找尋思想概念之間的關係
      [用集論的術語 可以說 使思想感念的集合形成結構]
      [><><>< 爲什麼 集論 有這種術語 而類型論沒有]

    - 思想概念的形成是多樣的
      因爲感官是多樣的

    - 思想概念所形成的體系是複雜的
      因爲可以有很多層次結構

    - 邏輯命題描述的是結構的一般性質
      這種 一般性 或 普遍性
      是哪裏來的
      是來自量詞 那麼也就是來自依賴性

    - ><><>< 邏輯規則獨立與數學結構嘛

    - 把數學劃歸爲神經科學
      因爲數學是一個典型的認知過程

*** 一個人的知識越多 這個人的生命就越不以存在爲目的

*** 空間爲什麼有三維 [龐加萊]

    - 沒有一種感覺不藉助於其他感覺就能向我們傳達空間的觀念
      也沒有一種感覺不傳達大量與空間無關的信息

    - 因爲
      我們在三維空間中運動的同時
      能夠獲得二維視覺信息
      所以
      當我們再看到一個二維視覺信息時
      我們就能想像出我們運動時它的變化

*** 索緒爾

    - 人的能力
      1. 對感受的記憶
      2. 把感受與感受相聯繫
      模型中 還缺少什麼

    - 禮儀和習慣是行爲的符號

    - 符號的不變性與可變性
      演化的穩定性與突變的存在

    - 語言的存在與演化
      石塊的存在 適應物理能量 [高壓即毀滅]
      細菌的存在 適應生物圈
      語言的存在 適應 什麼
      交流方式之間的競爭嘛

    - 爲了更好地表明有關同一對象的兩大秩序的對立和交叉
      不如分別命名以
      共時語言學 synchronie [信息論]
      歷時語言學 diachronie [演化]

* 構造主義方法中的難點

  - 構造主義的證明論中
    常常說 想要證明一個東西存在
    就要給出構造這個東西的方法
    在討論這個看似是常識的想法時
    人們常常關心由此形成的推演系統的抽象性質
    而忽略了如何使用這一想法
    利用這一想法所啓發的思考角度
    去觀察古典定理與古典證明
    bishop 在分析學中做了這種嘗試
    但是其實在比分析學更爲初等的數論中
    構造主義的觀察角度所得到的觀察結果
    也還從沒有得到系統地總結
    我以一些古典的定理與證明爲例
    討論構造主義的難點

  - [fermat 小定理]
    (1)
    ((a : non-zero) (p : prime) -> (a ^{p} = a (mod p)))
    又因爲 a 與 p coprime
    因此有 (a ^{p-1} = 1 (mod p))

    證明
    在 (mod p) 的語境下
    a * 2*a ... (p-1)*a = 1 * 2 * (p-1)
    a^{p-1} * (p-1)! = (p-1)!
    a^{p-1} = 1
    證完

  - fermat 小定理 可以用來否定一個數是素數
    但是做出這種否定的同時
    又不能給出這個合數的因子分解
    看似我們有如下的逆否命題
    (2)
    ((a : non-zero) (a ^{p} = a (mod p)) -> (p : composite))
    可以觀察到難點在於 prime 與 composite 的定義

  - 考慮如下的定義
    (p : composite) := ((x, y : non-trivial) (x * y = p))
    (p : prime) := ((p : composite) -> unlikely)
    這種定義下 prime 本身已經帶有一層否定了
    而在古典數學的敘述中 這層否定是不明顯的

  - 再考慮如下 fermat 小定理 的逆否
    (3)
    ((a : non-zero) (a ^{p} = a (mod p)) -> (p : prime -> unlikely))
    即
    ((a : non-zero) (a ^{p} = a (mod p)) -> ((p : composite -> unlikely) -> unlikely))
    就定義的強度而言
    有 (2) > (1) > (3)
    古典的證明只證明到 (1)
    而構造主義要求 (2)
    即 不給出構造 也能否定一個數是素數
    但是並不能 '證明' 這個數是合數

  - 結論是
    一個命題或證明的計算意義的強弱
    在構造主義的方法下 是可以明顯體現出來的
    而構造主義本身的目的就是要設計語言
    來方便地描述[或者說 度量]
    命題或者證明的計算意義之強弱

  - euclid 定理 常常被認爲是證明了
    the set of prime numbers is infinite
    如下我們可以展示 定義了 finite 與 infinite 之後
    定理可以分爲兩種強度
    (1) ((prime : finite) -> unlikely)
    (2) (-> (prime : infinite))
    就強度而言 (2) > (1)
    而 euclid 所證明的是 (1)

  - 考慮如下的定義
    (prime : finite) := (f : (fin -> prime)) [f 爲雙射]
    (prime : infinite) := (f : (nat -> prime)) [f 爲單射]
    [euclid 就是就某個 fin 的例子 (即有三個元素的集合) 來證明 (1) 的]

  - 我們可以很容易找到雙射 (f : (nat -> prime))
    儘管算法的效率可能非常低

  - 結論是
    與 prime 有關的不具有構造性的命題非常多
    同時 與 prime 有關的實用算法也非常多
    當設計 構造主義的語言 時
    就可以以這裏命題與算法爲例子

* 可構造性的譜系

  - x -
    (1) 可以構造出來的東西
    (2) 假設可以構造出來的東西 還有這些東西上的操作
    爲什麼說 微分幾何中定義流形的方式
    只是在考慮假設可以構造出來的東西

  - k -
    但是要知道
    這種考慮其實有主觀的一面
    即 如果這個構造方式非常複雜
    在發展理論的時候
    人們就不給出實際的構造 而只是假設構造存在
    其實這些東西也是可以構造

  - x -
    也就是說
    我們應該 用簡單的構造代替複雜的構造
    使得人們能夠常常考慮構造的例子
