---
title: Category Theory for Programmers
---

# Category Theory for Programmers

------
- Author: Bartosz Milewski
------

Notes taken from video lectures,
the chapter naming of which is different from the book.

- Source of the book: https://github.com/hmemcpy/milewski-ctfp-pdf
- Source of the video lectures:
  - Part I: https://www.youtube.com/playlist?list=PLbgaMIhjbmEnaH_LTkxLI7FMa2HsnawM_
  - Part II: https://www.youtube.com/playlist?list=PLbgaMIhjbmEn64WVX4B08B4h2rOtueWIL
  - Part III: https://www.youtube.com/playlist?list=PLbgaMIhjbmElia1eCEZNvsVscFef9m0dm

## Note

- **[Xie]** One interesting feature of the teaching of the lecturer is that
  we do not emphasize the historical notes too much,
  but always re-construct the process of development from basic principles.
  By teaching in this way, student starts to think independently
  instead of appealing to authorities.

## I 1.1 Motivation and Philosophy

## I 1.2 What is a category?

Category is about object and arrow (morphism) and composition of arrows,
think of them as type and function and composition of functions.

``` js
f(A): B
g(B): C
(x) => g(f(x)) : (A) -> C
```

Category theory is about composition.

Category theory is also about identity.

The reason for having object is so you can type arrows.

Objects do not serve any propose other than identifying ends of arrows.

From category theory's view object has no structure.

We have mathematical structures like `set_t`, `group_t`, `vector_space_t`,
to define them in the language of category theory,
we must not reach for the concrete structure of their objects.

We must define mathematical structures by describing the relations between their objects,
and the relations we can describe are all equations about arrows.

- **[Xie]** We describe properties only by interface functions of abstract class.

## I 2.1 Functions, epimorphisms

A function is pure if you can memorize it and turning it into a lookup table.

The basic building blocks of programming are types and functions they form a category.

Take example properties from set theory
and limit the language to arrow equations
to translate such properties to category theory.

## I 2.2 Monomorphisms, simple types

## I 2.3 What Are Types?

We can make use of the set theoretical interpretation of type.
but the problem is polymorphic functions that involve circular definitions.

## I 3.1 Examples of categories, orders, monoids

Free category generated by a given graph.

It's an example of a free construction,
a process of completing a given structure
by extending it with a minimum number of items
that satisfy its laws (here, the laws of a category).

When view preorder as category, an arrow is not a function, but a relation.

Preorder is thin category, homset have 0 or 1 elements..

We can view category as generalized preorder, in which homset can have more elements.

- **[Xie]** We can have different proofs of the relation `pre_t`.

Monoid is like pre-group.

Monoid is category with only one object,
thus every two arrows are composable.

We can view category as generalized monoid, in which there can be more objects.

We can view preorder as category, or monoid as category.
We can view category as generalization of preorder, or generalization of monoid.

- **[Xie]** Viewing preorder as category,

  ``` js
  impl preorder_t {
    elem_t: type
    ...
  }

  develop preorder_t {
    as_category = new category_t {
      object_t = elem_t
      ...
    }
  }
  ```

  is different from study the category of all preorders,

  ``` js
  preorder_category: category_t = new category_t {
    object_t = preorder_t
    ...
  }
  ```

## I 3.2 Kleisli category

Objects of a category can be types,
while arrows between `a`, `b` can not only be functions of type `(a) -> b`,
but can also be functions of type `(a) -> (b, string_t)` by redefining composition.

- The `string_t` can be replaced by any `monoid_t`.

This technique can be used to implement logger.
- We can also use global variable to implement logger,
  but using global variable will increase complexity of the code base in a hidden way.
  Also when we need to use multiple core,
  we would have to add global lock to the global variable.

## I 4.1 Terminal and initial objects

One view is that a set is a thing that has elements.
Another view is to not talk about elements, but to talk about arrows.

We can begin with study structure implemented set theory,
then abstract the interface of the structure and forget about elements.

The general method of doing this is called **universal construction**.
It is like googling a pattern (described by arrows),
searching for all hits matching the pattern, and rank them.

Take singleton set as an example,
it is the `unit_t` type in type theory,
from any type `A` there is a function of type `(A) -> unit_t`.

But this is not enough to pin down singleton set yet,
because set is rich in arrows, for any set `X`, as long as it is not empty,
forall `A` there is a function of type `(A) -> X`.

We need to say the arrow from `A` to `unit_t` is unique, to pin down singleton set,
and we call such object **terminal object**.

Not metter what path you take to the terminal object, the path is always the same.

The `unit_t` type has this property,
but even we just add one element to it to get `bool_t`,
the set of paths to `bool_t` will be much more completed,
which is the set of all predicates.

The next question we should ask is how many terminal objects are there?
Terminal object is not unique.
Terminal object is unique up to unique isomorphism.

Actually, to express uniqueness of terminal object,
we need equivalence relation between objects,
but in category we can not use this equivalence relation.
We can compare arrows for equality, but we can not compare objects for equality.
Thus we can only ask for isomorphism between objects.

- **[Xie]** Is it true that we can not use the equivalence relation between objects?
  Maybe we can, but it is just that for universal construction,
  uniqueness expressed by the equivalence relation between objects is too strong,
  for example, product set `A * B` is not equal to `B * A`,
  but `A * B` is isomorphic to `B * A`.

The terminal object as an universal construction,
- The pattern is single object.
- The ranking is that `A` is better than `B`, if there is a unique arrow from `B` to `A`.
  - Note that the ranking is not total but partial order.
the terminal object is the best of such pattern.

An arrow from the terminal object `unit_t` to another object `X`,
can be viewed as picking up an element in `X` (if we view the object `X` as set).

## I 4.2 Products

The **product** of object `A` and `B` as an universal construction,
- The pattern is an object `C` and two arrow `p : C -> A` and `p : C -> B` (`p` for "projection").
- The ranking is that `(C, p, q)` is better than `(C', p', q')`,
  if there is a unique arrow `m : C' -> C` such that
  `p' == compose m p` and `q' == compose m q`,
  `p'` and `q'` have common factor `m`,
  the factor `m` take out the bad part from `p'` and `q'`,
  after which `p` and `q` will be good projections.
the product of object `A` and `B` is the best of such pattern.

- **[Xie]** We need to imagine the picture of the arrows to understand a construction.

- **[Xie]** Is it true that when factoring our programs,
  we have `p'` and `q'`, and we want to factor them into `compose m p` and `compose m q`.
  after which all functions (of type `C -> X`) we developed of `C` can be used for `C'`.

For example, bad candidates,

``` haskell
C = (int_t, bool_t)
p (x, b) = x
q (x, b) = b

C' = int_t
p' = id
q' = true
m : int_t -> (int_t, bool_t)
m x = (x, true)

C' = (int_t, int_t, bool_t)
p' (x, _, _) = x
q' (_, _, b) = b
m : (int_t, int_t, bool_t) -> (int_t, bool_t)
m (x, y, b) = (x, b)
```

- **[Xie]** The uniqueness of arrow `m : C' -> C` will help us to define operators in category,
  such as cross of two morphisms, for `f : A -> B` and `g : C -> D`,
  we can define `f * g : (A * C) -> (B * D)`,
  we needed the uniqueness, because to define functions (operators)
  the relation between arguments and return value must be univalent.

## I 5.1 Coproducts, sum types

The **coproduct** of object `A` and `B` as an universal construction,
is the dual of the construction of product,
- The pattern is an object `C` and two arrow `i : A -> C` and `j : B -> C` (`i` for "injection").
- The ranking is that `(C, i, j)` is better than `(C', i', j')`,
  if there is a unique arrow `m : C -> C'` such that
  `i' == compose i m` and `j' == compose j m`,
  `i'` and `j'` have common factor `m`,
  the factor `m` take out the bad part from `i'` and `j'`,
  after which `i` and `j` will be good injection.
the coproduct of object `A` and `B` is the best of such pattern.

``` haskell
data either_t A B
  = left A
  | right B
```

- **[Xie]** Remember that,
  seeking for interpretation of universal construction in programming language,
  is the same as seeking for interpretation in set theory.

## I 5.2 Algebraic data types

If we view datatypes as elements,
product type as `*` operator,
sum type as `+` operator,
isomorphic (set theoretical) as equivalence relation between elements.

- For example `A * B` is equal to `B * A` because there is a isomorphic between them
  `swap : (A * B) -> (B * A)`.

Then what is the algebraic structure of datatypes?
Is it a ring?
(Remember we use isomorphic as equivalence relation.)

We will see that (datatype, product) form a monoid,
and (datatype, sum) form a monoid,
and product is distributive over sum.

It is not a ring, because sum has no inverse.
It is thus a semiring (or "rig", "ring" without "n" (negative)).
- https://en.wikipedia.org/wiki/Semiring

Let us take (datatype, product) for a walk,
- product is commutative `A * B == B * A`,
  `swap` can be defined by simple pattern matching,
- product is associative `(A * B) * C == A * (B * C)`,
  `product_associative` can be defined by simple pattern matching,
- product has identity element, the `unit_t` type,
  `unit_id_left` and `unit_id_right` can be implemented by simple pattern matching.

Actually all the functions we need to define to verify the algebraic laws,
can be implemented by simple pattern matching.

The pair (datatype, sum) is the same,
in which the identity element will be `void_t`,
and forall `A`, we have `A + void_t == A`.

We also know `A * void_t == void_t`.

We also know `A * (B + C) == (A * B) + (A * C)`.

Examples,

``` haskell
data maybe_t A = nothing + (just A)
-- maybe_t A = 1 + A

data list_t A = null + (cons A * (list_t A))
-- list_t A = 1 + A * (list_t A)
-- list_t A = 1 + A * (1 + A * (list_t A))
-- list_t A = 1 + A  + A * A * (list_t A)
-- list_t A = 1 + A  + A * A * (1 + A * (list_t A))
-- list_t A = 1 + A  + A * A + A * A * A * (list_t A)
-- ...
```

- **[Xie]** During transformation of equations,
  the lecturer also used subtraction and division,
  the transformation seems still valid,
  as long as the resulting equation does not contain subtraction and division.

  This feels like using neutral expression in normalization by evaluation.

  We know that the validity of such transformation can be used to extend the algebraic structure,
  maybe the validity of neutral expression can also be used to extend the structure of type theory.

  In the extended theory the neutral expressions will be first class object.

## I 6.1 Functors

Functor is about recognizing pattern of structure in another category.
Functor is about recognizing one category in another category.
Functor is about mapping between two categories.

We generalize function between sets to functor between categories (mappings which preserve structure).
- Sets are structure-less, which is partly the reason why it is hard to implement set in computer.

A category with no structure is a category with no arrows, which is called discrete category.
Which can be used to model set.
If the category is also small, it is exactly set.

Since structure is expressed by arrows,
functor between categories (mappings which preserve structure)
must also describe how arrows are mapped,
and "preserving structure" means respect composition of arrows and id arrow of object.

Category formalize the concept of structure.
Functor formalize the concept of construction that preserving structure.
Functor is like continuous map, connected construction is still mapped to connected construction.

Faithful functor is defined as been injective on all homsets.
Full functor is defined as been surjective on all homsets.
(The mapping behavior on object does not need to be injective or surjective.)
We can also define fully faithful functor as both faithful and full.

Functor of type `functor_t(singleton_category, C)` can be used to pick up object in `C`.
Functor of type `functor_t(C, singleton_category)` is called constant functor.

We define `endofunctor_t(C) = functor_t(C, C)`.

In programming language, a unary type constructor is endofunctor of the category of datatypes.

## I 6.2 Functors in programming

In haskell `Functor` is endofunctor of types.

For example, array-like collections (or say, containers) are instances `Functor`.

``` haskell
type reader_t R A = R -> A
```

when fix `R`, `reader_t R` is a `Functor`.

## I 7.1 Functoriality, bifunctors

In the category of category, an object is a category, a morphism is a functor.

Example of composition of functors,

``` haskell
tail : list_t(A) -> maybe_t(list_t(A))
tail null = nothing_t
tail cons(x, xs) = just_t(xs)
```

All algebraic datatypes are functors,
in categorical semantics functors (initial algebra) can be used to model algebraic datatype.

The product `(a, b)` is called bifunctor, which means when fix one argument, it is a functor.
Bifunctor can also be defined as functor from product of two categories to a category `(A * B) -> C`.

``` haskell
bimap : [f : (type, type) -> type] ->
  (A -> A1) -> (B -> B1) -> f(A, B) -> f(A1, B1)
```

Note that, the canonical sum type `either_t(A, B)` (co-product in category) is still bifunctor,
we do not need sum of two categories to view it (co-product in category of category),
we only need product of two categories (product in category of category).

## I 7.2 Monoidal Categories, Functoriality of ADTs, Profunctors

In monoidal categories, we would like to multiply two object (to return an object),
bifunctor is what we need.

In monoidal categories, we can define tensor product, which has unit and associative.

The ADTs without type arguments can be viewed as constant functor.

For the function type `A -> B`,
fixing `A` we get `A -> _`, which is covariant functor (normal functor),
fixing `B` ww get `_ -> B`, which is contravariant functor.

``` haskell
function_space : (op(C) * C) -> C

dimap : [f : (type, type) -> type] ->
  (A1 -> A) -> (B -> B1) -> f(A, B) -> f(A1, B1)
```

The `function_space` above is called profunctor.

## I 8.1 Function objects, exponentials

In programming, we work with category of sets,
objects are sets, and for two objects `A` an `B`, we have `homset(A, B)`,
since a `homset(A, B)` is also a set, it is also an object of our category.

This means our category has function objects (or say exponentials).
(Not every category have this good property.)

We can define exponential objects by universal construction
(thus generalize the concept to arbitrary category).

We need product to define exponential.

- **[Xie]**
  The exponential object can not be defined as limit of shape,
  but should be defined using adjoint.

The **exponential object** from `A` to `B` as an universal construction,
- The pattern is an object `C` and an arrow `g: (C, A) -> B`.
- The ranking says, `C` is better than `C'` and `g': (C', A) -> B`,
  if there is a unique `m: C' -> C` such that
  `compose (m * id(A)) g == g' : (C', A) -> B`,
  where `(m * id(A))` is a cross of two morphism `m: C' -> C` and `id(A): A -> A`.
the exponential object from `A` to `B` is the best of such pattern.

We can also view `m: C' -> C` as `m: C' -> (A -> B)`,
then from `g': (C', A) -> B` to `m: C' -> (A -> B)`
is called currying in programming.

A programming language can has currying built-in (such as Haskell).

**Cartesian closed category** is defined as
category with terminal object, product object and exponential object.

**Bi-Cartesian closed category** is defined as
Cartesian closed category with initial object and sum object.

## I 8.2 Type algebra, Curry-Howard-Lambek isomorphism

The "-Lambek" in "Curry-Howard-Lambek" means extends Curry-Howard isomorphism to category theory.

## I 9.1 Natural transformations

Natural transformation is mapping (morphism) between functors,
which enable us to describe relations (universal constructions) between functors,
just like morphism enable us to describe relations between objects.

A lot of specifications of commuting diagram,
can be expressed by natural transformation.

If functor `F` can be transformed to functor `G`,
we can say `F` has higher resolution than `G`.

Natural isomorphism is like natural transformation,
but the components are isomorphisms.
(Natural isomorphism will be used to define adjunctions.)

In programming, we think about endofunctor of the category of types.
The component function of a natural transformation between such endofunctors
will be functions of type `F a -> G a`.

When functor is a container,
natural transformation re-package content of container.

Such polymorphic function defined in Haskell is automatically natural.
`head :: [a] -> Maybe a` is such an example,
`unit_list :: a -> [a]` is a more simple example (id functor),
`length :: [a] -> Nat` is a special simple example (const functor).
(All algebraic datatypes are functors.)

## I 9.2 Bicategories

Let's talk about category theory in a really wild area,
push the view of category theory to as far as we can.

Every time we see mappings or arrows, we ask can we compose them.

- **[Xie]** We try hard to observe pattern of structures.

- **[Xie]** Composing commuting squares is composing equation of morphisms.
  `a b == c d` and `d e == f g` compose to `a b e == c f g`.

We can extends `category_t` to `strict_two_category_t`
by enrich the structure of homset with category.

- **[From The Catsters]**
  Since natural transformation is morphism in some category, we can compose them.
  We have functor category, `C, D : category_t`,
  `functor_category_t(C, D)` is a category,
  where `object_t = functor_t(C, D)`
  and `morphism_t(f, g) = transformation_t(C, D, f, g)`.

The `functor_category_t` is defined,
and they are exponential objects in category of categories,
which means `strict_two_category_t` is Cartesian closed.

From `strict_two_category_t` we can define `bicategory_t`,
by not to use equality between morphisms,
but to use isomorphism between morphisms in `functor_category_t`
to describe laws like associativity.

Because of complicated coherent laws occured in n-category,
we study n-groupoid where such coherent laws are simple.

- **[Xie]** We need an example to demonstrate
  how coherent laws of n-category are complicated.

## I 10.1 Monads

Monad is about specifying new ways to do composition,
i.e. composing `A -> M B` with `B -> M C` to get `A -> M C`,
i.e. `(>=>) : (A -> M B) -> (B -> M C) -> (A -> M C)`,
i.e. composition of Kleisli arrows.

But just like in normal programming,
always using composition is not convenient,
it is also not convenient in monad programming.

This is why we re-factor composition to `bind` a.k.a. `(>>=)` (a.k.a. `flatMap` in Scala.),
i.e. `(>=>) : (A -> M B) -> (B -> M C) -> (A -> M C)`,
can be defined by `(>>=) : M B -> (B -> M C) -> M C`.

`(>>=)` can be defined by `fmap : M A -> (A -> B) -> M B`,
and `join : M (M A) -> M A`. (`join` is called `flatten` in Scala.)

If we already have a functor we can extend it to a moand,
by defining `join : M (M A) -> M A`
and `return : A -> M A`.

- And `join` and `return` are the interface functions used in category theory,
  when we talk about monad.
  `join` is called `mu`, which is a natural transformation from `M M` functor to `M`,
  `return` is called `eta`, which is a natural transformation from the `Id` to `M`.
  Thus a monad is a functor `M` and two natural transformations,
  plus associativity of the endo-functor composition of `M`,
  `(M M) M == M (M M)`.

Monad can be used to model side-effect to keep the language pure.

Non-pure function can be translated to pure function
by making the return type more complex.
Moand comes in, when we need to compose pure functions.

## I 10.2 Monoid in the category of endofunctors

> A monad is just a monoid-object in the monoidal-category of endofunctors,
> where in the monoidal-category tensor-product is functor composition,
> thus a special endofunctor, with two morphisms `join` and `return`.

How to define monoid without talking about sets?

A monoid can be viewed as a special category with only one object ,
elements of monoid are endo-morphisms,
but this is not enough, because we are still taking about set of endo-morphisms.

If we think about what is monoid in the category of sets,
we can generalize the monoid to **monoid-object** of any category.

First we have `mu : (A, A) -> A` and `eta : () -> A`,
we can replace Cartesian product `(A, A)` by categorical product `A * A`,
and replace `()` by the terminal object.

That is suppose for some object `A` (the monad) in some a category,
we have morphisms `mu` and `eta`.

To express that `mu` analog to the associative binary function of monoid,
we first need `(A * A) * A ~~ A * (A * A)`,
which is not an equivalent but an isomorphism.

A monoidal category means generalize categorical product to a bifunctor,
thus we can define monad in monoidal category.

- For a bifunctor associative can be strict,
  `(A * A) * A ~~ A * (A * A)` can be `(A * A) * A == A * (A * A)`.

Given a category `C`, its endofunctors form a category,
the `functor_category_t(C, C)` (or write as `[C, C]`),
where `object_t = functor_t(C, C)`
and `morphism_t(f, g) = transformation_t(C, C, f, g)`.

Elements in `[C, C]` are functors from `C` to `C`,
so we can compose them, and this functor composition
can be viewed as form bifunctor (tensor-product) of category `[C, C]`,
thus `[C, C]` is a monoidal category.

A monad is just a monoid-object in the (strict) monoidal-category of endofunctors,
where in the monoidal-category tensor-product is functor composition.

## II 1.1 Declarative vs Imperative Approach

We have to know why we study category theory.

- **[Xie]**
  From the perspective of programming language,
  the answer is to use category theory to model
  concepts in programming language and type system (categorical semantics).
  When talk about "semantics" I mean both intuition and implementation
  (but nothing more than intuition and implementation).

  From the perspective of mathematics, logic or other knowledge domain,
  the answer would be different.

Can we always implement declarative language in imperative language?

- **[Xie]** The might be fail when the declarative language is so high level.

Can we do all that we can do in imperative language in declarative language?

- **[Xie]** Even if we can, is it always worth doing so?

Imperative vs Declarative, like local vs global physics laws.

The universal construction of category theory is an example of global approach.

## II 1.2 Limits

Limit captures the genereal idea about universal constructions,
we need to go one level up for abstraction here.

- [Kan extension](https://en.wikipedia.org/wiki/Kan_extension) would be even more genereal.

we start from the concrete example -- categorical product.

We can use functor to pick up pattern from a category.

Cone can be describe as a natural transformation
from  constant functor to the pattern picking functor.

To go from cone to limit, we talk about "universal", 
which means "uniqueness" and "for all".

## II 2.1 Limits, Higher order functors



## II 2.2 Limits, Naturality



## II 3.1 Examples of Limits and Colimits



## II 3.2 Free Monoids



## II 4.1 Representable Functors

TODO

``` js
category_t (t, arrow_t, arrow_eqv_t)
set_t : (type) -> type
hom_set : (a: t, b : t) -> set_t(arrow_t(a, b))
(x: t) -> hom_set(a, x)
```

## II 4.2 The Yoneda Lemma
## II 5.1 Yoneda Embedding
## II 5.2 Adjunctions
## II 6.1 Examples of Adjunctions
## II 6.2 Free-Forgetful Adjunction, Monads from Adjunctions
## II 7.1 Comonads
## II 7.2 Comonads Categorically and Examples
## II 8.1 F-Algebras, Lambek's lemma
## II 8.2 Catamorphisms and Anamorphisms
## II 9.1 Lenses
## II 9.2 Lenses categorically
## III 1.1 Overview part 1
## III 1.2 Overview part 2
## III 2.1 String Diagrams part 1
## III 2.2 String Diagrams part 2.webm
## III 3.1 Adjunctions and monads
## III 3.2 Monad Algebras.webm
## III 4.1 Monad algebras part 2
## III 4.2 Monad algebras part 3
## III 5.1 Eilenberg Moore and Lawvere
## III 5.2 Lawvere Theories
## III 6.1 Profunctors.webm
## III 6.2 Ends
## III 7.1 Natural transformations as ends
## III 7.2 Coends
