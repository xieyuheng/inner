#+title: Practical Object Oriented Design
#+author: Sandi Marts
#+date: 2019

* 1 Object-Oriented Design 1
** 1.1 In Praise of Design 2
*** 1.1.1 The Problem Design Solves 2
*** 1.1.2 Why Change Is Hard 3
*** 1.1.3 A Practical Definition of Design 3
** 1.2 The Tools of Design 4
*** 1.2.1 Design Principles 4

- What are the main design principles of OOP?

  TODO

*** 1.2.2 Design Patterns 6
** 1.3 The Act of Design 6
*** 1.3.1 How Design Fails 6
*** 1.3.2 When to Design 7
*** 1.3.3 Judging Design 9
*** 1.4 A Brief Introduction to Object-Oriented Programming
**** 1.4.1 Procedural Languages 11
**** 1.4.2 Object-Oriented Languages 11
** 1.5 Summary 13
* 2 Designing Classes with a Single Responsibility 15
** 2.1 Deciding What Belongs in a Class 16
*** 2.1.1 Grouping Methods into Classes 16
*** 2.1.2 Organizing Code to Allow for Easy Changes 16
** 2.2 Creating Classes That Have a Single Responsibility 17
*** 2.2.1 An Example Application: Bicycles and Gears 17
*** 2.2.2 Why Single Responsibility Matters 21
*** 2.2.3 Determining If a Class Has a Single Responsibility
*** 2.2.4 Determining When to Make Design Decisions 22
** 2.3 Writing Code That Embraces Change 24
*** 2.3.1 Depend on Behavior, Not Data 24
*** 2.3.2 Enforce Single Responsibility Everywhere 29

- What design techniques can be used here?

  All the same design techniques work
  ask them questions about what they do
  and try to describe their responsibilities in a single sentence.

- Describe the relation between the refactorings and the ultimate design.

  Refactoring reveal design.

  Do these refactorings even when you do not know the ultimate design.
  They are needed, not because the design is clear, but because it isn't.
  You do not have to know where you're going to use good design practices to get there.
  Good practices reveal design.

- What are the benefits of methods that have a single responsibility?

  - Expose previously hidden qualities
  - Avoid the need for comments
  - Encourage reuse
  - Are easy to move to another class

- You found the extra responsibilities,
  but you are not sure about creating a new class for them.
  What should you do?

  We can remove extra responsibilities without creating a new class.

  Your goal is to preserve single responsibility in the old class
  while making the fewest design commitments possible.

  Because you are writing changeable code,
  you are best served by postponing decisions
  until you are absolutely forced to make them.

  Any decision you make in advance of an explicit requirement is just a guess.
  Don't decide; preserve your ability to make a decision later.

  Without creating a new public class, we can create a inner private class.

- What should be our attitude towards a muddled class with too many responsibilities?

  If you have a muddled class with too many responsibilities,
  separate those responsibilities into different classes.

  Concentrate on the primary class.
  Decide on its responsibilities
  and enforce your decision fiercely.

  If you identify extra responsibilities that you cannot yet remove, isolate them.
  Do not allow extraneous responsibilities to leak into your class.

** 2.4 Finally, the Real Wheel 33
** 2.5 Summary
* 3 Managing Dependencies 37

- What are the three ways an object might fulfill a desired behavior?

  For any desired behavior, an object either
  - knows it personally,
  - inherits it,
  - or knows another object who knows it.

  The previous chapter "Enforce Single Responsibility Everywhere",
  is about the first way.

  This chapter "Managing Dependencies",
  is about the third way.

** 3.1 Understanding Dependencies 38

- What is the definition of dependency between objects?

  An object depends on another object if,
  when one object changes,
  the other might be forced to change in turn.

*** 3.1.1 Recognizing Dependencies 39

- How can an object depend on another object?

  An object has a dependency when it knows:
  - The name of another class.
  - The name of a message that it intends to send to someone other than self.
  - The arguments that a message requires.
  - The order of those arguments.

*** 3.1.2 Coupling Between Objects (CBO) 39

- What is the definition of coupling?

  A and B are coupled if changing one imply changing another.

  Coupling must be defined relative to change.

  coupling(A, B, d) = implication(change(A, d), change(B, d))

*** 3.1.3 Other Dependencies 40

- Beside the four kinds of dependencies listed previously,
  what are other dependency-related issues?

  - message chain
  - tests on code

** 3.2 Writing Loosely Coupled Code 41

*** 3.2.1 Inject Dependencies 41

- What kind of dependency does this "Inject Dependencies" coding technique deal with?

  Referring to another class by its name.

- How to use dependency injection?

  Using dependency injection to shape code relies on your ability to recognize that
  the responsibility for knowing the name of a class
  and the responsibility for knowing the name of a message to send to that class
  may belong in different objects.

*** 3.2.2 Isolate Dependencies 44

- What should we do if we cannot remove unnecessary dependency?

  If you cannot remove unnecessary dependencies,
  you should isolate them within your class,
  so that they are easy to spot and reduce when circumstances permit.

- What should be our attitude towards dependency?

  Think of every dependency as an alien bacterium that's trying to infect your class.

  Give your class a vigorous immune system; quarantine each dependency.

  Dependencies are foreign invaders that represent vulnerabilities,
  and they should be concise, explicit, and isolated.

- When we can not use dependency injection, what techniques we can use to isolate dependency?

  - isolate instance creation
    - creation in constructor
    - lazy creation in method
  - isolate vulnerable external messages

  - How "isolate instance creation" improves arrangement of code?

    An application whose classes are sprinkled with
    entangled and obscure class name references is unwieldy and inflexible,
    while one whose class name dependencies are concise, explicit, and isolated
    can easily adapt to new requirements.

  - What is the definition of external messages?

    Messages that are "sent to someone other than self."

  - When to use "isolate vulnerable external messages"?

    This technique becomes necessary when a class contains
    embedded references to a message that is likely to change.

    Isolating the reference provides some insurance against being affected by that change.

    Although not every external method is a candidate for this preemptive isolation,
    it's worth examining your code, looking for and wrapping the most vulnerable dependencies.

*** 3.2.3 Remove Argument-Order Dependencies

- What are them methods we can use to remove argument-order dependencies?

  - use keyword arguments
  - explicitly define defaults
  - isolate multiparameter initialization

- What is the disadvantage of using keyword arguments?

  - Keyword arguments is verbose.

  - It remove dependency on arguments order,
    but introduce dependency on argument names,
    if keyword arguments API are published,
    one can not change the names.

- Beside removing dependency on arguments order, what else is good about using keyword arguments?

  The keyword arguments is essentially record type data, which is self-descriptive.

  About "Self-descriptive messages", recall the four uniform interface constraints RESTful:

  - Resource identification in requests -- URI (Uniform Resource Identifier)
  - Resource manipulation through representations -- I am not sure about the meaning of this.
  - Self-descriptive messages -- record type
  - Hypermedia as the engine of application state -- hyperlink -- like dependency injection?

  As Sandi said:
  Using keyword arguments requires the sender
  and the receiver of a message to state the keyword names.
  This results in explicit documentation at both ends of the message.
  Future maintainers will be grateful for this information.

- What is the principle behind "isolate multiparameter initialization"?

  The classes in your application should depend on code that you own;
  use a wrapping method to isolate external dependencies.

  The above technique for replacing positional arguments with keywords
  is perfect for cases where you are forced to depend on external interfaces
  that you cannot change.

  Do not allow these kinds of external dependencies to permeate your code;
  protect yourself by wrapping each in a method that is owned by your own application.

** 3.3 Managing Dependency Direction 53

- What is the most import way of managing dependency?

  Reverse the direction of the dependency.

*** 3.3.1 Reversing Dependencies 53

- How to reverse dependency?

  By moving a method from one class to its dependency class.

- What is the difference between reversing dependency and dependency injection?

  dependency injection remove dependency,
  reversing dependency change direction.

*** 3.3.2 Choosing Dependency Direction 55

- Based on what simple truths about code, you tell your classes,
  "depend on things that change less often than you do."

  - Some classes are more likely than others to have changes in requirements.
  - Concrete classes are more likely to change than abstract classes.
  - Changing a class that has many dependents will result in widespread consequences.

- Recall the "Likelihood of Requirements Change change versus number of dependents" chart.

  | A | Abstract Zone | have little likelihood of change but contain many dependents        |
  | B | Benign Zone   | rarely change and have few dependents                               |
  | C | Concrete Zone | contains code that is quite likely to change but has few dependents |
  | D | Danger Zone   | guaranteed to change and has many dependents                        |

- How to gradually make an application unmaintainable?

  You can guarantee that any application will gradually become unmaintainable
  by making its Zone D classes more likely to change than their dependents.

- In you own developing experience, do you have any examples about dependency direction design?

  If a type system is implemented by OOP,
  the "check" method should belong to expression instead of type,
  because type is more abstract then expression.

** 3.4 Summary

- Make a table of coding techniques that can be used to managing dependencies.

  |---------------------------------------+------------------+----------+--------------------------|
  | technique                             | dependency       | managing | side effect              |
  |---------------------------------------+------------------+----------+--------------------------|
  | dependency injection                  | class name       | remove   |                          |
  | (remove named class)                  |                  |          |                          |
  |---------------------------------------+------------------+----------+--------------------------|
  | isolate instance creation             | class name       | isolate  |                          |
  |---------------------------------------+------------------+----------+--------------------------|
  | isolate vulnerable external messages  | message name     | isolate  |                          |
  |---------------------------------------+------------------+----------+--------------------------|
  | use keyword arguments                 | argument order   | remove   | depends on argument name |
  | (remove positional arguments)         |                  |          |                          |
  |---------------------------------------+------------------+----------+--------------------------|
  | explicitly define defaults            | message argument | reduce   |                          |
  | (reduce required arguments)           |                  |          |                          |
  |---------------------------------------+------------------+----------+--------------------------|
  | isolate multiparameter initialization | message argument | isolate  |                          |
  |                                       | argument order   | isolate  |                          |
  |---------------------------------------+------------------+----------+--------------------------|

* 4 Creating Flexible Interfaces 61

** 4.1 Understanding Interfaces 61

- Why messages is the core concept of OOP?

  Because messages form the communication pattern between objects,
  which is the dynamic structure of the running application.

- What are the two kinds of interfaces?

  The first kind of interface is public v.s. private method, that is,
  methods within a class and how and what to expose to others.

  The second kind of interface is the one that represents a concept
  that is broader than a class and is defined by a set of messages.

  This chapter is about the first kind of interface.

  the next chapter "Reducing Costs with Duck Typing",
  is about the second kind of interface.

- What is the relation between interface (the first kind) and messages?

  Public interfaces constrain the communication pattern formed by the messages.

** 4.2 Defining Interfaces 63

- Why this distinction between public and private exists?

  Because it is the most effective way to do business.

*** 4.2.1 Public Interfaces 64
*** 4.2.2 Private Interfaces 64
*** 4.2.3 Responsibilities, Dependencies, and Interfaces 64
** 4.3 Finding the Public Interface 65
*** 4.3.1 An Example Application: Bicycle Touring Company 65
*** 4.3.2 Constructing an Intention 65
*** 4.3.3 Using Sequence Diagrams 66
*** 4.3.4 Asking for “What” Instead of Telling “How” 70
*** 4.3.5 Seeking Context Independence 72
*** 4.3.6 Trusting Other Objects 74
*** 4.3.7 Using Messages to Discover Objects 75
*** 4.3.8 Creating a Message-Based Application 77
** 4.4 Writing Code That Puts Its Best (Inter)Face Forward 77
*** 4.4.1 Create Explicit Interfaces 77
*** 4.4.2 Honor the Public Interfaces of Others 79
*** 4.4.3 Exercise Caution When Depending on Private Interfaces
*** 4.4.4 Minimize Context 80
** 4.5 The Law of Demeter 80
*** 4.5.1 Defining Demeter 81
*** 4.5.2 Consequences of Violations 81
*** 4.5.3 Avoiding Violations 82
*** 4.5.4 Listening to Demeter 83
** 4.6 Summary 84
