#+title: Practical Object Oriented Design
#+author: Sandi Marts
#+date: 2019

* 1 Object-Oriented Design 1
** 1.1 In Praise of Design 2
*** 1.1.1 The Problem Design Solves 2
*** 1.1.2 Why Change Is Hard 3
*** 1.1.3 A Practical Definition of Design 3
** 1.2 The Tools of Design 4
*** 1.2.1 Design Principles 4

- What are the main design principles of OOP?

  TODO

*** 1.2.2 Design Patterns 6
** 1.3 The Act of Design 6
*** 1.3.1 How Design Fails 6
*** 1.3.2 When to Design 7
*** 1.3.3 Judging Design 9
*** 1.4 A Brief Introduction to Object-Oriented Programming
**** 1.4.1 Procedural Languages 11
**** 1.4.2 Object-Oriented Languages 11
** 1.5 Summary 13
* 2 Designing Classes with a Single Responsibility 15
** 2.1 Deciding What Belongs in a Class 16
*** 2.1.1 Grouping Methods into Classes 16
*** 2.1.2 Organizing Code to Allow for Easy Changes 16
** 2.2 Creating Classes That Have a Single Responsibility 17
*** 2.2.1 An Example Application: Bicycles and Gears 17
*** 2.2.2 Why Single Responsibility Matters 21
*** 2.2.3 Determining If a Class Has a Single Responsibility
*** 2.2.4 Determining When to Make Design Decisions 22
** 2.3 Writing Code That Embraces Change 24
*** 2.3.1 Depend on Behavior, Not Data 24
*** 2.3.2 Enforce Single Responsibility Everywhere 29

- What design techniques can be used here?

  All the same design techniques work
  ask them questions about what they do
  and try to describe their responsibilities in a single sentence.

- Describe the relation between the refactorings and the ultimate design.

  Refactoring reveal design.

  Do these refactorings even when you do not know the ultimate design.
  They are needed, not because the design is clear, but because it isn't.
  You do not have to know where you're going to use good design practices to get there.
  Good practices reveal design.

- What are the benefits of methods that have a single responsibility?

  - Expose previously hidden qualities
  - Avoid the need for comments
  - Encourage reuse
  - Are easy to move to another class

- You found the extra responsibilities,
  but you are not sure about creating a new class for them.
  What should you do?

  We can remove extra responsibilities without creating a new class.

  Your goal is to preserve single responsibility in the old class
  while making the fewest design commitments possible.

  Because you are writing changeable code,
  you are best served by postponing decisions
  until you are absolutely forced to make them.

  Any decision you make in advance of an explicit requirement is just a guess.
  Don't decide; preserve your ability to make a decision later.

  Without creating a new public class, we can create a inner private class.

- What should be our attitude towards a muddled class with too many responsibilities?

  If you have a muddled class with too many responsibilities,
  separate those responsibilities into different classes.

  Concentrate on the primary class.
  Decide on its responsibilities
  and enforce your decision fiercely.

  If you identify extra responsibilities that you cannot yet remove, isolate them.
  Do not allow extraneous responsibilities to leak into your class.

** 2.4 Finally, the Real Wheel 33
** 2.5 Summary
* 3 Managing Dependencies 37

- What are the three ways an object might fulfill a desired behavior?

  For any desired behavior, an object either
  - knows it personally,
  - inherits it,
  - or knows another object who knows it.

  The previous chapter "Enforce Single Responsibility Everywhere",
  is about the first way.

  This chapter "Managing Dependencies",
  is about the third way.

** 3.1 Understanding Dependencies 38

- What is the definition of dependency between objects?

  An object depends on another object if,
  when one object changes,
  the other might be forced to change in turn.

*** 3.1.1 Recognizing Dependencies 39

- How can an object depend on another object?

  An object has a dependency when it knows:
  - The name of another class.
  - The name of a message that it intends to send to someone other than self.
  - The arguments that a message requires.
  - The order of those arguments.

*** 3.1.2 Coupling Between Objects (CBO) 39

- What is the definition of coupling?

  A and B are coupled if changing one imply changing another.

  Coupling must be defined relative to change.

  coupling(A, B, d) = implication(change(A, d), change(B, d))

*** 3.1.3 Other Dependencies 40
** 3.2 Writing Loosely Coupled Code 41
*** 3.2.1 Inject Dependencies 41
*** 3.2.2 Isolate Dependencies 44
*** 3.2.3 Remove Argument-Order Dependencies
** 3.3 Managing Dependency Direction 53
*** 3.3.1 Reversing Dependencies 53
*** 3.3.2 Choosing Dependency Direction 55
** 3.4 Summary
