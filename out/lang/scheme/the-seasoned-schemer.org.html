<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>lang/scheme/the-seasoned-schemer.org</title>
</head>
<body>
<pre style="white-space: pre-wrap;">#+title: to be the seasoned schemer

* [todo-stack]

  - how to change two mutual recursive functions
    to one (non-mutual) recursive function?

* &gt;&lt; lost

* &gt;&lt; 14 let there be names

  #+begin_src scheme
  (define-syntax try
    (syntax-rules ()
      [(_ &lt;var&gt; a . b)
       (letcc success
         (letcc &lt;var&gt; (success a)) . b)]
      ))
  (try x a b)

  (letcc success
    (letcc x (success &lt;sexp1&gt;))
    &lt;sexp2&gt;)
  得:(&lt;sexp2&gt;暫時被忘掉了)
  (letcc success
    &lt;sexp1&gt;)

  失敗:
  x是失敗的記號
  如果在求值&lt;sexp1&gt;的過程中遇到x的作用(x &lt;sexp*&gt;)
  就得:
  (letcc success
    (letcc x &lt;sexp*&gt;)
    &lt;sexp2&gt;)
  (letcc success
    &lt;sexp*&gt;
    &lt;sexp2&gt;)
  然後返回&lt;sexp2&gt;的值

  成功:
  如果在求值&lt;sexp1&gt;的過程中沒有遇到x的作用
  就返回&lt;sexp1&gt;的值

  #+end_src

* &gt;&lt; 15 the difference between men and boys ..

* 16 ready, set, bang!

  use (set! ...) to remember valuable things between
  two distinct uses of a function

*** from deep to deepM

    first write deep simply

    #+begin_src scheme
    (define deep
      (lambda (m)
        (cond ((zero? m) &apos;pizza)
              (else (cons (deep (sub1 m))
                          &apos;())))))
    (deep 3)
    #+end_src

    then write deepR
    which calls deep after a side effect remembered all input and output

    #+begin_src scheme
    (define Ns &apos;())
    (define Rs &apos;())
    (define deepR
      (lambda (n)
        (let ((result (deep n)))
          (set! Ns (cons n Ns))
          (set! Rs (cons result Rs))
          result)))
    (deepR 5)
    (let ()
      (display Ns)
      (newline))
    (let ()
      (display Rs)
      (newline))
    #+end_src

    then write deepM
    which calls deepR
    and will not remember the same in&amp;output twice
    and calls find as help function
    and builds Ns and Rs inside let
    + with Ns and Rs inside let means that the environment of
      the closure called deepM
      contains boxes called Ns and Rs with value &apos;() in both of them
      and only during the application of the closure
      the value in the boxes called Ns and Rs can be
      taken by simply calling their names
      or changing by set!
      so after define deepM
      Ns and Rs are really there in the store in this way

    #+begin_src scheme
    (define find
      (lambda (n Ns Rs)
        (letrec
            ((A (lambda (ns rs)
                  (cond ((null? ns) #f)
                        ((= (car ns) n) (car rs))
                        (else (A (cdr ns) (cdr rs)))))))
          (A Ns Rs))))
    (find 1000000000 Ns Rs)
    (find 5 Ns Rs)

    (define deepM
      (let ((Ns &apos;())
            (Rs &apos;()))
        (lambda (n)
          (let ((found (find n Ns Rs)))
            (if found
                found
                (deepR n))))))
    (deepM 10)
    #+end_src

    and to add the side effects casused by deepM
    to every self calling of the function deep
    by changing the recursion in deep
    from (deep (sub1 m)) to (deepM (sub1 m))

    #+begin_src scheme
    (define deep
      (lambda (m)
        (cond ((zero? m) &apos;pizza)
              (else (cons (deepM (sub1 m))
                          &apos;())))))
    #+end_src

    after every functions was correct
    we should simplify them by merging

    #+begin_src scheme
    (define deepM
      (let ((Ns &apos;())
            (Rs &apos;()))
        (lambda (n)
          (let ((found (find n Ns Rs)))
            (if found
                found
                (let ((result (if (zero? n)
                                  &apos;pizza
                                  (cons (deepM (sub1 n))
                                        &apos;()))))
                  (set! Ns (cons n Ns))
                  (set! Rs (cons result Rs))
                  result))))))
    (deepM 1000)
    #+end_src

*** define recursive function length in a new way

    #+begin_src scheme
    (define length
      (let ((f (lambda (l) 0)))
        (set! f (lambda (l)
                  (cond ((null? l) 0)
                        (else
                         (add1 (f (cdr l)))))))
        f))

    (define length
      ((lambda (f)
         (set! f (lambda (l)
                   (cond ((null? l) 0)
                         (else
                          (add1 (f (cdr l)))))))
         f)
       (lambda (l) 0)))

    (length &apos;(1 2 3 4))
    #+end_src

    use (set! &lt;var&gt; &lt;obj*&gt;) for (let ((&lt;var&gt; &lt;obj&gt;)) ...)
    if there is at least one (lambda ... between them
    or if the new &lt;obj*&gt; for &lt;var&gt; is a function that refers to &lt;var&gt;
    + in this way we can define recursive function
    + 畢竟set!和define的實現方式是類似的

*** bang!

    下面當procedure F需要被傳入參數
    而在傳入參數時必須不被立刻求值時
    會出現與Y中同樣的
    用(lambda (x) (F x))來代替F的技巧

    但是這裏爲什麼需要這種技巧

    to extract a value and give it a name

    #+begin_src scheme
    (define length
      (let ([f (lambda (l) 0)])
        (set! f (L (lambda (x) (f x))))
        f))

    (define Y!
      (lambda (F)
        (let ([f (lambda (x) &apos;())])
          (set! f (F (lambda (x) (f x))))
          f)))
    ;letrec as syntax sugar of let and set!
    (define Y-bang
      (lambda (F)
        (letrec ((f (F (lambda (x) (f x)))))
          f)))
    #+end_src

*** &gt;&lt; biz

    對於L這類通過Y或Y!生產遞歸函數的算子來說
    Y與Y!作用於它們的結果是完全相同的
    但是對於其他形狀的東西作用結果就可能不同了
    爲什麼?

    #+begin_src scheme
    (define biz
      (let ((x 0))
        (lambda (f)
          (set! x (add1 x))
          (lambda (a) (if (= a x)
                      0
                      (f a))))))
    #+end_src

* 17 we change, therefore we are (consC and why deepM is better than deep)

*** deepM again

    #+begin_src scheme
    (define deepM
      (let ((Ns &apos;())
            (Rs &apos;()))
        (lambda (n)
          (let ((found (find n Ns Rs)))
            (if found
                found
                (let ((result (if (zero? n)
                                  &apos;pizza
                                  (cons (deepM (sub1 n))
                                        &apos;()))))
                  (set! Ns (cons n Ns))
                  (set! Rs (cons result Rs))
                  result))))))
    #+end_src

*** consC

    in the following
    set! procedure conter and set-conter inside the consC
    enable us to open the box called N
    outside the consC&apos;s application

    #+begin_src scheme
    (define conter)
    (define set-conter)
    (define consC
      (let ((N 0))
        (lambda (a d)
          (set! conter
                (lambda () N))
          (set! set-conter
                (lambda (x) (set! N x)))
          (set! N (add1 N))
          (cons a d))))
    (consC 1 2)
    (conter)
    (set-conter 0)
    #+end_src

*** why deepM is better then deep

    let deep and deepM using consC in the recursion first

    #+begin_src scheme
    (define deep
      (lambda (m)
        (cond ((zero? m) &apos;pizza)
              (else (consC (deep (sub1 m))
                          &apos;())))))
    (define deepM
      (let ((Ns &apos;())
            (Rs &apos;()))
        (lambda (n)
          (let ((found (find n Ns Rs)))
            (if found
                found
                (let ((result (if (zero? n)
                                  &apos;pizza
                                  (consC (deepM (sub1 n))
                                        &apos;()))))
                  (set! Ns (cons n Ns))
                  (set! Rs (cons result Rs))
                  result))))))
    #+end_src

    &gt;&lt; any better way to use consC, rather than copy the code of them?

    #+begin_src scheme
    (define test-function-with-lots-of-numbers
      (lambda (f n)
        (letrec
            ((N n)
             (T (lambda (n)
                  (if (zero? n)
                      (let ()
                        (f n)
                        (let ()
                          (newline)
                          (display
                           (list
                            &quot;after runing&quot; `,f &quot;from&quot; N &quot;to zero,&quot;))
                          (newline)
                          (display
                           (list
                            &quot;the number of cons been used is:&quot;))
                          (newline)
                          ))
                      (let ()
                        (f n)
                        (T (sub1 n)))))))
          (set-conter 0)
          (T n)
          (conter)
          )))
    (test-function-with-lots-of-numbers deep 1000)
    (test-function-with-lots-of-numbers deepM 1000)
    #+end_src

    test deepM one time the result is 1000
    test deepM another time the result will be 0

    &quot;a LISP programmer knows the value of everything
    but the cost of nothing&quot;
    --alan j.perlis

*** &gt;&lt; rember1* again

* 18 we change, therefore we are the same! (kkk)

*** ccc

    sexp is constructed by &quot;cons&quot;
    and changed by &quot;car cdr&quot;
    theoretically, &quot;car cdr cons&quot; are just functions
    that satisfy the following axioms:

    #+begin_src scheme
    (car (cons &lt;obj1&gt; &lt;obj2&gt;)) == &lt;obj1&gt;
    (cdr (cons &lt;obj1&gt; &lt;obj2&gt;)) == &lt;obj2&gt;
    #+end_src

    it is way we have this chapter

*** add-at-end

    we don&apos;t handle the &apos;() here
    so the second `add-at-end&apos; of the following source-block is taken
    though the `add-at-end&apos; in the next source-block is much cooler

    #+begin_src scheme
    (define add-at-end
      (lambda (l)
        (cond ((null? l)
               (cons &apos;egg &apos;()))
              (else
               (cons (car l)
                     (add-at-end (cdr l)))))))
    (define add-at-end
      (lambda (l)
        (cond ((null? (cdr l))
               (cons (car l) (cons &apos;egg &apos;())))
              (else
               (cons (car l) (add-at-end (cdr l)))))))
    (add-at-end &apos;(egg1 egg2))
    #+end_src

    #+begin_src scheme
    (define add-at-end-too
      (lambda (l)
        (letrec
            ((A (lambda (ls)
                  (cond ((null? (cdr ls))
                         (set-cdr! ls (cons &apos;egg &apos;())))
                        (else (A (cdr ls)))))))
          (A l)
          l)))
    (add-at-end-too &apos;(egg1 egg2))
    #+end_src

*** kkk

    use &quot;lambda&quot; to make &quot;kar kdr kons&quot;
    由下面的實現看出&apos;()並沒有什麼特殊性
    + 比如說如果我本身沒有&apos;()
      我可以挑&lt;atom&gt;類型中的任意一個出來當作&apos;()
    然後把這個東西從&lt;atom&gt;類型中排除 加入到&lt;list&gt;類型
    如何給scheme解釋器加一個說明性的類型系統

    #+begin_src scheme
    :kons: (&lt;kist&gt; . &lt;kist&gt;) -&gt; (&lt;selector&gt; -&gt; &lt;selected-obj&gt;)
    &lt;kist&gt; ::= &lt;atom&gt; | (&lt;selector&gt; -&gt; &lt;selected-obj&gt;)
    (define kons
      (lambda (kar kdr)
        (lambda (selector)
          (selector kar
                    kdr))))
    :kar: (&lt;selector&gt; -&gt; &lt;selected-obj&gt;) -&gt; &lt;selected-obj&gt;
    顯然爲了實現 :kar: 的類型只需在kar中
    把(&lt;selector&gt; -&gt; &lt;selected-obj&gt;)作用到&lt;selector&gt;上面
    (define kar
      (lambda (c)
        (c (lambda (a d) a))))
    (define kdr
      (lambda (c)
        (c (lambda (a d) d))))
    #+end_src

*** note

    1. 這裏明顯地需要從比數學中的函數更廣義的角度來理解lambda表達式
       lexical scope中對lambda表達式被求值爲closure
       closure的action 首先是一個對sexp的代換過程
       最後是apply
       只有在最後apply的時候 sexp的fun和args才被區分 sexp中的項纔是不平等的
       這樣lambda表達式 能比數學中傳統意義上的函數表達更多的東西
       就在於做代換的時候fun位置也可以被代換

    2. 設想現在要設計一種函數式編程範式的新語法
       因爲我並不滿足scheme中的apply
       因爲apply的語義很侷限
       它總把sexp的頭一個位置的項理解爲fun 然後其他的項被它作用

    3. 要設計一個函數式編程範式的編程語言
       首先要找一個表示方式
       * LISP ::
            sexp（等價於tree）
       然後要設計出“函數的作用”這個語義應該如何實現 這正是“函數式”的所指
       * LISP ::
            用lambda表達式來實現一種代換方式
            這種代換方式指明瞭lambda表達式被化爲closure後作用於參數的方式
            然後用apply去指明procedure（primitive或non-primitive的closure）
            在明確了的方式下作用於參數將得到什麼

    4. 想像一下
       我的新語言用一般的圖來做爲表達方式
       同樣有類似lambda表達式的東西來指明作用方式
       但是apply就完全不一樣了
       要求它不能提前特殊化圖中的某些位置
       那麼它應該如何完成一次作用呢？
       如果它去檢測元素的類型的話 procedure就不能作用於procedure了！

    5. 回過頭來想一下
       想要追求的語義是什麼？
       可以說在數學中 並不是把作用死板地理解爲一個函數在作用 一些參在被作用
       正相反 參數和函數的地位是可以相互轉化的
       把參數明確了 然後把函數空下來 我就得到一個泛函(*,#)
       但是這樣的一個東西也可以被看作是一個二元函數
       也就說這兩個空位(*,*)不僅僅是兩個空位而已
       我寫出它們的同時還指定了當這兩個空位被填上時我應該以什麼方式
       從這兩個信息得到計算的結果 即(*,*) == f(*,*)
       所以LISP的能力其實是不被我的“新語言”所超越的

    6. (*,#) (*,*) f(*,*) 不同的表達方式可能代表了不同的計算方式

    7. 這真是狂想
       把一個作用方式結構化
       那麼這個結構所給出的豐富信息如何影響作用方式呢？

    8. 回憶一下friedman想要在這本書中教導人們計算的本質
       計算是有複雜性的
       這在於
       我在利用計算機進行計算
       我把我想要計算的東西表達成計算機能理解的形式
       然後計算機以它的方式把我表達的計算分解爲它對它存儲狀態的操作
       複雜性正產生與這裏
       順應計算機的行爲方式 我才能把我希望的計算做好
       就是在這樣惡劣的條件下 我要利用計算機來幫助我的某些數學思考
       可以說 那些控制對人的理解而言的複雜性的技術
       正是我爲了獲得計算機對我的幫助而學習的

*** kkk with set!

    爲了定義set-kdr 而利用下面的bons 重新定義&quot;kar kdr kons&quot;
    + why bons and kons are separated?
      because we need to bind kdr to set! it letter
      but when closure is constructed
      no name will be bound to any loaction
      it is in the first step of the apply
      where the binding should happen temporarily

    #+begin_src scheme
    :kons: &lt;kist&gt; -&gt; (&lt;selector&gt; -&gt; &lt;selected-obj&gt;)
    (define bons
      (lambda (kar)
        (let [(kdr &apos;())]
          (lambda (selector)
            (selector (lambda (x) (set! kdr x))
                      kar
                      kdr)))))
    :kar: (&lt;selector&gt; -&gt; &lt;selected-obj&gt;) -&gt; &lt;selected-obj&gt;
    (define kar
      (lambda (c)
        (c (lambda (s a d) a))))
    (define kdr
      (lambda (c)
        (c (lambda (s a d) d))))
    (define set-kdr
      (lambda (c x)
        ((c (lambda (s a d) s))
         x)))
    :kons: (&lt;kist&gt; . &lt;kist&gt;) -&gt; (&lt;selector&gt; -&gt; &lt;selected-obj&gt;)
    (define kons
      (lambda (a d)
        (let [(c (bons a))]
          (set-kdr c d)
          c)))
    (bons 1)
    (kar (bons 1))
    (kdr (bons 1))
    (kons 1 2)
    (kar (kons 1 2))
    (kdr (kons 1 2))
    #+end_src

    + 嘗試描述類型的過程中來看
      好像要想實現完備的類型系統就要對語言作很多限制

    + what the visual model of our kkk may looks like
      (*,*) is not a good one
      there are something more basic that is not in our define of kkk

*** &gt;&lt; play with kkk with set!

    when we use &quot;add-at-end&quot;
    we will make a new list
    but when we change to use &quot;add-at-end-too&quot;
    the konses are the same except fot the last one
    and the value of the &lt;arg&gt; of &quot;add-at-end-too&quot; is change
    &quot;we change, therefore we are the same!&quot;

    #+begin_src scheme
    (define kounter)
    (define set-kounter)
    (define konsC
      (lambda ()))


    (define lots
      (lambda (m)
        (cond ((zero? m) &apos;())
              (else (konsC &apos;egg (lots (sub1 m)))))))
    (define lenkth
      (lambda (l)
        (cond ((null? l) 0)
              (else (add1 (lenkth (kdr l)))))))
    (define add-at-end
      (lambda (l)
        (cond ((null? (kdr l))
               (konsC (kar l) (kons &apos;egg &apos;())))
              (else
               (konsC (kar l) (add-at-end (kdr l)))))))
    (define add-at-end-too
      (lambda (l)
        (letrec
            ((A (lambda (ls)
                  (cond ((null? (kdr ls))
                         (set-kdr ls (konsC &apos;egg &apos;())))
                        (else (A (kdr ls)))))))
          (A l)
          l)))
    #+end_src

*** &gt;&lt; same?

    #+begin_src scheme
    (define eklist?
      (lambda (ls1 ls2)
        (cond (())
              (())
              (else
               ()))))
    #+end_src

    there is a new idea of &quot;sameness&quot; once we introduce (set! ...)
    &quot;two konses are the same if changing one changes the other&quot;
    by &quot;changing&quot; it means we are using the &quot;set-kdr&quot;
    by &quot;two konses&quot; it means two different names
    + notice `c1 c2&apos; must be non-empty kons-list

    #+begin_src scheme
    (define same?
      (lambda (c1 c2)
        (let ((t1 (kdr c1))
              (t2 (kdr c2)))
          (set-kdr c1 1)
          (set-kdr c2 2)
          (let ((v (= (kdr c1) (kdr c2))))
            (set-kdr c1 1)
            (set-kdr c2 2)
            v))))
    #+end_src

*** &gt;&lt; play with same?

*** &gt;&lt; play with set-kdr

*** finite-lenkth

    循環者返回#f
    不循環者計數其長度
    + because we are doing recursion
      the order of the questions is matter
    + 這裏數的是一個線性的list中的元素 而不是一般的kons-sexp
      它所能形成的循環很簡單
    + 一般的kons-sexp能形成多麼一般的圖？
      首先是一顆樹
      要明白 這裏是用list做爲樹的模型 而不是用pair
      因爲pair對branch的數目有顯示
      例如((1) (2) (3))是一個節點
      它的子節點是 三個葉節點：(1) (2) (3)
      而1 2 3是用來區分這些葉節點的標記
      這樣每個節點就都是一個list
      在這種模型下
      把list末尾cons的&apos;()換成樹中的其它節點的地址的過程
      就可以被視爲是給原來的樹中的節點之間增添有向邊
      如果忽略這些增添的有向邊的方向
      那麼顯然就得到了一個任意無向圖的一般表示方法
      問題是很難判斷兩個表示是否表示着同一個圖
      這是所需要的最基本的謂詞 這總是表示的難點
      + sexp對樹結構的表示 其性質是：
        1) 每一個表示都表示着唯一的一個樹
        2) 並且所有的樹都能用sexp表示出來
        這樣sexp和樹就是等價的
      &gt;&lt;還有一個問題就是一般的有向圖怎麼辦？
      &gt;&lt;無窮的圖又怎麼辦？
      &gt;&lt;有限狀態機可以用來寫謂詞 但是很不理想

    #+begin_src scheme
    (define finite-lenkth
      (lambda (p)
        (letcc infinite
               (letrec
                   ((C (lambda (p q)
                         (cond ((null? q) 0)
                               ((null? (kdr q)) 1)
                               ((same? p q) (infinite #f))
                               (else
                                (+ (C (sl p) (qk q))
                                   2)))))
                    (qk (lambda (x) (kdr (kdr x))));quickly
                    (sl (lambda (x) (kdr x)));slowly
                    )
                 (cond ((null? p) 0)
                       (else
                        (add1 (C p (kdr p)))))))))
    #+end_src

* 19 absconding with the jewels

*** deep again

    #+begin_src scheme
    (define deep
      (lambda (m)
        (if (zero? m)
            &apos;pizza
            (cons (deep (sub1 m)) &apos;()))))
    (deep 12)

    (define toppings)
    (define deepB
      (lambda (m)
        (cond ((zero? m)
               (letcc jump
                      (set! toppings jump)
                      &apos;pizza))
              (else
               (cons (deepB (sub1 m)) &apos;())))))
    (deepB 2)
    (cons (toppings &apos;k) (toppings &apos;kk))

    (define deep&amp;co;collector
      (lambda (m k)
        (cond ((zero? m) (k &apos;pizza))
              (else
               (deep&amp;co (sub1 m)
                        (lambda (x)
                          (k (cons x &apos;()))))))))
    (deep&amp;co 10 (lambda (x) x))

    (define deep&amp;coB
      (lambda (m k)
        (cond ((zero? m)
               (let ()
                 (set! toppings k)
                 (k &apos;pizza)))
              (else
               (deep&amp;coB (sub1 m)
                         (lambda (x)
                           (k (cons x &apos;()))))))))
    (deep&amp;coB 20 (lambda (x) x))
    (cons (toppings &apos;a)
          (cons (toppings &apos;b)
                (cons (toppings &apos;c)
                      &apos;())))
    #+end_src

*** kill-the-orc-hero

    &gt;&lt;letcc到底是如何實現的？

    雖然我知道它是的幾種使用方式
    但是不知道它是如何實現的就沒法完全瞭解它

    letcc是人族大法師的一個魔法
    大法師用這個魔法制作一個標記爲&lt;marker&gt;的傳送卷軸
    (letcc &lt;marker&gt;
    &lt;sexp1&gt;
    &lt;sexp2&gt;
    ...)
    大法師作這個卷軸的目的是
    希望戰士們把他渴望得到的寶物或者渴望交手的敵人&lt;sexp*&gt;
    從戰場上帶到他面前
    大法師把卷軸發放給這個戰場上的人族戰士們
    戰士可以通過(&lt;marker&gt; &lt;sexp*&gt;)來使用卷軸
    把自己和自己面前的&lt;sexp*&gt;傳送回製作卷軸的地方
    戰士也可以用(set! &lt;var&gt; &lt;marker&gt;)把卷軸通過&lt;var&gt;帶出當前的戰場
    然後在別的地方以(&lt;var&gt; &lt;sexp*&gt;)之名使用卷軸
    把使用者與使用者面前的&lt;sexp*&gt;傳送回製作卷軸的地方

    #+begin_src scheme
    (define kill-the-orc-hero
      (lambda (battle-field)
        (let ((find-him (lambda (battle-field)
                         (letcc bring-him-to-master
                                (set! knight bring-him-to-master)
                                (go-and-search battle-field))))
              (kill-him (lambda (him)
                          (list &apos;kill-you &apos;aha &quot;---&gt;&gt;&gt;&quot; him))))
          (kill-him (find-him battle-field)))))
    (define knight)
    (define go-and-search
      (lambda (battle-field)
        (cond ((null? battle-field) &quot;nobody in the battle-field&quot;)
              ((atom? (car battle-field))
               (if (eq? (car battle-field) &apos;orc-hero)
                   (knight (car battle-field))
                   (go-and-search (cdr battle-field))))
              (else
               (let ()
                 (go-and-search (car battle-field))
                 (go-and-search (cdr battle-field)))))))
    (kill-the-orc-hero
     &apos;((((1(331(3((3(1()31)4))132) 412414() 43241() ()) () 1344((43(((124())3413) (&apos;orc-hero)))143))423)134)324))
    #+end_src

*** &gt;&lt; two-in-a-row*?

    #+begin_src scheme
    (define two-in-a-row?
      (lambda (lat)
        (letrec
            ((W (lambda (a lat)
                  (cond ((null? lat) #f)
                        (else
                         (let ((nxt (car lat)))
                           (or (eq? a nxt)
                               (W nxt (cdr lat)))))))))
          (cond ((null? lat) #f)
                (else
                 (W (car lat) (cdr lat)))))))
    (two-in-a-row? &apos;(1 2 3 4 5 6))
    #+end_src

    then two-in-a-row*? will do the same, regardless of parentheses
    but it is long way to go

    walk is like &quot;leftmost&quot; if we put the rigth kind of value into leave
    其實是把leftmost分解成幾部分 因爲需要分別命名 以在別處靈活使用
    + 使用letcc的另一種典型方式
      更好的方法
      因爲更靈活
      因爲這樣就可以把函數分開來寫
    下面的函數名&quot;walk&quot; &quot;waddle&quot;是說你只不過是在蹣跚學步呢 所以不要牛逼

    #+begin_src scheme
    (define leave)
    (define walk
      (lambda (l)
        (cond ((null? l) &apos;())
              ((atom? (car l))
               (leave (car l)))
              (else
               (let ()
                 (walk (car l))
                 (walk (cdr l)))))))
    (define start-it
      (lambda (l)
        (letcc here
               (set! leave here)
               (walk l))))
    (start-it &apos;(((((((((((((!)))))132)3)12)3)213)))))
    (define fill)
    (define waddle
      (lambda (l)
        (cond ((null? l) &apos;())
              ((atom? (car l))
               (let ()
                 (letcc rest
                        (set! fill rest)
                        (leave (car l)))
                 (waddle (cdr l))))
              (else
               (let ()
                 (waddle (car l))
                 (waddle (cdr l)))))))
    ;; why we need the following get-next then this one?
    ;; (define start-it2
    ;;   (lambda (l)
    ;;     (letcc here
    ;;            (set! leave here)
    ;;            (waddle l))))
    ;; (start-it2 &apos;(((((((((((((!)))))132)3)12)3)213)))))
    ;; (start-it2 &apos;())
    (define get-next
      (lambda (x)
        (letcc here-again
               (set! leave here-again)
               (fill &apos;go))))
    (get-next &apos;go)
    (define get-first
      (lambda (l)
        (letcc here
               (set! leave here)
               (waddle l)
               (leave &apos;()))))
    (get-first &apos;(((((((((((((!)))))132)3)12)3)213)))))
    (get-first &apos;())
    #+end_src

    上面因爲使用了很多set!而使get-next完全處離了數學函數的範圍

    then it is easy to define two-in-a-row*?

    #+begin_src scheme

    #+end_src

*** note

    &quot;during the evaluation of a scheme expression
    the implementation must keep track of two things:
    1) what to evaluate
    2) what to do with the value.&quot;

    &quot;we call `what to do with the value&apos;
    the continuation of a computation&quot;

    --kent dybvig

    原來call/cc中的&quot;cc&quot;就是指展開遞歸函數的過程中遇到call/cc時的&quot;當前狀態&quot;
    而(set! fill rest)將把(letcc rest ...)位置處的狀態保存起來
    在外面出現作用fill的時候將回到這個位置所對應的計算狀態
    + 因此把(letcc &lt;marker&gt; &lt;sexp&gt;)使用在最外面
      並且在&lt;sexp&gt;中直接使用(&lt;marker&gt; &lt;sexp*&gt;)的效果就是
      直接中斷遞歸計算而返回&lt;sexp*&gt;的結果
    在(letcc &lt;marker&gt; &lt;sexp&gt;)的&lt;sexp&gt;之中
    + 或者在多個&lt;sexp&gt;組成的&lt;body&gt;之中
      一些用來副作用
      最後一個用來返回值
      如果&lt;body&gt;中前面的&lt;sexp&gt;中有&lt;marker&gt;的action出現 後面的當然會被忽略

      #+begin_src scheme
      (define test-cc
        (lambda ()
          (letcc kkk
                 123
                 456
                 (kkk &quot;good&quot;)
                 (kkk &quot;bad&quot;))))
      (test-cc)
      #+end_src

    &lt;marker&gt;是一個單參數的procedure的name
    這個procedure的action：(&lt;marker&gt; &lt;sexp*&gt;)
    將把&lt;sexp*&gt;代入到在展開遞歸函數的過程中遇到(letcc ...)的那個位置

    更好的說
    procedure的action的求值是一個展開過程
    因爲它要等待fun部分和args部分的求值結果
    在這個展開過程中
    把任意一個需要被等待求值結果的位置空出來
    就會形成一個一元的procedure
    + 當然 對fun部分和args部分的求值是按順序一個一個求的
      要想形成一個一元的procedure
      就必須要記住那些還在等待中的位置應該如何被求值
    這個一元的procedure就是&quot;call/cc&quot;中的&quot;cc&quot;
    如果一個需要被等待求值結果的位置原本是&lt;sexp&gt;
    那麼只要把它替換爲(letcc &lt;marker&gt; &lt;sexp&gt;)
    就可以把上面所說的一元的procedure保存到
    爲名字&lt;marker&gt;所開闢的存儲地址當中
    + 這個&lt;marker&gt;的binding只在這個(letcc ...)中可見
      因此
      如果在&lt;sexp&gt;中不出現這個&lt;marker&gt;所對應的一元的procedure的action
      也不把這個一元的procedure利用(set! &lt;var&gt; &lt;marker&gt;)保存在別處
      的話
      那麼letcc的出現是沒有意義的
      其實也可以是有意義的 比如下面這個例子

      #+begin_src scheme
      ((lambda (x)
         (x (lambda (ignore) &quot;hi&quot;)))
       (letcc k k))
      #+end_src

    這樣一切就都明白了
    + 而letcc給出了這種語義的最清晰的語法
      又爲什麼有call/cc這種不清晰的語法?
      因爲它揭示了call/cc的實現方式嗎?
    + 一個問題是可不可以嵌套？
      即 代入之後是不是得(letcc &lt;marker&gt; &lt;sexp*&gt;)

      #+begin_src scheme
      (define test-cc
        (lambda ()
          (letcc kkk
                 (kkk
                  (kkk &quot;good&quot;)))))
      (test-cc)
      #+end_src

      結果確實是如此&lt;marker&gt;在&lt;sexp&gt;中的出現是可以嵌套的

*** play with call/cc

    #+begin_src scheme
    (let ([x (call/cc (lambda (k) k))])
      (x (lambda (ignore) &quot;hi&quot;)))
    ((lambda (x)
       (x (lambda (ignore) &quot;hi&quot;)))
     (letcc k k))

    (define k (letcc x x))
    (k (lambda (ignore) &quot;hi&quot;))
    ;; 第一次求值的時候會
    ;; (define k (lambda (ignore) &quot;hi&quot;))
    ;; 再次求值的時候就與(letcc x x)無關了

    (((letcc k k)
      (lambda (x) x))
     &quot;HEY!&quot;)
    #+end_src

    the following mechanism could be the basis
    for a breakpoint package implemented with call/cc
    each time a breakpoint is encountered
    the continuation of the breakpoint is saved
    so that the computation may be restarted from the breakpoint
    more than once if desired

    #+begin_src scheme
    (define retry)
    (define factorial
      (lambda (x)
        (if (= x 0)
            (letcc k
                   (set! retry k)
                   1)
            (* x (factorial (- x 1))))))
    #+end_src

    如何使用lwp? 什麼是multitasking
    就是函數們在返回值之前相互商量?
    &quot;the simple &quot;light-weight process&quot; mechanism
    defined below allows multiple computations to be interleaved
    since it is nonpreemptive
    it requires that each process voluntarily &quot;pause&quot; from time to time
    in order to allow the others to run&quot;

    #+begin_src scheme
    (define lwp-list &apos;())
    (define lwp;; denote light-weight process
      (lambda (thunk)
        (set! lwp-list (append lwp-list (list thunk)))))
    (define start
      (lambda ()
        (let ([p (car lwp-list)])
          (set! lwp-list (cdr lwp-list))
          (p))))
    (define pause
      (lambda ()
        (letcc k
               (lwp (lambda () (k #f)))
               (start))))
    #+end_src

* CPS

  &quot;把任意一個需要被等待求值結果的位置空出來
  就會形成一個一元的procedure&quot;
  但是這種想法只能作出一元procedure
  CPS可以實現作爲多元procedure的continuation

  1. 我所擅長的就是在下面這種頭腦風暴中總結我所觀察到的規律
     不管正確不正確
     先形成一個自己的認識
     對所形成的這種認識的態度當然是
     只要有更清晰更有力的方式 我就一定讓它代替我的舊認識

  2. h被調用的位置的改變
     h被一個cons的作用調用(這個調用所形成的cc被明顯的寫了出來)
     置爲
     h的作用 其中h是在後面增加了一個參數位置的
     那個cc被明顯地寫出來並且被放入那個新的參數位置

  3. h的定義位置的改變 h的定義調用了g 因此這也是g的被調用的位置的改變
     因爲直接是g的作用
     所以幾乎沒什麼改變只是繼續把這個cc傳給被h調用的g
     不用改變cc

  4. g的定義位置的改變 也是f的調用位置的改變
     cons的作用調用f
     這個作用形成一個一元cc (調用f的作用的cc可以被記爲cc-f(denote cc of f))
     原來的cc要被 這個作用所形成的cc來擴充
     之後才能被傳入f的新參數位置
     這個擴充簡單地說就是把原來的cc作用在這個cc-f上形成一個新的cc

  5. f的定義位置的改變
     f不再調用任何non-primitive了
     所以這裏簡單的就是這裏的表達式要被傳入f的新參數位置的cc作用

  #+begin_src scheme
  (cons &apos;d
        (cons &apos;b
              (cons &apos;a
                    (cons &apos;c &apos;()))))

  (letrec ([f (lambda (x) (cons &apos;a x))]
           [g (lambda (x) (cons &apos;b (f x)))]
           [h (lambda (x) (g (cons &apos;c x)))])
    (cons &apos;d (h &apos;())))

  (letrec ([f (lambda (x k) (k (cons &apos;a x)))]
           [g (lambda (x k) (f x
                           (lambda (v) (k (cons &apos;b v)))))]
           [h (lambda (x k) (g (cons &apos;c x)
                           k))])
    (h &apos;()
       (lambda (v) (cons &apos;d v))))
  #+end_src

  not-CPS and CPS

  #+begin_src scheme
  (define f (x)
    &lt;sexp&gt;)
  (g (f x))

  (define f (x cc-f)
    (cc-f &lt;sexp&gt;))
  (f x
     (lambda (y) (g y)))
  #+end_src

  CPS可以實現一個函數作用在不同的條件下獲得不同的cc的效果
  下面的函數接受cc參數的參數位置是後兩個
  integer-divide成功時返回商與餘數的list

  #+begin_src scheme
  (define integer-divide
    (lambda (x y success failure)
      (if (= y 0)
          (failure &quot;divide by zero&quot;)
          (let ([q (quotient x y)])
            (success q (- x (* q y)))))))
  (integer-divide 10 3 list (lambda (x) x))
  (integer-divide 10 0 list (lambda (x) x))
  #+end_src

  &quot;explicit success and failure continuations
  can sometimes help to avoid the extra communication necessary
  to separate successful execution of a procedure
  from unsuccessful execution
  furthermore
  it is possible to have multiple success or failure continuations
  for different flavors of success or failure
  each possibly taking different numbers and types of arguments&quot;

  &quot;any program that uses call/cc can be rewritten in cps without call/cc
  but a total rewrite of the program
  (sometimes including even system-defined primitives)
  might be necessary&quot;

  #+begin_src scheme
  (define product
    (lambda (ls)
      (letcc break
             (let f ([ls ls])
               (cond
                [(null? ls) 1]
                [(= (car ls) 0) (break 0)]
                [else (* (car ls) (f (cdr ls)))])))))
  (define product
    (lambda (ls)
      (letcc break
             (letrec
                 ([f (lambda (ls)
                       (cond
                        [(null? ls) 1]
                        [(= (car ls) 0) (break 0)]
                        [else (* (car ls) (f (cdr ls)))]))]
                  )
               (f ls)))))
  (product &apos;(1 2 3 4 5))
  (product &apos;(7 3 8 0 1 9 5))
  (define product
    (lambda (ls k)
      (let ([break k]);這個賦值只爲了區分k的語義 並且與上面一致
        (letrec ([f (lambda (ls k)
                      (cond
                       [(null? ls) (k 1)]
                       [(= (car ls) 0) (break 0)]
                       [else (f (cdr ls)
                                (lambda (x)
                                  (k (* (car ls) x))))]))]
                 )
          (f ls k)))))
  (define product
    (lambda (ls k)
      (letrec ([f (lambda (ls k)
                    (cond
                     [(null? ls) (k 1)]
                     [(= (car ls) 0) (k 0)]
                     [else (f (cdr ls)
                              (lambda (x)
                                (k (* (car ls) x))))]))]
               )
        (f ls k))))
  (product &apos;(1 2 3 4 5)
           (lambda (x) x))
  (product &apos;(7 3 8 0 1 9 5)
           (lambda (x) x))
  #+end_src
  CPS中recursion在於改變cc
  其實這種技巧在the little schemer的第8章已經學過了

* internal definitions

  *internal definitions can appear only at the front of a body*
  *syntax definitions may appear among the internal definitions*
  怎麼能有這種東西?
  它不影響代碼清晰性的用法如下

  #+begin_src scheme
  (let ()
    (define-syntax &lt;key&gt;
      (syntax-rules ()
        [&lt;p&gt; &lt;t&gt;]))
    (define &lt;var1&gt; &lt;sexp1&gt;)
    (define &lt;var2&gt; &lt;sexp2&gt;)
    (&lt;sexp3&gt;))

  (begin
    (define-syntax &lt;key&gt;
      (syntax-rules ()
        [&lt;p&gt; &lt;t&gt;]))
    (define &lt;var1&gt; &lt;sexp1&gt;)
    (define &lt;var2&gt; &lt;sexp2&gt;)
    (&lt;sexp3&gt;))
  #+end_src

  如同emacs-lisp中的progn
  可以在大的環境中分出來獨立的區域

  #+begin_src emacs-lisp
  (progn
    (defun &lt;var1&gt; &lt;sexp1&gt;)
    (defun &lt;var2&gt; &lt;sexp2&gt;)
    (&lt;sexp3&gt;))
  #+end_src

  在scheme中 可能需要用這種表示方法的 就是下面的情況
  &quot;variable definitions are guaranteed
  to be evaluated from left to right
  while the bindings of a letrec may be evaluated in any order&quot;
  &quot;however, use letrec*, which, like let*, guarantees
  left-to-right evaluation order&quot;

  &quot;internal definitions may be used in conjunction with
  top-level definitions and assignments to help modularize programs
  each module of a program should make visible only those bindings
  that are needed by other modules
  while hiding other bindings
  that would otherwise clutter the top-level namespace
  and possibly result in unintended use
  or redefinition of those bindings&quot;
  &quot;it does not support the publication of keyword bindings
  since there is no analogue to set! for keywords&quot;

  #+begin_src scheme
  (define export-var #f)
  (let ()
    (define &lt;var1&gt; &lt;sexp1&gt;)
    (define &lt;var2&gt; &lt;sexp2&gt;)
    (set! export-var &lt;var1&gt;)
    &lt;sexp3&gt;
    )
  #+end_src

* libraries

  #+begin_src scheme
  (library (grades)
           (export gpa-&gt;grade gpa)
           (import (rnrs))
           (define in-range?
             (lambda (x n y)
               (and (&gt;= n x) (&lt; n y))))
           (define-syntax range-case
             (syntax-rules (- else)
               [(_ expr ((x - y) e1 e2 ...) ... [else ee1 ee2 ...])
                (let ([tmp expr])
                  (cond
                   [(in-range? x tmp y) e1 e2 ...]
                   ...
                   [else ee1 ee2 ...]))]
               [(_ expr ((x - y) e1 e2 ...) ...)
                (let ([tmp expr])
                  (cond
                   [(in-range? x tmp y) e1 e2 ...]
                   ...))]))
           (define letter-&gt;number
             (lambda (x)
               (case x
                 [(a)  4.0]
                 [(b)  3.0]
                 [(c)  2.0]
                 [(d)  1.0]
                 [(f)  0.0]
                 [else (assertion-violation &apos;grade &quot;invalid letter grade&quot; x)])))
           (define gpa-&gt;grade
             (lambda (x)
               (range-case x
                           [(0.0 - 0.5) &apos;f]
                           [(0.5 - 1.5) &apos;d]
                           [(1.5 - 2.5) &apos;c]
                           [(2.5 - 3.5) &apos;b]
                           [else &apos;a])))
           (define-syntax gpa
             (syntax-rules ()
               [(_ g1 g2 ...)
                (let ([ls (map letter-&gt;number &apos;(g1 g2 ...))])
                  (/ (apply + ls) (length ls)))])))
  #+end_src

  #+begin_src scheme
  (import (grades))
  (gpa c a c b b)
  (gpa-&gt;grade 2.8)
  #+end_src

* 20 what&apos;s in the store? (interpreter-with-define-and-set!)

*** note

    1. 這一章寫一個新的有define和set!的解釋器
       有一個全局的命名空間global-table
       以元解釋器中的procedure爲新的table(of environment)的數據結構
       一個table就是一個procedure
       它作用於一個name返回這個name所對應的value
       table中name與box綁定 box中存放着value
       全局生成新box的是define 局部生成新box的是closure的作用
       box利用lambda-exp的技巧實現（或者說模擬）一種訪問機制
       有了訪問機制 就實現了set!
    2. 只有實現了命名機制在我的解釋器裏解釋自身才成爲可能
    3. 注意這裏沒有apply
       *const與*lambda都直接把e求值成了元解釋器中的procedure
       解釋了一些東西卻又矇蔽了另一些東西
       &gt;&lt; 爲了實現上面的性狀而必須這樣做嗎？
    4. 新增加了*letcc
       但是並沒有觸及letcc的本質
       在我的這個解釋器中使用letcc是爲了找不到name時的報錯
       而增加這個*letcc就使得
       在我的這個解釋器中可是實現一個相同的
       可以在找不到name時報錯的解釋器

*** &gt;&lt; hack

    1. 既然已經會使用letcc和set!了 那麼我能和這個解釋器玩的花樣就有趣多了
    2. 試着在這個解釋器中使用apply
    3. 試着補全&lt;formals&gt;的形式：
       &lt;variable&gt;
       (&lt;variable&gt;*)
       (&lt;variable&gt; &lt;variable&gt;* . &lt;variable&gt;)
    4. 用元解釋器創造一箇中文的解釋器
       以這個中文的解釋器爲元解釋器再寫出純中文的解釋器就是可以解釋自身的了
       有趣之處在於這會完全改變寫代碼和讀代碼時的感受

*** table as procedures and value and the-meaning and meaning

    #+begin_src scheme
    (define the-empty-table
      (lambda (name)
        (abort
         (cons &apos;no-answer
               (cons name &apos;())))))
    (define global-table the-empty-table)
    (define lookup
      (lambda (table name)
        (table name)))
    ;; 在全局擴展global-table的是*define
    ;; 而*lambda作用於lambda-exp所形成的ciosure在作用於args時
    ;; 會爲closure的body臨時擴展global-table
    (define extend
      (lambda (name1 value table)
        (lambda (name2)
          (cond ((eq? name1 name2) value)
                (else (table name2))))))

    (define abort);; 遇到the-empty-table時跳出來報錯
    (define value
      (lambda (e)
        (letcc the-end
          (set! abort the-end)
          (cond ((define? e) (*define e))
                (else (the-meaning e))))))
    (define the-meaning
      (lambda (e)
        (meaning e lookup-in-global-table)))
    (define meaning
      (lambda (e table)
        ((expression-to-action e) e table)))
    (define lookup-in-global-table
      (lambda (name)
        (lookup global-table name)))
    ;; 這裏通過調用lookup來作一個closure
    ;; 這個closure把當前的global-table保護起來
    ;; (define lookup-in-global-table
    ;;   (lambda (name) (global-table name)))
    ;; 爲什麼需要這個closure？
    ;; 保護起來的意思就是要延遲這個closure的body的求值
    ;; 使得求值時這個body中的global-table可以是最新的
    ;; 現在懂得使用closure的技巧了
    ;; 正是這種技巧使得利用define來定義遞歸函數成爲可能
    ;; 這樣也就明白了Y!和letrec
    #+end_src

*** classification

    #+begin_src scheme
    (define expression-to-action
      (lambda (e)
        (cond ((atom? e) (atom-to-action e))
              (else (list-to-action e)))))
    (define atom-to-action
      (lambda (e)
        (cond [(number? e) *const]
              [(eq? e #t) *const]
              [(eq? e #f) *const]
              [(eq? e &apos;cons) *const]
              [(eq? e &apos;car) *const]
              [(eq? e &apos;cdr) *const]
              [(eq? e &apos;null?) *const]
              [(eq? e &apos;eq?) *const]
              [(eq? e &apos;atom?) *const]
              [(eq? e &apos;zero?) *const]
              [(eq? e &apos;add1) *const]
              [(eq? e &apos;sub1) *const]
              [(eq? e &apos;number?) *const]
              [else *identifer])))
    (define list-to-action
      (lambda (e)
        (cond [(null? e) *null]
              [(atom? (car e))
               (cond [(eq? (car e) &apos;quote)
                      ,*quote]
                     [(eq? (car e) &apos;lambda)
                      ,*lambda]
                     [(eq? (car e) &apos;letcc)
                      ,*letcc]
                     [(eq? (car e) &apos;set!)
                      ,*set]
                     [(eq? (car e) &apos;cond)
                      ,*cond]
                     [else *application])]
              [else *application])))
    #+end_src

*** *define and box

    #+begin_src scheme
    (define define?
      (lambda (e)
        (cond ((atom? e) #f)
              ((atom? (car e))
               (eq? (car e) &apos;define))
              (else #f))))
    (define *define
      (lambda (e)
        (set! global-table
              (extend (name-of e)
                      (box (the-meaning
                            (rigth-side-of e)))
                      global-table))))
    (define box
      (lambda (it)
        (lambda (selector)
          (selector it
                    (lambda (new) (set! it new))))))
    ;; 下面是兩個selector
    ;; selector的用法是：(從哪選 (lambda (有那些) (選哪個與如何處理)))
    (define setbox
      (lambda (box new)
        (box (lambda (it set) (set new)))))
    (define unbox
      (lambda (box)
        (box (lambda (it set) it))))
    #+end_src

*** *null

    #+begin_src scheme
    (define *null
      (lambda (e table)
        &apos;()))
    #+end_src

*** *quote

    #+begin_src scheme
    (define *quote
      (lambda (e table)
        (text-of e)))
    #+end_src

*** *identifer and *set

    #+begin_src scheme
    (define *identifer
      (lambda (e table)
        (unbox (lookup table e))))
    (define *set
      (lambda (e table)
        (setbox (lookup table (name-of e))
                (meaning (rigth-side-of e) table))))
    #+end_src

*** *lambda

    1. 這裏實現了在&lt;body&gt;中可以包含多個&lt;sexp&gt;這一特性
       *lambda作用於e與table將形成一個元解釋器中的closure
       這個closure作用時beglis將在擴展的table中對&lt;body&gt;求值
       closure作用的時候evlis返回的參數值會被處理爲list
       所以這裏使用了args這個形參名
       + 在下面的*const中還需要把這些參數從args中拿出來再讓primitive作用
         但是closure的作用僅僅是利用args來擴展table因此不需要這樣
    2. 這裏*lambda所形成的closure用元解釋器中的closure來實現了
       這樣就不用分別實現primitive與non-primitive的apply了
       但是這是必須的嗎？
       畢竟在上一個解釋器中我能學到關於closure的知識
       正是因爲我用一個數據結構實現了closure
    #+begin_src scheme
    (define *lambda
      (lambda (e table)
        (lambda (args)
          (beglis (body-of e)
                  (multi-extend (formals-of e)
                                (box-all args)
                                table)))))
    ;; beglis denote? begain list
    ;; 它對&lt;body&gt;中的所有&lt;sexp&gt;求值
    ;; 只返回最後一個&lt;sexp&gt;的值 其他的&lt;sexp&gt;用來形成副作用
    (define beglis
      (lambda (es table)
        (cond ((null? (cdr es));so body-of e con&apos;t be empty
               (meaning (car es) table))
              (else
               ;; 這裏需要一個賦值
               ;; 因爲後面的東西(beglis (cdr es) table)
               ;; 需要在前面的副作用所形成新環境中求值
               ((lambda (val)
                  (beglis (cdr es) table))
                (meaning (car es) table))))))
    (define box-all
      (lambda (vals)
        (cond ((null? vals) &apos;())
              (else
               (cons (box (car vals))
                     (box-all (cdr vals)))))))
    (define multi-extend
      (lambda (names values table)
        (cond ((null? names) table)
              (else
               (extend (car names)
                       (car values)
                       (multi-extend (cdr names)
                                     (cdr values)
                                     table))))))
    #+end_src

*** *application

    #+begin_src scheme
    (define *application
      (lambda (e table)
        ((meaning (function-of e) table)
         (evlis (arguments-of e) table))))
    (define evlis
      (lambda (args table)
        (cond ((null? args) &apos;())
              (else
               ;; 這裏爲什麼需要一個賦值？
               ;; 賦值在於在作用之前就先求某些表達式的值
               ;; 賦值在於控制求值順序
               ;; 需要這個賦值可能是因爲我們不能預料cons對它參數的求值順序
               ((lambda (val)
                  (cons val
                        (evlis (cdr args) table)))
                (meaning (car args) table))))))
    #+end_src

*** *const

    #+begin_src scheme
    ;; 因爲evlis返回的參數值會被處理爲list
    ;; 所以用下面的兩個東西把參數從args-in-a-list中拿出來
    (define a-prim
      (lambda (p)
        (lambda (args-in-a-list)
          (p (car args-in-a-list)))))
    (define b-prim
      (lambda (p)
        (lambda (args-in-a-list)
          (p (car args-in-a-list)
             (cadr args-in-a-list)))))
    ;; 避免重複使用a-prim與b-prim
    ;; 因此在最外層對它們的作用結果進行賦值
    ;; 這樣定義*const後 以*const爲名字的closure中
    ;; 這些本來需要被a-prim與b-prim作用才能獲得的值
    ;; 只要經過一個*identifer的查找就能獲得了
    (define *const
      ((lambda (:cons :car :cdr :null? :eq? :atom? :zero? :add1 :sub1 :number?)
         (lambda (e table)
           (cond ((number? e) e)
                 ((eq? e #t) #t)
                 ((eq? e #f) #f)
                 ((eq? e &apos;cons) :cons)
                 ((eq? e &apos;car) :car)
                 ((eq? e &apos;cdr) :cdr)
                 ((eq? e &apos;null?) :null?)
                 ((eq? e &apos;eq?) :eq?)
                 ((eq? e &apos;atom?) :atom?)
                 ((eq? e &apos;zero?) :zero?)
                 ((eq? e &apos;add1) :add1)
                 ((eq? e &apos;sub1) :sub1)
                 ((eq? e &apos;number?) :number?)
                 )))
       (b-prim cons)
       (a-prim car)
       (a-prim cdr)
       (a-prim null?)
       (b-prim eq?)
       (a-prim atom?)
       (a-prim zero?)
       (a-prim add1)
       (a-prim sub1)
       (a-prim number?)
       ))
    #+end_src

*** *cond

    #+begin_src scheme
    (define *cond
      (lambda (e table)
        (evcon (cond-lines-of e) table)))
    (define evcon
      (lambda (lines table)
        (cond ((else? (question-of (car lines)))
               (meaning (answer-of (car lines)) table))
              ((meaning (question-of (car lines)) table)
               (meaning (answer-of (car lines)) table))
              (else (evcon (cdr lines) table)))))
    #+end_src

*** *letcc

    #+begin_src scheme
    ;; 其實寫解釋器學的就是closure的使用方式
    ;; 比如下面這個把letcc直接加入我的解釋器中的過程就根本不觸及letcc的本質
    (define *letcc
      (lambda (e table)
        (letcc skip
               (beglis (ccbody-of e)
                       (extend (name-of e)
                               (box (a-prim skip))
                               table)))))
    #+end_src

*** auxiliary functions

    #+begin_src scheme
    (define text-of
      (lambda (x) (car (cdr x))))
    (define formals-of
      (lambda (x) (car (cdr x))))
    (define body-of
      (lambda (x) (cdr (cdr x))))
    (define ccbody-of
      (lambda (x) (cdr (cdr x))))
    (define name-of
      (lambda (x) (car (cdr x))))
    (define rigth-side-of
      (lambda (x)
        (cond ((null? (cdr (cdr x))) 0)
              ;; this handles definitions like (define kkk)
              (else (car (cdr (cdr x)))))))
    (define cond-lines-of
      (lambda (x) (cdr x)))
    (define else?
      (lambda (x)
        (cond ((atom? x) (eq? x &apos;else))
              (else #f))))
    (define question-of
      (lambda (x) (car x)))
    (define answer-of
      (lambda (x) (car (cdr x))))
    (define function-of
      (lambda (x) (car x)))
    (define arguments-of
      (lambda (x) (cdr x)))
    #+end_src

    use (let ...) to name the values of repeated expressions
    in a function definition if they may be evaluated twice
    for one and the same use of the function
    and use (let ...) to name the values of expressions (without set!)
    that are re-evaluated every time a function is used

*** 測試於下面的中文元解釋器

* 中文解釋器零

  除了把所有的語法詞與基礎函數名翻譯成中文以外
  這個解釋器同上面的解釋器完全一樣
  是寫在元解釋器中的
  而之所以又稱之爲 零
  是因爲 就下面的中文解釋器而言它是元解釋器

*** table as procedures and value and the-meaning and meaning

    #+begin_src scheme
    (define the-empty-table
      (lambda (name)
        (abort
         (cons &apos;no-answer
               (cons name &apos;())))))
    (define global-table the-empty-table)
    (define lookup
      (lambda (table name)
        (table name)))
    (define extend
      (lambda (name1 value table)
        (lambda (name2)
          (cond [(eq? name1 name2) value]
                [else (table name2)]))))

    (define abort)
    (define 求
      (lambda (e)
        (letcc the-end
               (set! abort the-end)
               (cond [(define? e) (*define e)]
                     [else (the-meaning e)]))))
    (define the-meaning
      (lambda (e)
        (meaning e lookup-in-global-table)))
    (define meaning
      (lambda (e table)
        ((expression-to-action e) e table)))
    (define lookup-in-global-table
      (lambda (name)
        (lookup global-table name)))
    #+end_src

*** classification

    #+begin_src scheme
    (define expression-to-action
      (lambda (e)
        (cond ((atom? e) (atom-to-action e))
              (else (list-to-action e)))))
    (define atom-to-action
      (lambda (e)
        (cond ((number? e) *const)
              ((eq? e #t) *const)
              ((eq? e #f) *const)
              ((eq? e &apos;鏈) *const)
              ((eq? e &apos;容) *const)
              ((eq? e &apos;址) *const)
              ((eq? e &apos;空?) *const)
              ((eq? e &apos;等?) *const)
              ((eq? e &apos;原子?) *const)
              ((eq? e &apos;零?) *const)
              ((eq? e &apos;增一) *const)
              ((eq? e &apos;減一) *const)
              ((eq? e &apos;數?) *const)
              (else *identifer))))
    (define list-to-action
      (lambda (e)
        (cond [(null? e) *null]
              [(atom? (car e))
               (cond [(eq? (car e) &apos;引)
                      ,*quote]
                     [(eq? (car e) &apos;λ)
                      ,*lambda]
                     [(eq? (car e) &apos;捕)
                      ,*letcc]
                     [(eq? (car e) &apos;置!)
                      ,*set]
                     [(eq? (car e) &apos;控)
                      ,*cond]
                     [else *application]
                     )]
              [else *application]
              )))
    #+end_src

*** *define and box

    #+begin_src scheme
    (define define?
      (lambda (e)
        (cond ((atom? e) #f)
              ((atom? (car e))
               (eq? (car e) &apos;定))
              (else #f))))
    (define *define
      (lambda (e)
        (set! global-table
              (extend (name-of e)
                      (box (the-meaning
                            (rigth-side-of e)))
                      global-table))))
    (define box
      (lambda (it)
        (lambda (selector)
          (selector it
                    (lambda (new) (set! it new))))))

    (define setbox
      (lambda (box new)
        (box (lambda (it set) (set new)))))
    (define unbox
      (lambda (box)
        (box (lambda (it set) it))))
    #+end_src

*** *null

    #+begin_src scheme
    (define *null
      (lambda (e table)
        &apos;()))
    #+end_src

*** *quote

    #+begin_src scheme
    (define *quote
      (lambda (e table)
        (text-of e)))
    #+end_src

*** *identifer and *set

    #+begin_src scheme
    (define *identifer
      (lambda (e table)
        (unbox (lookup table e))))
    (define *set
      (lambda (e table)
        (setbox (lookup table (name-of e))
                (meaning (rigth-side-of e) table))))
    #+end_src

*** *lambda

    #+begin_src scheme
    (define *lambda
      (lambda (e table)
        (lambda (args)
          (beglis (body-of e)
                  (multi-extend (formals-of e)
                                (box-all args)
                                table)))))

    (define beglis
      (lambda (es table)
        (cond ((null? (cdr es))
               (meaning (car es) table))
              (else
               ((lambda (val)
                  (beglis (cdr es) table))
                (meaning (car es) table))))))
    (define box-all
      (lambda (vals)
        (cond ((null? vals) &apos;())
              (else
               (cons (box (car vals))
                     (box-all (cdr vals)))))))
    (define multi-extend
      (lambda (names values table)
        (cond ((null? names) table)
              (else
               (extend (car names)
                       (car values)
                       (multi-extend (cdr names)
                                     (cdr values)
                                     table))))))
    #+end_src

*** *application

    #+begin_src scheme
    (define *application
      (lambda (e table)
        ((meaning (function-of e) table)
         (evlis (arguments-of e) table))))
    (define evlis
      (lambda (args table)
        (cond ((null? args) &apos;())
              (else
               ((lambda (val)
                  (cons val
                        (evlis (cdr args) table)))
                (meaning (car args) table))))))
    #+end_src

*** *const

    #+begin_src scheme
    (define a-prim
      (lambda (p)
        (lambda (args-in-a-list)
          (p (car args-in-a-list)))))
    (define b-prim
      (lambda (p)
        (lambda (args-in-a-list)
          (p (car args-in-a-list)
             (car (cdr args-in-a-list))))))
    (define *const
      ((lambda (:cons :car :cdr :null? :eq? :atom? :zero? :add1 :sub1 :number?)
         (lambda (e table)
           (cond ((number? e) e)
                 ((eq? e #t) #t)
                 ((eq? e #f) #f)
                 ((eq? e &apos;鏈) :cons)
                 ((eq? e &apos;容) :car)
                 ((eq? e &apos;址) :cdr)
                 ((eq? e &apos;空?) :null?)
                 ((eq? e &apos;等?) :eq?)
                 ((eq? e &apos;原子?) :atom?)
                 ((eq? e &apos;零?) :zero?)
                 ((eq? e &apos;增一) :add1)
                 ((eq? e &apos;減一) :sub1)
                 ((eq? e &apos;數?) :number?)
                 )))
       (b-prim cons)
       (a-prim car)
       (a-prim cdr)
       (a-prim null?)
       (b-prim eq?)
       (a-prim atom?)
       (a-prim zero?)
       (a-prim add1)
       (a-prim sub1)
       (a-prim number?)
       ))
    #+end_src

*** *cond

    #+begin_src scheme
    (define *cond
      (lambda (e table)
        (evcon (cond-lines-of e) table)))
    (define evcon
      (lambda (lines table)
        (cond ((else? (question-of (car lines)))
               (meaning (answer-of (car lines)) table))
              ((meaning (question-of (car lines)) table)
               (meaning (answer-of (car lines)) table))
              (else (evcon (cdr lines) table)))))
    #+end_src

*** *letcc

    #+begin_src scheme
    (define *letcc
      (lambda (e table)
        (letcc skip
               (beglis (ccbody-of e)
                       (extend (name-of e)
                               (box (a-prim skip))
                               table)))))
    #+end_src

*** auxiliary functions

    #+begin_src scheme
    (define text-of
      (lambda (x) (car (cdr x))))
    (define formals-of
      (lambda (x) (car (cdr x))))
    (define body-of
      (lambda (x) (cdr (cdr x))))
    (define ccbody-of
      (lambda (x) (cdr (cdr x))))
    (define name-of
      (lambda (x) (car (cdr x))))
    (define rigth-side-of
      (lambda (x)
        (cond ((null? (cdr (cdr x))) 0)
              (else (car (cdr (cdr x)))))))
    (define cond-lines-of
      (lambda (x) (cdr x)))
    (define else?
      (lambda (x)
        (cond ((atom? x) (eq? x &apos;否則))
              (else #f))))
    (define question-of
      (lambda (x) (car x)))
    (define answer-of
      (lambda (x) (car (cdr x))))
    (define function-of
      (lambda (x) (car x)))
    (define arguments-of
      (lambda (x) (cdr x)))
    #+end_src

* 中文解釋器一

*** &gt;&lt; 記
    1. [X] 用kkk而不用ccc
    2. [ ] 加入apply
       這可能嗎?
    3. [ ] 補全&lt;formals&gt;的形式：
       &lt;variable&gt;
       (&lt;variable&gt;*)
       (&lt;variable&gt; &lt;variable&gt;* . &lt;variable&gt;)
    4. [ ] 補全用於創造語法的匹配語言
       匹配語言是同樣重要的
    5. 在解釋器中寫解釋器
       可以作爲一種方式來漸進地改變解釋器的性質
       但是非常慢
       有沒有方法優化?
    6. 如果是編譯器那很可能就可以優化
       保持所編譯處理的東西能編譯自身
       並且生成的目標代碼質量相同
       那就是實現了編譯器的層進開發

*** 表 求 其意 意

    #+begin_src scheme
    (定 空表
        (λ (名)
            (失敗
             (鏈 (引 無值之名)
                 (鏈 名 (引 ()))))))
    (定 總表 空表)
    (定 查
        (λ (表 名)
            (表 名)))
    (定 擴展
        (λ (名1 值 表)
            (λ (名2)
                (控 [(等? 名1 名2) 值]
                    [否則 (表 名2)]))))

    (定 失敗)
    (定 求
        (λ (e)
            (捕 終
                (置! 失敗 終)
                (控 [(定? e) (*定 e)]
                    [否則 (其意 e)]))))
    (定 其意
        (λ (e)
            (意 e 查總表)))
    (定 意
        (λ (e 表)
            ((式之作用 e) e 表)))
    (定 查總表
        (λ (名)
            (查 總表 名)))
    #+end_src

*** 分類

    #+begin_src scheme
    (定 式之作用
        (λ (e)
            (控 [(原子? e) (原子之作用 e)]
                [否則 (鏈之作用 e)])))
    (定 原子之作用
        (λ (e)
            (控 [(數? e) *常元]
                [(等? e #t) *常元]
                [(等? e #f) *常元]
                [(等? e (引 鏈)) *常元]
                [(等? e (引 容)) *常元]
                [(等? e (引 址)) *常元]
                [(等? e (引 空?)) *常元]
                [(等? e (引 等?)) *常元]
                [(等? e (引 原子?)) *常元]
                [(等? e (引 零?)) *常元]
                [(等? e (引 增一)) *常元]
                [(等? e (引 減一)) *常元]
                [(等? e (引 數?)) *常元]
                [否則 *變元])))
    (定 鏈之作用
        (λ (e)
            (控 [(空? e) *空]
                [(原子? (容 e))
                 (控 [(等? (容 e) (引 引))
                      *引]
                     [(等? (容 e) (引 λ))
                      *λ]
                     [(等? (容 e) (引 捕))
                      *捕]
                     [(等? (容 e) (引 置!))
                      *置]
                     [(等? (容 e) (引 控))
                      *控]
                     [否則 *作用])]
                [否則 *作用])))
    #+end_src

*** *定 盒

    #+begin_src scheme
    (定 定?
        (λ (e)
            (控 [(原子? e) #f]
                [(原子? (容 e))
                 (等? (容 e) (引 定))]
                [否則 #f])))
    (定 *定
        (λ (e)
            (置! 總表
                 (擴展 (名部 e)
                       (盒 (其意
                            (值部 e)))
                       總表))))
    (定 盒
        (λ (物)
            (λ (選擇子)
                (選擇子 物
                        (λ (新物) (置! 物 新物))))))
    ;; 下面是兩個選擇子
    (定 重置盒
        (λ (盒 新物)
            (盒 (λ (之物 之置) (之置 新物)))))
    (定 取於盒
        (λ (盒)
            (盒 (λ (之物 之置) 之物))))
    #+end_src

*** *空

    #+begin_src scheme
    (定 *空
        (λ (e 表)
            (引 ())))
    #+end_src

*** *引

    #+begin_src scheme
    (定 *引
      (λ (e 表)
        (文部 e)))
    #+end_src

*** *變元 *置

    #+begin_src scheme
    (定 *變元
        (λ (e 表)
            (取於盒 (查 表 e))))
    (定 *置
        (λ (e 表)
            (重置盒 (查 表 (名部 e))
                    (意 (值部 e) 表))))
    #+end_src

*** *λ

    #+begin_src scheme
    (定 *λ
        (λ (e 表)
          (λ (實參鏈)
            (求於體 (體部 e)
                    (多擴展 (形參部 e)
                            (多盒 實參鏈)
                            表)))))

    (定 求於體
        (λ (式鏈 表)
          (控 [(空? (址 式鏈))
               (意 (容 式鏈) 表)]
              [否則
               ((λ (賦參)
                  (求於體 (址 式鏈) 表))
                (意 (容 式鏈) 表))])))
    (定 多盒
        (λ (實參鏈)
          (控 [(空? 實參鏈) (引 ())]
              [否則
               (鏈 (盒 (容 實參鏈))
                   (多盒 (址 實參鏈)))])))
    (定 多擴展
        (λ (名鏈 值鏈 表)
          (控 [(空? 名鏈) 表]
              [否則
               (擴展 (容 名鏈)
                     (容 值鏈)
                     (多擴展 (址 名鏈)
                             (址 值鏈)
                             表))])))
    #+end_src

*** *作用

    #+begin_src scheme
    (定 *作用
        (λ (e 表)
            ((意 (函數部 e) 表)
             (求於鏈 (參數鏈部 e) 表))))
    (定 求於鏈
        (λ (式鏈 表)
            (控 [(空? 式鏈) (引 ())]
                [否則
                 ((λ (賦參)
                      (鏈 賦參
                          (求於鏈 (址 式鏈) 表)))
                  (意 (容 式鏈) 表))]
                )))
    #+end_src

*** *常元

    #+begin_src scheme
    (定 準備一元函數
        (λ (一元函數)
            (λ (實參鏈)
                (一元函數 (容 實參鏈)))))
    (定 準備二元函數
        (λ (二元函數)
            (λ (實參鏈)
                (二元函數 (容 實參鏈)
                          (容 (址 實參鏈))))))

    (定 *常元
        ((λ (:鏈 :容 :址
                  :空? :等? :原子?
                  :零? :增一 :減一 :數?)
             (λ (e 表)
                 (控 [(數? e) e]
                     [(等? e #t) #t]
                     [(等? e #f) #f]
                     [(等? e (引 鏈)) :鏈]
                     [(等? e (引 容)) :容]
                     [(等? e (引 址)) :址]
                     [(等? e (引 空?)) :空?]
                     [(等? e (引 等?)) :等?]
                     [(等? e (引 原子?)) :原子?]
                     [(等? e (引 零?)) :零?]
                     [(等? e (引 增一)) :增一]
                     [(等? e (引 減一)) :減一]
                     [(等? e (引 數?)) :數?]
                     )))
         (準備二元函數 鏈)
         (準備一元函數 容)
         (準備一元函數 址)
         (準備一元函數 空?)
         (準備二元函數 等?)
         (準備一元函數 原子?)
         (準備一元函數 零?)
         (準備一元函數 增一)
         (準備一元函數 減一)
         (準備一元函數 數?)
         ))

    ;; 用λ實現鏈 很容易通過增加鏈中被選之物 來改變鏈的結構
    (定 初鏈
        (λ (容)
            ((λ (賦址)
                 (λ (選擇子)
                     (選擇子 (λ (x) (置! 賦址 x))
                             容
                             賦址)))
             (引 ()))))
    (定 鏈
        (λ (容 址)
            ((λ (賦鏈)
                 (置址 賦鏈 址)
                 賦鏈)
             (初鏈 容))))
    (定 置址
        (λ (鏈 新址)
            ((鏈 (λ (之置 之容 之址) 之置))
             新址)))
    (定 容
        (λ (鏈)
            (鏈 (λ (之置 之容 之址) 之容))))
    (定 址
        (λ (鏈)
            (鏈 (λ (之置 之容 之址) 之址))))
    #+end_src

*** *控

    #+begin_src scheme
    (定 *控
        (λ (e 表)
            (求於控 (問答鏈部 e) 表)))
    (定 求於控
        (λ (問答鏈 表)
            (控 [(否則? (問部 (容 問答鏈)))
                 (意 (答部 (容 問答鏈)) 表)]
                [(意 (問部 (容 問答鏈)) 表)
                 (意 (答部 (容 問答鏈)) 表)]
                [否則 (求於控 (址 問答鏈) 表)]
                )))
    #+end_src

*** *捕

    #+begin_src scheme
    (定 *捕
        (λ (e 表)
          (捕 捕之標
              (求於體 (捕之體部 e)
                      (擴展 (名部 e)
                            (盒 (準備一元函數 捕之標))
                            表)))))
    #+end_src

*** 輔

    #+begin_src scheme
    (定 文部
        (λ (x) (容 (址 x))))
    (定 形參部
        (λ (x) (容 (址 x))))
    (定 體部
        (λ (x) (址 (址 x))))
    (定 捕之體部
        (λ (x) (址 (址 x))))
    (定 名部
        (λ (x) (容 (址 x))))
    (定 值部
        (λ (x)
            (控 [(空? (址 (址 x))) 0]
                [否則 (容 (址 (址 x)))]
                )))
    (定 問答鏈部
        (λ (x) (址 x)))
    (定 否則?
        (λ (x)
            (控 [(原子? x) (等? x (引 否則))]
                [否則 #f]
                )))
    (定 問部
        (λ (x) (容 x)))
    (定 答部
        (λ (x) (容 (址 x))))
    (定 函數部
        (λ (x) (容 x)))
    (定 參數鏈部
        (λ (x) (址 x)))
    #+end_src

* 測試

*** load one

    #+name: 在元解釋器中加載value一層
    #+begin_src scheme
    ;; (load &quot;dependence.scm&quot;)
    ;; (load &quot;interpreter-with-define-and-set!.scm&quot;)

    (value
     &apos;(define the-empty-table
        (lambda (name)
          (abort
           (cons &apos;no-answer
                 (cons name &apos;()))))))
    ;; ((value &apos;value) &apos;the-empty-table)
    (value
     &apos;(define global-table the-empty-table))
    (value
     &apos;(define lookup
        (lambda (table name)
          (table name))))
    ;; 在全局擴展global-table的是*define
    ;; 而*lambda作用於lambda-exp所形成的ciosure在作用於args時
    ;; 會爲closure的body臨時擴展global-table
    (value
     &apos;(define extend
        (lambda (name1 value table)
          (lambda (name2)
            (cond ((eq? name1 name2) value)
                  (else (table name2)))))))

    (value
     &apos;(define abort)) ;; 遇到the-empty-table時跳出來報錯
    (value
     &apos;(define value
        (lambda (e)
          (letcc the-end
                 (set! abort the-end)
                 (cond ((define? e) (*define e))
                       (else (the-meaning e)))))))
    (value
     &apos;(define the-meaning
        (lambda (e)
          (meaning e lookup-in-global-table))))
    (value
     &apos;(define meaning
        (lambda (e table)
          ((expression-to-action e) e table))))
    (value
     &apos;(define lookup-in-global-table
        (lambda (name)
          (lookup global-table name))))
    ;; 這裏通過調用lookup來作一個closure
    ;; 這個closure把當前的global-table保護起來
    ;; (define lookup-in-global-table
    ;;   (lambda (name) (global-table name)))
    ;; 爲什麼需要這個closure？
    ;; 保護起來的意思就是要延遲這個closure的body的求值
    ;; 使得求值時這個body中的global-table可以是最新的
    ;; 現在懂得使用closure的技巧了
    ;; 正是這種技巧使得利用define來定義遞歸函數成爲可能
    ;; 這樣也就明白了Y!和letrec

    (value
     &apos;(define expression-to-action
        (lambda (e)
          (cond ((atom? e) (atom-to-action e))
                (else (list-to-action e))))))
    (value
     &apos;(define atom-to-action
        (lambda (e)
          (cond [(number? e) *const]
                [(eq? e #t) *const]
                [(eq? e #f) *const]
                [(eq? e &apos;cons) *const]
                [(eq? e &apos;car) *const]
                [(eq? e &apos;cdr) *const]
                [(eq? e &apos;null?) *const]
                [(eq? e &apos;eq?) *const]
                [(eq? e &apos;atom?) *const]
                [(eq? e &apos;zero?) *const]
                [(eq? e &apos;add1) *const]
                [(eq? e &apos;sub1) *const]
                [(eq? e &apos;number?) *const]
                [else *identifer]))))
    (value
     &apos;(define list-to-action
        (lambda (e)
          (cond [(null? e) *null]
                [(atom? (car e))
                 (cond [(eq? (car e) &apos;quote)
                        ,*quote]
                       [(eq? (car e) &apos;lambda)
                        ,*lambda]
                       [(eq? (car e) &apos;letcc)
                        ,*letcc]
                       [(eq? (car e) &apos;set!)
                        ,*set]
                       [(eq? (car e) &apos;cond)
                        ,*cond]
                       [else *application])]
                [else *application]))))

    (value
     &apos;(define define?
        (lambda (e)
          (cond ((atom? e) #f)
                ((atom? (car e))
                 (eq? (car e) &apos;define))
                (else #f)))))
    (value
     &apos;(define *define
        (lambda (e)
          (set! global-table
                (extend (name-of e)
                        (box (the-meaning
                              (rigth-side-of e)))
                        global-table)))))
    (value
     &apos;(define box
        (lambda (it)
          (lambda (selector)
            (selector it
                      (lambda (new) (set! it new)))))))
    ;; 下面是兩個selector
    ;; selector的用法是：(從哪選 (lambda (有那些) (選哪個與如何處理)))
    (value
     &apos;(define setbox
        (lambda (box new)
          (box (lambda (it set) (set new))))))
    (value
     &apos;(define unbox
        (lambda (box)
          (box (lambda (it set) it)))))

    (value
     &apos;(define *null
        (lambda (e table)
          &apos;())))

    (value
     &apos;(define *quote
        (lambda (e table)
          (text-of e))))

    (value
     &apos;(define *identifer
        (lambda (e table)
          (unbox (lookup table e)))))
    (value
     &apos;(define *set
        (lambda (e table)
          (setbox (lookup table (name-of e))
                  (meaning (rigth-side-of e) table)))))

    (value
     &apos;(define *lambda
        (lambda (e table)
          (lambda (args)
            (beglis (body-of e)
                    (multi-extend (formals-of e)
                                  (box-all args)
                                  table))))))
    ;; beglis denote? begain list
    ;; 它對&lt;body&gt;中的所有&lt;sexp&gt;求值
    ;; 只返回最後一個&lt;sexp&gt;的值 其他的&lt;sexp&gt;用來形成副作用
    (value
     &apos;(define beglis
        (lambda (es table)
          (cond ((null? (cdr es))           ;so body-of e con&apos;t be empty
                 (meaning (car es) table))
                (else
                 ;; 這裏需要一個賦值
                 ;; 因爲後面的東西(beglis (cdr es) table)
                 ;; 需要在前面的副作用所形成新環境中求值
                 ((lambda (val)
                    (beglis (cdr es) table))
                  (meaning (car es) table)))))))
    (value
     &apos;(define box-all
        (lambda (vals)
          (cond ((null? vals) &apos;())
                (else
                 (cons (box (car vals))
                       (box-all (cdr vals))))))))
    (value
     &apos;(define multi-extend
        (lambda (names values table)
          (cond ((null? names) table)
                (else
                 (extend (car names)
                         (car values)
                         (multi-extend (cdr names)
                                       (cdr values)
                                       table)))))))

    (value
     &apos;(define *application
        (lambda (e table)
          ((meaning (function-of e) table)
           (evlis (arguments-of e) table)))))
    (value
     &apos;(define evlis
        (lambda (args table)
          (cond ((null? args) &apos;())
                (else
                 ;; 這裏爲什麼需要一個賦值？
                 ;; 賦值在於在作用之前就先求某些表達式的值
                 ;; 賦值在於控制求值順序
                 ;; 需要這個賦值可能是因爲我們不能預料cons對它參數的求值順序
                 ((lambda (val)
                    (cons val
                          (evlis (cdr args) table)))
                  (meaning (car args) table)))))))

    ;; 因爲evlis返回的參數值會被處理爲list
    ;; 所以用下面的兩個東西把參數從args-in-a-list中拿出來
    (value
     &apos;(define a-prim
        (lambda (p)
          (lambda (args-in-a-list)
            (p (car args-in-a-list))))))
    (value
     &apos;(define b-prim
        (lambda (p)
          (lambda (args-in-a-list)
            (p (car args-in-a-list)
               (car (cdr args-in-a-list)))))))
    ;; 避免重複使用a-prim與b-prim
    ;; 因此在最外層對它們的作用結果進行賦值
    ;; 這樣定義*const後 以*const爲名字的closure中
    ;; 這些本來需要被a-prim與b-prim作用才能獲得的值
    ;; 只要經過一個*identifer的查找就能獲得了
    (value
     &apos;(define *const
        ((lambda (:cons :car :cdr :null? :eq? :atom? :zero? :add1 :sub1 :number?)
           (lambda (e table)
             (cond ((number? e) e)
                   ((eq? e #t) #t)
                   ((eq? e #f) #f)
                   ((eq? e &apos;cons) :cons)
                   ((eq? e &apos;car) :car)
                   ((eq? e &apos;cdr) :cdr)
                   ((eq? e &apos;null?) :null?)
                   ((eq? e &apos;eq?) :eq?)
                   ((eq? e &apos;atom?) :atom?)
                   ((eq? e &apos;zero?) :zero?)
                   ((eq? e &apos;add1) :add1)
                   ((eq? e &apos;sub1) :sub1)
                   ((eq? e &apos;number?) :number?)
                   )))
         (b-prim cons)
         (a-prim car)
         (a-prim cdr)
         (a-prim null?)
         (b-prim eq?)
         (a-prim atom?)
         (a-prim zero?)
         (a-prim add1)
         (a-prim sub1)
         (a-prim number?)
         )))

    (value
     &apos;(define *cond
        (lambda (e table)
          (evcon (cond-lines-of e) table))))
    (value
     &apos;(define evcon
        (lambda (lines table)
          (cond ((else? (question-of (car lines)))
                 (meaning (answer-of (car lines)) table))
                ((meaning (question-of (car lines)) table)
                 (meaning (answer-of (car lines)) table))
                (else (evcon (cdr lines) table))))))

    ;; 其實寫解釋器學的就是closure的使用方式
    ;; 比如下面這個把letcc直接加入我的解釋器中的過程就根本不觸及letcc的本質
    (value
     &apos;(define *letcc
        (lambda (e table)
          (letcc skip
                 (beglis (ccbody-of e)
                         (extend (name-of e)
                                 (box (a-prim skip))
                                 table))))))

    (value
     &apos;(define text-of
        (lambda (x) (car (cdr x)))))
    (value
     &apos;(define formals-of
        (lambda (x) (car (cdr x)))))
    (value
     &apos;(define body-of
        (lambda (x) (cdr (cdr x)))))
    (value
     &apos;(define ccbody-of
        (lambda (x) (cdr (cdr x)))))
    (value
     &apos;(define name-of
        (lambda (x) (car (cdr x)))))
    (value
     &apos;(define rigth-side-of
        (lambda (x)
          (cond ((null? (cdr (cdr x))) 0)
                ;; this handles definitions like (define kkk)
                (else (car (cdr (cdr x))))))))
    (value
     &apos;(define cond-lines-of
        (lambda (x) (cdr x))))
    (value
     &apos;(define else?
        (lambda (x)
          (cond ((atom? x) (eq? x &apos;else))
                (else #f)))))
    (value
     &apos;(define question-of
        (lambda (x) (car x))))
    (value
     &apos;(define answer-of
        (lambda (x) (car (cdr x)))))
    (value
     &apos;(define function-of
        (lambda (x) (car x))))
    (value
     &apos;(define arguments-of
        (lambda (x) (cdr x))))
    #+end_src

*** &gt;&lt; load two

    爲什麼需要list之後才能正常測試?

    #+name: 在value中加載value二層
    #+begin_src scheme
    ;; (define value-one
    ;;   (lambda (e)
    ;;     ((value &apos;value) e)))
    ;; (value-one
    ;;  &apos;((lambda (x) (cons 1 x)) 2))
    (define value-one
      (lambda (e)
        ((value &apos;value) (list e))))
    (value-one
     &apos;(define the-empty-table
        (lambda (name)
          (abort
           (cons &apos;no-answer
                 (cons name &apos;()))))))
    (value-one
     &apos;(define global-table the-empty-table))
    (value-one
     &apos;(define lookup
        (lambda (table name)
          (table name))))
    ;; 在全局擴展global-table的是*define
    ;; 而*lambda作用於lambda-exp所形成的ciosure在作用於args時
    ;; 會爲closure的body臨時擴展global-table
    (value-one
     &apos;(define extend
        (lambda (name1 value table)
          (lambda (name2)
            (cond ((eq? name1 name2) value)
                  (else (table name2)))))))

    (value-one
     &apos;(define abort)) ;; 遇到the-empty-table時跳出來報錯
    (value-one
     &apos;(define value
        (lambda (e)
          (letcc the-end
                 (set! abort the-end)
                 (cond ((define? e) (*define e))
                       (else (the-meaning e)))))))
    (value-one
     &apos;(define the-meaning
        (lambda (e)
          (meaning e lookup-in-global-table))))
    (value-one
     &apos;(define meaning
        (lambda (e table)
          ((expression-to-action e) e table))))
    (value-one
     &apos;(define lookup-in-global-table
        (lambda (name)
          (lookup global-table name))))
    ;; 這裏通過調用lookup來作一個closure
    ;; 這個closure把當前的global-table保護起來
    ;; (define lookup-in-global-table
    ;;   (lambda (name) (global-table name)))
    ;; 爲什麼需要這個closure？
    ;; 保護起來的意思就是要延遲這個closure的body的求值
    ;; 使得求值時這個body中的global-table可以是最新的
    ;; 現在懂得使用closure的技巧了
    ;; 正是這種技巧使得利用define來定義遞歸函數成爲可能
    ;; 這樣也就明白了Y!和letrec

    (value-one
     &apos;(define expression-to-action
        (lambda (e)
          (cond ((atom? e) (atom-to-action e))
                (else (list-to-action e))))))
    (value-one
     &apos;(define atom-to-action
        (lambda (e)
          (cond [(number? e) *const]
                [(eq? e #t) *const]
                [(eq? e #f) *const]
                [(eq? e &apos;cons) *const]
                [(eq? e &apos;car) *const]
                [(eq? e &apos;cdr) *const]
                [(eq? e &apos;null?) *const]
                [(eq? e &apos;eq?) *const]
                [(eq? e &apos;atom?) *const]
                [(eq? e &apos;zero?) *const]
                [(eq? e &apos;add1) *const]
                [(eq? e &apos;sub1) *const]
                [(eq? e &apos;number?) *const]
                [else *identifer]))))
    (value-one
     &apos;(define list-to-action
        (lambda (e)
          (cond [(null? e) *null]
                [(atom? (car e))
                 (cond [(eq? (car e) &apos;quote)
                        ,*quote]
                       [(eq? (car e) &apos;lambda)
                        ,*lambda]
                       [(eq? (car e) &apos;letcc)
                        ,*letcc]
                       [(eq? (car e) &apos;set!)
                        ,*set]
                       [(eq? (car e) &apos;cond)
                        ,*cond]
                       [else *application])]
                [else *application]))))

    (value-one
     &apos;(define define?
        (lambda (e)
          (cond ((atom? e) #f)
                ((atom? (car e))
                 (eq? (car e) &apos;define))
                (else #f)))))
    (value-one
     &apos;(define *define
        (lambda (e)
          (set! global-table
                (extend (name-of e)
                        (box (the-meaning
                              (rigth-side-of e)))
                        global-table)))))
    (value-one
     &apos;(define box
        (lambda (it)
          (lambda (selector)
            (selector it
                      (lambda (new) (set! it new)))))))
    ;; 下面是兩個selector
    ;; selector的用法是：(從哪選 (lambda (有那些) (選哪個與如何處理)))
    (value-one
     &apos;(define setbox
        (lambda (box new)
          (box (lambda (it set) (set new))))))
    (value-one
     &apos;(define unbox
        (lambda (box)
          (box (lambda (it set) it)))))

    (value-one
     &apos;(define *null
        (lambda (e table)
          &apos;())))

    (value-one
     &apos;(define *quote
        (lambda (e table)
          (text-of e))))

    (value-one
     &apos;(define *identifer
        (lambda (e table)
          (unbox (lookup table e)))))
    (value-one
     &apos;(define *set
        (lambda (e table)
          (setbox (lookup table (name-of e))
                  (meaning (rigth-side-of e) table)))))

    (value-one
     &apos;(define *lambda
        (lambda (e table)
          (lambda (args)
            (beglis (body-of e)
                    (multi-extend (formals-of e)
                                  (box-all args)
                                  table))))))
    ;; beglis denote? begain list
    ;; 它對&lt;body&gt;中的所有&lt;sexp&gt;求值
    ;; 只返回最後一個&lt;sexp&gt;的值 其他的&lt;sexp&gt;用來形成副作用
    (value-one
     &apos;(define beglis
        (lambda (es table)
          (cond ((null? (cdr es))           ;so body-of e con&apos;t be empty
                 (meaning (car es) table))
                (else
                 ;; 這裏需要一個賦值
                 ;; 因爲後面的東西(beglis (cdr es) table)
                 ;; 需要在前面的副作用所形成新環境中求值
                 ((lambda (val)
                    (beglis (cdr es) table))
                  (meaning (car es) table)))))))
    (value-one
     &apos;(define box-all
        (lambda (vals)
          (cond ((null? vals) &apos;())
                (else
                 (cons (box (car vals))
                       (box-all (cdr vals))))))))
    (value-one
     &apos;(define multi-extend
        (lambda (names values table)
          (cond ((null? names) table)
                (else
                 (extend (car names)
                         (car values)
                         (multi-extend (cdr names)
                                       (cdr values)
                                       table)))))))

    (value-one
     &apos;(define *application
        (lambda (e table)
          ((meaning (function-of e) table)
           (evlis (arguments-of e) table)))))
    (value-one
     &apos;(define evlis
        (lambda (args table)
          (cond ((null? args) &apos;())
                (else
                 ;; 這裏爲什麼需要一個賦值？
                 ;; 賦值在於在作用之前就先求某些表達式的值
                 ;; 賦值在於控制求值順序
                 ;; 需要這個賦值可能是因爲我們不能預料cons對它參數的求值順序
                 ((lambda (val)
                    (cons val
                          (evlis (cdr args) table)))
                  (meaning (car args) table)))))))

    ;; 因爲evlis返回的參數值會被處理爲list
    ;; 所以用下面的兩個東西把參數從args-in-a-list中拿出來
    (value-one
     &apos;(define a-prim
        (lambda (p)
          (lambda (args-in-a-list)
            (p (car args-in-a-list))))))
    (value-one
     &apos;(define b-prim
        (lambda (p)
          (lambda (args-in-a-list)
            (p (car args-in-a-list)
               (cadr args-in-a-list))))))
    ;; 避免重複使用a-prim與b-prim
    ;; 因此在最外層對它們的作用結果進行賦值
    ;; 這樣定義*const後 以*const爲名字的closure中
    ;; 這些本來需要被a-prim與b-prim作用才能獲得的值
    ;; 只要經過一個*identifer的查找就能獲得了
    (value-one
     &apos;(define *const
        ((lambda (:cons :car :cdr :null? :eq? :atom? :zero? :add1 :sub1 :number?)
           (lambda (e table)
             (cond ((number? e) e)
                   ((eq? e #t) #t)
                   ((eq? e #f) #f)
                   ((eq? e &apos;cons) :cons)
                   ((eq? e &apos;car) :car)
                   ((eq? e &apos;cdr) :cdr)
                   ((eq? e &apos;null?) :null?)
                   ((eq? e &apos;eq?) :eq?)
                   ((eq? e &apos;atom?) :atom?)
                   ((eq? e &apos;zero?) :zero?)
                   ((eq? e &apos;add1) :add1)
                   ((eq? e &apos;sub1) :sub1)
                   ((eq? e &apos;number?) :number?)
                   )))
         (b-prim cons)
         (a-prim car)
         (a-prim cdr)
         (a-prim null?)
         (b-prim eq?)
         (a-prim atom?)
         (a-prim zero?)
         (a-prim add1)
         (a-prim sub1)
         (a-prim number?)
         )))

    (value-one
     &apos;(define *cond
        (lambda (e table)
          (evcon (cond-lines-of e) table))))
    (value-one
     &apos;(define evcon
        (lambda (lines table)
          (cond ((else? (question-of (car lines)))
                 (meaning (answer-of (car lines)) table))
                ((meaning (question-of (car lines)) table)
                 (meaning (answer-of (car lines)) table))
                (else (evcon (cdr lines) table))))))

    ;; 其實寫解釋器學的就是closure的使用方式
    ;; 比如下面這個把letcc直接加入我的解釋器中的過程就根本不觸及letcc的本質
    (value-one
     &apos;(define *letcc
        (lambda (e table)
          (letcc skip
                 (beglis (ccbody-of e)
                         (extend (name-of e)
                                 (box (a-prim skip))
                                 table))))))

    (value-one
     &apos;(define text-of
        (lambda (x) (car (cdr x)))))
    (value-one
     &apos;(define formals-of
        (lambda (x) (car (cdr x)))))
    (value-one
     &apos;(define body-of
        (lambda (x) (cdr (cdr x)))))
    (value-one
     &apos;(define ccbody-of
        (lambda (x) (cdr (cdr x)))))
    (value-one
     &apos;(define name-of
        (lambda (x) (car (cdr x)))))
    (value-one
     &apos;(define rigth-side-of
        (lambda (x)
          (cond ((null? (cdr (cdr x))) 0)
                ;; this handles definitions like (define kkk)
                (else (car (cdr (cdr x))))))))
    (value-one
     &apos;(define cond-lines-of
        (lambda (x) (cdr x))))
    (value-one
     &apos;(define else?
        (lambda (x)
          (cond ((atom? x) (eq? x &apos;else))
                (else #f)))))
    (value-one
     &apos;(define question-of
        (lambda (x) (car x))))
    (value-one
     &apos;(define answer-of
        (lambda (x) (car (cdr x)))))
    (value-one
     &apos;(define function-of
        (lambda (x) (car x))))
    (value-one
     &apos;(define arguments-of
        (lambda (x) (cdr x))))
    #+end_src

*** 加載 零

    #+name: 在中文解釋器零中加載中文解釋器一
    #+begin_src scheme
    (load &quot;dependence.scm&quot;)
    (load &quot;中文解釋器零.scm&quot;)
    (求 &apos;(定 空表
             (λ (名)
                 (失敗
                  (鏈 (引 無值之名)
                      (鏈 名 (引 ())))))))

    (求 &apos;(定 空表
         (λ (名)
             (失敗
              (鏈 (引 無值之名)
                  (鏈 名 (引 ())))))))
    (求 &apos;(定 總表 空表))
    (求 &apos;(定 查
         (λ (表 名)
             (表 名))))
    (求 &apos;(定 擴展
         (λ (名1 值 表)
             (λ (名2)
                 (控 [(等? 名1 名2) 值]
                     [否則 (表 名2)])))))

    (求 &apos;(定 失敗))
    (求 &apos;(定 求
         (λ (e)
             (捕 終
                 (置! 失敗 終)
                 (控 [(定? e) (*定 e)]
                     [否則 (其意 e)])))))
    (求 &apos;(定 其意
         (λ (e)
             (意 e 查總表))))
    (求 &apos;(定 意
         (λ (e 表)
             ((式之作用 e) e 表))))
    (求 &apos;(定 查總表
         (λ (名)
             (查 總表 名))))

    (求 &apos;(定 式之作用
         (λ (e)
             (控 [(原子? e) (原子之作用 e)]
                 [否則 (鏈之作用 e)]))))
    (求 &apos;(定 原子之作用
         (λ (e)
             (控 [(數? e) *常元]
                 [(等? e #t) *常元]
                 [(等? e #f) *常元]
                 [(等? e (引 鏈)) *常元]
                 [(等? e (引 容)) *常元]
                 [(等? e (引 址)) *常元]
                 [(等? e (引 空?)) *常元]
                 [(等? e (引 等?)) *常元]
                 [(等? e (引 原子?)) *常元]
                 [(等? e (引 零?)) *常元]
                 [(等? e (引 增一)) *常元]
                 [(等? e (引 減一)) *常元]
                 [(等? e (引 數?)) *常元]
                 [否則 *變元]))))
    (求 &apos;(定 鏈之作用
         (λ (e)
             (控 [(空? e) *空]
                 [(原子? (容 e))
                  (控 [(等? (容 e) (引 引))
                       ,*引]
                      [(等? (容 e) (引 λ))
                       ,*λ]
                      [(等? (容 e) (引 捕))
                       ,*捕]
                      [(等? (容 e) (引 置!))
                       ,*置]
                      [(等? (容 e) (引 控))
                       ,*控]
                      [否則 *作用])]
                 [否則 *作用]))))

    (求 &apos;(定 定?
         (λ (e)
             (控 [(原子? e) #f]
                 [(原子? (容 e))
                  (等? (容 e) (引 定))]
                 [否則 #f]))))
    (求 &apos;(定 *定
         (λ (e)
             (置! 總表
                  (擴展 (名部 e)
                        (盒 (其意
                             (值部 e)))
                        總表)))))
    (求 &apos;(定 盒
         (λ (物)
             (λ (選擇子)
                 (選擇子 物
                         (λ (新物) (置! 物 新物)))))))
    ;; 下面是兩個選擇子
    (求 &apos;(定 重置盒
         (λ (盒 新物)
             (盒 (λ (之物 之置) (之置 新物))))))
    (求 &apos;(定 取於盒
         (λ (盒)
             (盒 (λ (之物 之置) 之物)))))

    (求 &apos;(定 *空
         (λ (e 表)
             (引 ()))))

    (求 &apos;(定 *引
         (λ (e 表)
             (文部 e))))

    (求 &apos;(定 *變元
         (λ (e 表)
             (取於盒 (查 表 e)))))
    (求 &apos;(定 *置
         (λ (e 表)
             (重置盒 (查 表 (名部 e))
                     (意 (值部 e) 表)))))

    (求 &apos;(定 *λ
         (λ (e 表)
             (λ (實參鏈)
                 (求於體 (體部 e)
                         (多擴展 (形參部 e)
                                 (多盒 實參鏈)
                                 表))))))

    (求 &apos;(定 求於體
         (λ (式鏈 表)
             (控 [(空? (址 式鏈))
                  (意 (容 式鏈) 表)]
                 [否則
                  ((λ (賦參)
                       (求於體 (址 式鏈) 表))
                   (意 (容 式鏈) 表))]))))
    (求 &apos;(定 多盒
         (λ (實參鏈)
             (控 [(空? 實參鏈) (引 ())]
                 [否則
                  (鏈 (盒 (容 實參鏈))
                      (多盒 (址 實參鏈)))]))))
    (求 &apos;(定 多擴展
         (λ (名鏈 值鏈 表)
             (控 [(空? 名鏈) 表]
                 [否則
                  (擴展 (容 名鏈)
                        (容 值鏈)
                        (多擴展 (址 名鏈)
                                (址 值鏈)
                                表))]))))

    (求 &apos;(定 *作用
         (λ (e 表)
             ((意 (函數部 e) 表)
              (求於鏈 (參數鏈部 e) 表)))))
    (求 &apos;(定 求於鏈
         (λ (式鏈 表)
             (控 [(空? 式鏈) (引 ())]
                 [否則
                  ((λ (賦參)
                       (鏈 賦參
                           (求於鏈 (址 式鏈) 表)))
                   (意 (容 式鏈) 表))]
                 ))))

    (求 &apos;(定 準備一元函數
         (λ (一元函數)
             (λ (實參鏈)
                 (一元函數 (容 實參鏈))))))
    (求 &apos;(定 準備二元函數
         (λ (二元函數)
             (λ (實參鏈)
                 (二元函數 (容 實參鏈)
                           (容 (址 實參鏈)))))))

    (求 &apos;(定 *常元
         ((λ (:鏈 :容 :址
                   :空? :等? :原子?
                   :零? :增一 :減一 :數?)
              (λ (e 表)
                  (控 [(數? e) e]
                      [(等? e #t) #t]
                      [(等? e #f) #f]
                      [(等? e (引 鏈)) :鏈]
                      [(等? e (引 容)) :容]
                      [(等? e (引 址)) :址]
                      [(等? e (引 空?)) :空?]
                      [(等? e (引 等?)) :等?]
                      [(等? e (引 原子?)) :原子?]
                      [(等? e (引 零?)) :零?]
                      [(等? e (引 增一)) :增一]
                      [(等? e (引 減一)) :減一]
                      [(等? e (引 數?)) :數?]
                      )))
          (準備二元函數 鏈)
          (準備一元函數 容)
          (準備一元函數 址)
          (準備一元函數 空?)
          (準備二元函數 等?)
          (準備一元函數 原子?)
          (準備一元函數 零?)
          (準備一元函數 增一)
          (準備一元函數 減一)
          (準備一元函數 數?)
          )))

    ;; 用λ實現鏈 很容易通過增加鏈中被選之物 來改變鏈的結構
    (求 &apos;(定 初鏈
         (λ (容)
             ((λ (賦址)
                  (λ (選擇子)
                      (選擇子 (λ (x) (置! 賦址 x))
                              容
                              賦址)))
              (引 ())))))
    (求 &apos;(定 鏈
         (λ (容 址)
             ((λ (賦鏈)
                  (置址 賦鏈 址)
                  賦鏈)
              (初鏈 容)))))
    (求 &apos;(定 置址
         (λ (鏈 新址)
             ((鏈 (λ (之置 之容 之址) 之置))
              新址))))
    (求 &apos;(定 容
         (λ (鏈)
             (鏈 (λ (之置 之容 之址) 之容)))))
    (求 &apos;(定 址
         (λ (鏈)
             (鏈 (λ (之置 之容 之址) 之址)))))

    (求 &apos;(定 *控
         (λ (e 表)
             (求於控 (問答鏈部 e) 表))))
    (求 &apos;(定 求於控
         (λ (問答鏈 表)
             (控 [(否則? (問部 (容 問答鏈)))
                  (意 (答部 (容 問答鏈)) 表)]
                 [(意 (問部 (容 問答鏈)) 表)
                  (意 (答部 (容 問答鏈)) 表)]
                 [否則 (求於控 (址 問答鏈) 表)]
                 ))))

    (求 &apos;(定 *捕
         (λ (e 表)
             (捕 捕之標
                 (求於體 (捕之體部 e)
                         (擴展 (名部 e)
                               (盒 (準備一元函數 捕之標))
                               表))))))

    (求 &apos;(定 文部
         (λ (x) (容 (址 x)))))
    (求 &apos;(定 形參部
         (λ (x) (容 (址 x)))))
    (求 &apos;(定 體部
         (λ (x) (址 (址 x)))))
    (求 &apos;(定 捕之體部
         (λ (x) (址 (址 x)))))
    (求 &apos;(定 名部
         (λ (x) (容 (址 x)))))
    (求 &apos;(定 值部
         (λ (x)
             (控 [(空? (址 (址 x))) 0]
                 [否則 (容 (址 (址 x)))]
                 ))))
    (求 &apos;(定 問答鏈部
         (λ (x) (址 x))))
    (求 &apos;(定 否則?
         (λ (x)
             (控 [(原子? x) (等? x (引 否則))]
                 [否則 #f]
                 ))))
    (求 &apos;(定 問部
         (λ (x) (容 x))))
    (求 &apos;(定 答部
         (λ (x) (容 (址 x)))))
    (求 &apos;(定 函數部
         (λ (x) (容 x))))
    (求 &apos;(定 參數鏈部
         (λ (x) (址 x))))
    #+end_src

*** &gt;&lt; 加載 一

    爲什麼需要把參數列表之後才能作中文解釋器中的求值?
    從錯誤信息看出一開始就在作用(car x)

    #+name: 在中文解釋器一中加載自身第一層
    #+begin_src scheme
    (define 中文解釋器一
      (lambda (x)
        ((求 &apos;求) (list x))))

    (中文解釋器一
     &apos;(定 空表
          (λ (名)
            (失敗
             (鏈 (引 無值之名)
                 (鏈 名 (引 ())))))))
    (中文解釋器一
     &apos;(定 總表 空表))
    (中文解釋器一
     &apos;(定 查
          (λ (表 名)
            (表 名))))
    (中文解釋器一
     &apos;(定 擴展
          (λ (名1 值 表)
            (λ (名2)
              (控 [(等? 名1 名2) 值]
                  [否則 (表 名2)])))))

    (中文解釋器一
     &apos;(定 失敗))
    (中文解釋器一
     &apos;(定 求
          (λ (e)
            (捕 終
                (置! 失敗 終)
                (控 [(定? e) (*定 e)]
                    [否則 (其意 e)])))))
    (中文解釋器一
     &apos;(定 其意
          (λ (e)
            (意 e 查總表))))
    (中文解釋器一
     &apos;(定 意
          (λ (e 表)
            ((式之作用 e) e 表))))
    (中文解釋器一
     &apos;(定 查總表
          (λ (名)
            (查 總表 名))))

    (中文解釋器一
     &apos;(定 式之作用
          (λ (e)
            (控 [(原子? e) (原子之作用 e)]
                [否則 (鏈之作用 e)]))))
    (中文解釋器一
     &apos;(定 原子之作用
          (λ (e)
            (控 [(數? e) *常元]
                [(等? e #t) *常元]
                [(等? e #f) *常元]
                [(等? e (引 鏈)) *常元]
                [(等? e (引 容)) *常元]
                [(等? e (引 址)) *常元]
                [(等? e (引 空?)) *常元]
                [(等? e (引 等?)) *常元]
                [(等? e (引 原子?)) *常元]
                [(等? e (引 零?)) *常元]
                [(等? e (引 增一)) *常元]
                [(等? e (引 減一)) *常元]
                [(等? e (引 數?)) *常元]
                [否則 *變元]))))
    (中文解釋器一
     &apos;(定 鏈之作用
          (λ (e)
            (控 [(空? e) *空]
                [(原子? (容 e))
                 (控 [(等? (容 e) (引 引))
                      ,*引]
                     [(等? (容 e) (引 λ))
                      ,*λ]
                     [(等? (容 e) (引 捕))
                      ,*捕]
                     [(等? (容 e) (引 置!))
                      ,*置]
                     [(等? (容 e) (引 控))
                      ,*控]
                     [否則 *作用])]
                [否則 *作用]))))

    (中文解釋器一
     &apos;(定 定?
          (λ (e)
            (控 [(原子? e) #f]
                [(原子? (容 e))
                 (等? (容 e) (引 定))]
                [否則 #f]))))
    (中文解釋器一
     &apos;(定 *定
          (λ (e)
            (置! 總表
                 (擴展 (名部 e)
                       (盒 (其意
                            (值部 e)))
                       總表)))))
    (中文解釋器一
     &apos;(定 盒
          (λ (物)
            (λ (選擇子)
              (選擇子 物
                      (λ (新物) (置! 物 新物)))))))
    ;; 下面是兩個選擇子
    (中文解釋器一
     &apos;(定 重置盒
          (λ (盒 新物)
            (盒 (λ (之物 之置) (之置 新物))))))
    (中文解釋器一
     &apos;(定 取於盒
          (λ (盒)
            (盒 (λ (之物 之置) 之物)))))

    (中文解釋器一
     &apos;(定 *空
          (λ (e 表)
            (引 ()))))

    (中文解釋器一
     &apos;(定 *引
          (λ (e 表)
            (文部 e))))

    (中文解釋器一
     &apos;(定 *變元
          (λ (e 表)
            (取於盒 (查 表 e)))))
    (中文解釋器一
     &apos;(定 *置
          (λ (e 表)
            (重置盒 (查 表 (名部 e))
                    (意 (值部 e) 表)))))

    (中文解釋器一
     &apos;(定 *λ
          (λ (e 表)
            (λ (實參鏈)
              (求於體 (體部 e)
                      (多擴展 (形參部 e)
                              (多盒 實參鏈)
                              表))))))

    (中文解釋器一
     &apos;(定 求於體
          (λ (式鏈 表)
            (控 [(空? (址 式鏈))
                 (意 (容 式鏈) 表)]
                [否則
                 ((λ (賦參)
                    (求於體 (址 式鏈) 表))
                  (意 (容 式鏈) 表))]))))
    (中文解釋器一
     &apos;(定 多盒
          (λ (實參鏈)
            (控 [(空? 實參鏈) (引 ())]
                [否則
                 (鏈 (盒 (容 實參鏈))
                     (多盒 (址 實參鏈)))]))))
    (中文解釋器一
     &apos;(定 多擴展
          (λ (名鏈 值鏈 表)
            (控 [(空? 名鏈) 表]
                [否則
                 (擴展 (容 名鏈)
                       (容 值鏈)
                       (多擴展 (址 名鏈)
                               (址 值鏈)
                               表))]))))

    (中文解釋器一
     &apos;(定 *作用
          (λ (e 表)
            ((意 (函數部 e) 表)
             (求於鏈 (參數鏈部 e) 表)))))
    (中文解釋器一
     &apos;(定 求於鏈
          (λ (式鏈 表)
            (控 [(空? 式鏈) (引 ())]
                [否則
                 ((λ (賦參)
                    (鏈 賦參
                        (求於鏈 (址 式鏈) 表)))
                  (意 (容 式鏈) 表))]
                ))))

    (中文解釋器一
     &apos;(定 準備一元函數
          (λ (一元函數)
            (λ (實參鏈)
              (一元函數 (容 實參鏈))))))
    (中文解釋器一
     &apos;(定 準備二元函數
          (λ (二元函數)
            (λ (實參鏈)
              (二元函數 (容 實參鏈)
                        (容 (址 實參鏈)))))))

    (中文解釋器一
     &apos;(定 *常元
          ((λ (:鏈 :容 :址
                    :空? :等? :原子?
                    :零? :增一 :減一 :數?)
             (λ (e 表)
               (控 [(數? e) e]
                   [(等? e #t) #t]
                   [(等? e #f) #f]
                   [(等? e (引 鏈)) :鏈]
                   [(等? e (引 容)) :容]
                   [(等? e (引 址)) :址]
                   [(等? e (引 空?)) :空?]
                   [(等? e (引 等?)) :等?]
                   [(等? e (引 原子?)) :原子?]
                   [(等? e (引 零?)) :零?]
                   [(等? e (引 增一)) :增一]
                   [(等? e (引 減一)) :減一]
                   [(等? e (引 數?)) :數?]
                   )))
           (準備二元函數 鏈)
           (準備一元函數 容)
           (準備一元函數 址)
           (準備一元函數 空?)
           (準備二元函數 等?)
           (準備一元函數 原子?)
           (準備一元函數 零?)
           (準備一元函數 增一)
           (準備一元函數 減一)
           (準備一元函數 數?)
           )))

    ;; 用λ實現鏈 很容易通過增加鏈中被選之物 來改變鏈的結構
    (中文解釋器一
     &apos;(定 初鏈
          (λ (容)
            ((λ (賦址)
               (λ (選擇子)
                 (選擇子 (λ (x) (置! 賦址 x))
                         容
                         賦址)))
             (引 ())))))
    (中文解釋器一
     &apos;(定 鏈
          (λ (容 址)
            ((λ (賦鏈)
               (置址 賦鏈 址)
               賦鏈)
             (初鏈 容)))))
    (中文解釋器一
     &apos;(定 置址
          (λ (鏈 新址)
            ((鏈 (λ (之置 之容 之址) 之置))
             新址))))
    (中文解釋器一
     &apos;(定 容
          (λ (鏈)
            (鏈 (λ (之置 之容 之址) 之容)))))
    (中文解釋器一
     &apos;(定 址
          (λ (鏈)
            (鏈 (λ (之置 之容 之址) 之址)))))

    (中文解釋器一
     &apos;(定 *控
          (λ (e 表)
            (求於控 (問答鏈部 e) 表))))
    (中文解釋器一
     &apos;(定 求於控
          (λ (問答鏈 表)
            (控 [(否則? (問部 (容 問答鏈)))
                 (意 (答部 (容 問答鏈)) 表)]
                [(意 (問部 (容 問答鏈)) 表)
                 (意 (答部 (容 問答鏈)) 表)]
                [否則 (求於控 (址 問答鏈) 表)]
                ))))

    (中文解釋器一
     &apos;(定 *捕
          (λ (e 表)
            (捕 捕之標
                (求於體 (捕之體部 e)
                        (擴展 (名部 e)
                              (盒 (準備一元函數 捕之標))
                              表))))))

    (中文解釋器一
     &apos;(定 文部
          (λ (x) (容 (址 x)))))
    (中文解釋器一
     &apos;(定 形參部
          (λ (x) (容 (址 x)))))
    (中文解釋器一
     &apos;(定 體部
          (λ (x) (址 (址 x)))))
    (中文解釋器一
     &apos;(定 捕之體部
          (λ (x) (址 (址 x)))))
    (中文解釋器一
     &apos;(定 名部
          (λ (x) (容 (址 x)))))
    (中文解釋器一
     &apos;(定 值部
          (λ (x)
            (控 [(空? (址 (址 x))) 0]
                [否則 (容 (址 (址 x)))]
                ))))
    (中文解釋器一
     &apos;(定 問答鏈部
          (λ (x) (址 x))))
    (中文解釋器一
     &apos;(定 否則?
          (λ (x)
            (控 [(原子? x) (等? x (引 否則))]
                [否則 #f]
                ))))
    (中文解釋器一
     &apos;(定 問部
          (λ (x) (容 x))))
    (中文解釋器一
     &apos;(定 答部
          (λ (x) (容 (址 x)))))
    (中文解釋器一
     &apos;(定 函數部
          (λ (x) (容 x))))
    (中文解釋器一
     &apos;(定 參數鏈部
          (λ (x) (址 x))))

    #+end_src

*** 加載 二

    爲什麼每增加一層都要給參數增加一次list

    #+name: 在中文解釋器一中加載自身第二層
    #+begin_src scheme
    (define 中文解釋器二
      (lambda (x)
        ((中文解釋器一 &apos;求) (list (list x)))))

    (中文解釋器二
     &apos;(定 空表
          (λ (名)
              (失敗
               (鏈 (引 無值之名)
                   (鏈 名 (引 ())))))))

    (中文解釋器二
     &apos;(定 空表
          (λ (名)
              (失敗
               (鏈 (引 無值之名)
                   (鏈 名 (引 ())))))))
    (中文解釋器二
     &apos;(定 總表 空表))
    (中文解釋器二
     &apos;(定 查
          (λ (表 名)
              (表 名))))
    (中文解釋器二
     &apos;(定 擴展
          (λ (名1 值 表)
              (λ (名2)
                  (控 [(等? 名1 名2) 值]
                      [否則 (表 名2)])))))

    (中文解釋器二
     &apos;(定 失敗))
    (中文解釋器二
     &apos;(定 求
          (λ (e)
              (捕 終
                  (置! 失敗 終)
                  (控 [(定? e) (*定 e)]
                      [否則 (其意 e)])))))
    (中文解釋器二
     &apos;(定 其意
          (λ (e)
              (意 e 查總表))))
    (中文解釋器二
     &apos;(定 意
          (λ (e 表)
              ((式之作用 e) e 表))))
    (中文解釋器二
     &apos;(定 查總表
          (λ (名)
              (查 總表 名))))

    (中文解釋器二
     &apos;(定 式之作用
          (λ (e)
              (控 [(原子? e) (原子之作用 e)]
                  [否則 (鏈之作用 e)]))))
    (中文解釋器二
     &apos;(定 原子之作用
          (λ (e)
              (控 [(數? e) *常元]
                  [(等? e #t) *常元]
                  [(等? e #f) *常元]
                  [(等? e (引 鏈)) *常元]
                  [(等? e (引 容)) *常元]
                  [(等? e (引 址)) *常元]
                  [(等? e (引 空?)) *常元]
                  [(等? e (引 等?)) *常元]
                  [(等? e (引 原子?)) *常元]
                  [(等? e (引 零?)) *常元]
                  [(等? e (引 增一)) *常元]
                  [(等? e (引 減一)) *常元]
                  [(等? e (引 數?)) *常元]
                  [否則 *變元]))))
    (中文解釋器二
     &apos;(定 鏈之作用
          (λ (e)
              (控 [(空? e) *空]
                  [(原子? (容 e))
                   (控 [(等? (容 e) (引 引))
                        ,*引]
                       [(等? (容 e) (引 λ))
                        ,*λ]
                       [(等? (容 e) (引 捕))
                        ,*捕]
                       [(等? (容 e) (引 置!))
                        ,*置]
                       [(等? (容 e) (引 控))
                        ,*控]
                       [否則 *作用])]
                  [否則 *作用]))))

    (中文解釋器二
     &apos;(定 定?
          (λ (e)
              (控 [(原子? e) #f]
                  [(原子? (容 e))
                   (等? (容 e) (引 定))]
                  [否則 #f]))))
    (中文解釋器二
     &apos;(定 *定
          (λ (e)
              (置! 總表
                   (擴展 (名部 e)
                         (盒 (其意
                              (值部 e)))
                         總表)))))
    (中文解釋器二
     &apos;(定 盒
          (λ (物)
              (λ (選擇子)
                  (選擇子 物
                          (λ (新物) (置! 物 新物)))))))
    ;; 下面是兩個選擇子
    (中文解釋器二
     &apos;(定 重置盒
          (λ (盒 新物)
              (盒 (λ (之物 之置) (之置 新物))))))
    (中文解釋器二
     &apos;(定 取於盒
          (λ (盒)
              (盒 (λ (之物 之置) 之物)))))

    (中文解釋器二
     &apos;(定 *空
          (λ (e 表)
              (引 ()))))

    (中文解釋器二
     &apos;(定 *引
          (λ (e 表)
              (文部 e))))

    (中文解釋器二
     &apos;(定 *變元
          (λ (e 表)
              (取於盒 (查 表 e)))))
    (中文解釋器二
     &apos;(定 *置
          (λ (e 表)
              (重置盒 (查 表 (名部 e))
                      (意 (值部 e) 表)))))

    (中文解釋器二
     &apos;(定 *λ
          (λ (e 表)
              (λ (實參鏈)
                  (求於體 (體部 e)
                          (多擴展 (形參部 e)
                                  (多盒 實參鏈)
                                  表))))))

    (中文解釋器二
     &apos;(定 求於體
          (λ (式鏈 表)
              (控 [(空? (址 式鏈))
                   (意 (容 式鏈) 表)]
                  [否則
                   ((λ (賦參)
                        (求於體 (址 式鏈) 表))
                    (意 (容 式鏈) 表))]))))
    (中文解釋器二
     &apos;(定 多盒
          (λ (實參鏈)
              (控 [(空? 實參鏈) (引 ())]
                  [否則
                   (鏈 (盒 (容 實參鏈))
                       (多盒 (址 實參鏈)))]))))
    (中文解釋器二
     &apos;(定 多擴展
          (λ (名鏈 值鏈 表)
              (控 [(空? 名鏈) 表]
                  [否則
                   (擴展 (容 名鏈)
                         (容 值鏈)
                         (多擴展 (址 名鏈)
                                 (址 值鏈)
                                 表))]))))

    (中文解釋器二
     &apos;(定 *作用
          (λ (e 表)
              ((意 (函數部 e) 表)
               (求於鏈 (參數鏈部 e) 表)))))
    (中文解釋器二
     &apos;(定 求於鏈
          (λ (式鏈 表)
              (控 [(空? 式鏈) (引 ())]
                  [否則
                   ((λ (賦參)
                        (鏈 賦參
                            (求於鏈 (址 式鏈) 表)))
                    (意 (容 式鏈) 表))]
                  ))))

    (中文解釋器二
     &apos;(定 準備一元函數
          (λ (一元函數)
              (λ (實參鏈)
                  (一元函數 (容 實參鏈))))))
    (中文解釋器二
     &apos;(定 準備二元函數
          (λ (二元函數)
              (λ (實參鏈)
                  (二元函數 (容 實參鏈)
                            (容 (址 實參鏈)))))))

    (中文解釋器二
     &apos;(定 *常元
          ((λ (:鏈 :容 :址
                    :空? :等? :原子?
                    :零? :增一 :減一 :數?)
               (λ (e 表)
                   (控 [(數? e) e]
                       [(等? e #t) #t]
                       [(等? e #f) #f]
                       [(等? e (引 鏈)) :鏈]
                       [(等? e (引 容)) :容]
                       [(等? e (引 址)) :址]
                       [(等? e (引 空?)) :空?]
                       [(等? e (引 等?)) :等?]
                       [(等? e (引 原子?)) :原子?]
                       [(等? e (引 零?)) :零?]
                       [(等? e (引 增一)) :增一]
                       [(等? e (引 減一)) :減一]
                       [(等? e (引 數?)) :數?]
                       )))
           (準備二元函數 鏈)
           (準備一元函數 容)
           (準備一元函數 址)
           (準備一元函數 空?)
           (準備二元函數 等?)
           (準備一元函數 原子?)
           (準備一元函數 零?)
           (準備一元函數 增一)
           (準備一元函數 減一)
           (準備一元函數 數?)
           )))

    ;; 用λ實現鏈 很容易通過增加鏈中被選之物 來改變鏈的結構
    (中文解釋器二
     &apos;(定 初鏈
          (λ (容)
              ((λ (賦址)
                   (λ (選擇子)
                       (選擇子 (λ (x) (置! 賦址 x))
                               容
                               賦址)))
               (引 ())))))
    (中文解釋器二
     &apos;(定 鏈
          (λ (容 址)
              ((λ (賦鏈)
                   (置址 賦鏈 址)
                   賦鏈)
               (初鏈 容)))))
    (中文解釋器二
     &apos;(定 置址
          (λ (鏈 新址)
              ((鏈 (λ (之置 之容 之址) 之置))
               新址))))
    (中文解釋器二
     &apos;(定 容
          (λ (鏈)
              (鏈 (λ (之置 之容 之址) 之容)))))
    (中文解釋器二
     &apos;(定 址
          (λ (鏈)
              (鏈 (λ (之置 之容 之址) 之址)))))

    (中文解釋器二
     &apos;(定 *控
          (λ (e 表)
              (求於控 (問答鏈部 e) 表))))
    (中文解釋器二
     &apos;(定 求於控
          (λ (問答鏈 表)
              (控 [(否則? (問部 (容 問答鏈)))
                   (意 (答部 (容 問答鏈)) 表)]
                  [(意 (問部 (容 問答鏈)) 表)
                   (意 (答部 (容 問答鏈)) 表)]
                  [否則 (求於控 (址 問答鏈) 表)]
                  ))))

    (中文解釋器二
     &apos;(定 *捕
          (λ (e 表)
              (捕 捕之標
                  (求於體 (捕之體部 e)
                          (擴展 (名部 e)
                                (盒 (準備一元函數 捕之標))
                                表))))))

    (中文解釋器二
     &apos;(定 文部
          (λ (x) (容 (址 x)))))
    (中文解釋器二
     &apos;(定 形參部
          (λ (x) (容 (址 x)))))
    (中文解釋器二
     &apos;(定 體部
          (λ (x) (址 (址 x)))))
    (中文解釋器二
     &apos;(定 捕之體部
          (λ (x) (址 (址 x)))))
    (中文解釋器二
     &apos;(定 名部
          (λ (x) (容 (址 x)))))
    (中文解釋器二
     &apos;(定 值部
          (λ (x)
              (控 [(空? (址 (址 x))) 0]
                  [否則 (容 (址 (址 x)))]
                  ))))
    (中文解釋器二
     &apos;(定 問答鏈部
          (λ (x) (址 x))))
    (中文解釋器二
     &apos;(定 否則?
          (λ (x)
              (控 [(原子? x) (等? x (引 否則))]
                  [否則 #f]
                  ))))
    (中文解釋器二
     &apos;(定 問部
          (λ (x) (容 x))))
    (中文解釋器二
     &apos;(定 答部
          (λ (x) (容 (址 x)))))
    (中文解釋器二
     &apos;(定 函數部
          (λ (x) (容 x))))
    (中文解釋器二
     &apos;(定 參數鏈部
          (λ (x) (址 x))))
    #+end_src

*** 加載 三

    ikarus的速度很快
    但是&quot;三&quot;在我的機器上此時已經需要十秒的時間了

    #+name: 在中文解釋器一中加載自身第三層
    #+begin_src scheme
    (define 中文解釋器三
      (lambda (x)
        ((中文解釋器二 &apos;求) (list (list (list x))))))
    (中文解釋器三
     &apos;(定 空表
          (λ (名)
              (失敗
               (鏈 (引 無值之名)
                   (鏈 名 (引 ())))))))

    (中文解釋器三
     &apos;(定 空表
          (λ (名)
              (失敗
               (鏈 (引 無值之名)
                   (鏈 名 (引 ())))))))
    (中文解釋器三
     &apos;(定 總表 空表))
    (中文解釋器三
     &apos;(定 查
          (λ (表 名)
              (表 名))))
    (中文解釋器三
     &apos;(定 擴展
          (λ (名1 值 表)
              (λ (名2)
                  (控 [(等? 名1 名2) 值]
                      [否則 (表 名2)])))))

    (中文解釋器三
     &apos;(定 失敗))
    (中文解釋器三
     &apos;(定 求
          (λ (e)
              (捕 終
                  (置! 失敗 終)
                  (控 [(定? e) (*定 e)]
                      [否則 (其意 e)])))))
    (中文解釋器三
     &apos;(定 其意
          (λ (e)
              (意 e 查總表))))
    (中文解釋器三
     &apos;(定 意
          (λ (e 表)
              ((式之作用 e) e 表))))
    (中文解釋器三
     &apos;(定 查總表
          (λ (名)
              (查 總表 名))))

    (中文解釋器三
     &apos;(定 式之作用
          (λ (e)
              (控 [(原子? e) (原子之作用 e)]
                  [否則 (鏈之作用 e)]))))
    (中文解釋器三
     &apos;(定 原子之作用
          (λ (e)
              (控 [(數? e) *常元]
                  [(等? e #t) *常元]
                  [(等? e #f) *常元]
                  [(等? e (引 鏈)) *常元]
                  [(等? e (引 容)) *常元]
                  [(等? e (引 址)) *常元]
                  [(等? e (引 空?)) *常元]
                  [(等? e (引 等?)) *常元]
                  [(等? e (引 原子?)) *常元]
                  [(等? e (引 零?)) *常元]
                  [(等? e (引 增一)) *常元]
                  [(等? e (引 減一)) *常元]
                  [(等? e (引 數?)) *常元]
                  [否則 *變元]))))
    (中文解釋器三
     &apos;(定 鏈之作用
          (λ (e)
              (控 [(空? e) *空]
                  [(原子? (容 e))
                   (控 [(等? (容 e) (引 引))
                        ,*引]
                       [(等? (容 e) (引 λ))
                        ,*λ]
                       [(等? (容 e) (引 捕))
                        ,*捕]
                       [(等? (容 e) (引 置!))
                        ,*置]
                       [(等? (容 e) (引 控))
                        ,*控]
                       [否則 *作用])]
                  [否則 *作用]))))

    (中文解釋器三
     &apos;(定 定?
          (λ (e)
              (控 [(原子? e) #f]
                  [(原子? (容 e))
                   (等? (容 e) (引 定))]
                  [否則 #f]))))
    (中文解釋器三
     &apos;(定 *定
          (λ (e)
              (置! 總表
                   (擴展 (名部 e)
                         (盒 (其意
                              (值部 e)))
                         總表)))))
    (中文解釋器三
     &apos;(定 盒
          (λ (物)
              (λ (選擇子)
                  (選擇子 物
                          (λ (新物) (置! 物 新物)))))))
    ;; 下面是兩個選擇子
    (中文解釋器三
     &apos;(定 重置盒
          (λ (盒 新物)
              (盒 (λ (之物 之置) (之置 新物))))))
    (中文解釋器三
     &apos;(定 取於盒
          (λ (盒)
              (盒 (λ (之物 之置) 之物)))))

    (中文解釋器三
     &apos;(定 *空
          (λ (e 表)
              (引 ()))))

    (中文解釋器三
     &apos;(定 *引
          (λ (e 表)
              (文部 e))))

    (中文解釋器三
     &apos;(定 *變元
          (λ (e 表)
              (取於盒 (查 表 e)))))
    (中文解釋器三
     &apos;(定 *置
          (λ (e 表)
              (重置盒 (查 表 (名部 e))
                      (意 (值部 e) 表)))))

    (中文解釋器三
     &apos;(定 *λ
          (λ (e 表)
              (λ (實參鏈)
                  (求於體 (體部 e)
                          (多擴展 (形參部 e)
                                  (多盒 實參鏈)
                                  表))))))

    (中文解釋器三
     &apos;(定 求於體
          (λ (式鏈 表)
              (控 [(空? (址 式鏈))
                   (意 (容 式鏈) 表)]
                  [否則
                   ((λ (賦參)
                        (求於體 (址 式鏈) 表))
                    (意 (容 式鏈) 表))]))))
    (中文解釋器三
     &apos;(定 多盒
          (λ (實參鏈)
              (控 [(空? 實參鏈) (引 ())]
                  [否則
                   (鏈 (盒 (容 實參鏈))
                       (多盒 (址 實參鏈)))]))))
    (中文解釋器三
     &apos;(定 多擴展
          (λ (名鏈 值鏈 表)
              (控 [(空? 名鏈) 表]
                  [否則
                   (擴展 (容 名鏈)
                         (容 值鏈)
                         (多擴展 (址 名鏈)
                                 (址 值鏈)
                                 表))]))))

    (中文解釋器三
     &apos;(定 *作用
          (λ (e 表)
              ((意 (函數部 e) 表)
               (求於鏈 (參數鏈部 e) 表)))))
    (中文解釋器三
     &apos;(定 求於鏈
          (λ (式鏈 表)
              (控 [(空? 式鏈) (引 ())]
                  [否則
                   ((λ (賦參)
                        (鏈 賦參
                            (求於鏈 (址 式鏈) 表)))
                    (意 (容 式鏈) 表))]
                  ))))

    (中文解釋器三
     &apos;(定 準備一元函數
          (λ (一元函數)
              (λ (實參鏈)
                  (一元函數 (容 實參鏈))))))
    (中文解釋器三
     &apos;(定 準備二元函數
          (λ (二元函數)
              (λ (實參鏈)
                  (二元函數 (容 實參鏈)
                            (容 (址 實參鏈)))))))

    (中文解釋器三
     &apos;(定 *常元
          ((λ (:鏈 :容 :址
                    :空? :等? :原子?
                    :零? :增一 :減一 :數?)
               (λ (e 表)
                   (控 [(數? e) e]
                       [(等? e #t) #t]
                       [(等? e #f) #f]
                       [(等? e (引 鏈)) :鏈]
                       [(等? e (引 容)) :容]
                       [(等? e (引 址)) :址]
                       [(等? e (引 空?)) :空?]
                       [(等? e (引 等?)) :等?]
                       [(等? e (引 原子?)) :原子?]
                       [(等? e (引 零?)) :零?]
                       [(等? e (引 增一)) :增一]
                       [(等? e (引 減一)) :減一]
                       [(等? e (引 數?)) :數?]
                       )))
           (準備二元函數 鏈)
           (準備一元函數 容)
           (準備一元函數 址)
           (準備一元函數 空?)
           (準備二元函數 等?)
           (準備一元函數 原子?)
           (準備一元函數 零?)
           (準備一元函數 增一)
           (準備一元函數 減一)
           (準備一元函數 數?)
           )))

    ;; 用λ實現鏈 很容易通過增加鏈中被選之物 來改變鏈的結構
    (中文解釋器三
     &apos;(定 初鏈
          (λ (容)
              ((λ (賦址)
                   (λ (選擇子)
                       (選擇子 (λ (x) (置! 賦址 x))
                               容
                               賦址)))
               (引 ())))))
    (中文解釋器三
     &apos;(定 鏈
          (λ (容 址)
              ((λ (賦鏈)
                   (置址 賦鏈 址)
                   賦鏈)
               (初鏈 容)))))
    (中文解釋器三
     &apos;(定 置址
          (λ (鏈 新址)
              ((鏈 (λ (之置 之容 之址) 之置))
               新址))))
    (中文解釋器三
     &apos;(定 容
          (λ (鏈)
              (鏈 (λ (之置 之容 之址) 之容)))))
    (中文解釋器三
     &apos;(定 址
          (λ (鏈)
              (鏈 (λ (之置 之容 之址) 之址)))))

    (中文解釋器三
     &apos;(定 *控
          (λ (e 表)
              (求於控 (問答鏈部 e) 表))))
    (中文解釋器三
     &apos;(定 求於控
          (λ (問答鏈 表)
              (控 [(否則? (問部 (容 問答鏈)))
                   (意 (答部 (容 問答鏈)) 表)]
                  [(意 (問部 (容 問答鏈)) 表)
                   (意 (答部 (容 問答鏈)) 表)]
                  [否則 (求於控 (址 問答鏈) 表)]
                  ))))

    (中文解釋器三
     &apos;(定 *捕
          (λ (e 表)
              (捕 捕之標
                  (求於體 (捕之體部 e)
                          (擴展 (名部 e)
                                (盒 (準備一元函數 捕之標))
                                表))))))

    (中文解釋器三
     &apos;(定 文部
          (λ (x) (容 (址 x)))))
    (中文解釋器三
     &apos;(定 形參部
          (λ (x) (容 (址 x)))))
    (中文解釋器三
     &apos;(定 體部
          (λ (x) (址 (址 x)))))
    (中文解釋器三
     &apos;(定 捕之體部
          (λ (x) (址 (址 x)))))
    (中文解釋器三
     &apos;(定 名部
          (λ (x) (容 (址 x)))))
    (中文解釋器三
     &apos;(定 值部
          (λ (x)
              (控 [(空? (址 (址 x))) 0]
                  [否則 (容 (址 (址 x)))]
                  ))))
    (中文解釋器三
     &apos;(定 問答鏈部
          (λ (x) (址 x))))
    (中文解釋器三
     &apos;(定 否則?
          (λ (x)
              (控 [(原子? x) (等? x (引 否則))]
                  [否則 #f]
                  ))))
    (中文解釋器三
     &apos;(定 問部
          (λ (x) (容 x))))
    (中文解釋器三
     &apos;(定 答部
          (λ (x) (容 (址 x)))))
    (中文解釋器三
     &apos;(定 函數部
          (λ (x) (容 x))))
    (中文解釋器三
     &apos;(定 參數鏈部
          (λ (x) (址 x))))
    #+end_src
</pre>
</body>
</html>
