<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>lang/scheme/little-lambda.scm</title>
</head>
<body>
<pre>(define atom?
  (lambda (x)
    (and (not (pair? x))
         (not (null? x)))))

(define add1
  (lambda (x)
    (+ 1 x)))

(define sub1
  (lambda (x)
    (- x 1)))

(define first car)

(define second (lambda (x) (car (cdr x))))

(define build
  (lambda (s1 s2)
    (cons s1 (cons s2 (quote ())))))


(define new-entry build)

(define lookup-in-entry
  (lambda (name entry entry-f)
    (lookup-in-entry-help
     name
     (first entry)
     (second entry)
     entry-f)))

(define lookup-in-entry-help
  (lambda (name names values entry-f)
    (cond [(null? names) (entry-f name)]
          [(eq? (car names) name)
           (car values)]
          [else (lookup-in-entry-help
                 name
                 (cdr names)
                 (cdr values)
                 entry-f)])))

(define extend-table cons)

(define lookup-in-table
  (lambda (name table table-f)
    (cond [(null? table)
           (table-f name)]
          [else
           (lookup-in-entry
            name
            (car table)
            (lambda (name)
              (lookup-in-table name (cdr table) table-f)))])))

(define value
  (lambda (e)
    (meaning e (quote ()))))

(define meaning
  (lambda (e table)
    ((expression-to-action e) e table)))

(define expression-to-action
  (lambda (e)
    (cond
     [(atom? e)
      (atom-to-action e)]
     [else
      (list-to-action e)])))

(define atom-to-action
  (lambda (e)
    (cond
     [(number? e)             *const]
     [(eq? e #t)              *const]
     [(eq? e #f)              *const]
     [(eq? e (quote cons))    *const]
     [(eq? e (quote car))     *const]
     [(eq? e (quote cdr))     *const]
     [(eq? e (quote null?))   *const]
     [(eq? e (quote eq?))     *const]
     [(eq? e (quote atom?))   *const]
     [(eq? e (quote zero?))   *const]
     [(eq? e (quote add1))    *const]
     [(eq? e (quote sub1))    *const]
     [(eq? e (quote number?)) *const]
     [else                    *identifer])))

(define list-to-action
  (lambda (e)
    (cond [(null? e) *null]
          [(atom? (car e))
           (cond [(eq? (car e) (quote quote))  *quote]
                 [(eq? (car e) (quote lambda)) *lambda]
                 [(eq? (car e) (quote cond))   *cond]
                 [else                         *application])]
          [else *application])))

;; *const

(define *const
  (lambda (e table)
    (cond [(number? e) e]
          [(eq? e #t) #t]
          [(eq? e #f) #f]
          [else (build (quote primitive) e)])))


;; *identifer

(define *identifer
  (lambda (e table)
    (lookup-in-table e table notfound)))

(define notfound
  (lambda (name)
    &quot;error: at least one name is unbound&quot;))


;; *null

(define *null
  (lambda (e table)
    (quote ())))


;; *quote

(define text-of second)

(define *quote
  (lambda (e table)
    (text-of e)))


;; *lambda

(define *lambda
  (lambda (e table)
    (list (quote non-primitive)
          (cons table (cdr e)))))

(define table-of
  (lambda (non-primitive)
    (car non-primitive)))

(define formals-of
  (lambda (non-primitive)
    (cadr non-primitive)))

(define body-of
  (lambda (non-primitive)
    (caddr non-primitive)))


;; *cond

(define *cond
  (lambda (e table)
    (evcon (cond-lines-of e) table)))

(define cond-lines-of cdr)

(define evcon
  (lambda (lines table)
    (cond [(else? (question-of (car lines)))
           (meaning (answer-of (car lines)) table)]
          [(meaning (question-of (car lines)) table)
           (meaning (answer-of (car lines)) table)]
          [else
           (evcon (cdr lines) table)])))

(define question-of
  (lambda (x)
    (car x)))

(define answer-of
  (lambda (x)
    (cadr x)))

(define else?
  (lambda (x)
    (cond ((atom? x)
           (eq? x (quote else)))
          (else
           #f))))


;; *application

(define *application
  (lambda (e table)
    (myapply
     (meaning (function-of e) table)
     (evlis (arguments-of e) table))))

(define evlis
  (lambda (args table)
    (cond [(null? args) (quote ())]
          [else (cons (meaning (car args) table)
                      (evlis (cdr args) table))])))

(define function-of car)

(define arguments-of cdr)

(define myapply
  (lambda (fun vals)
    (cond ((primitive? fun)
           (apply-primitive (second fun) vals))
          ((non-primitive? fun)
           (apply-closure (second fun) vals)))))

(define primitive?
  (lambda (l)
    (eq? (car l) (quote primitive))))

(define non-primitive?
  (lambda (l)
    (eq? (car l) (quote non-primitive))))

(define apply-primitive
  (lambda (name vals)
    (cond
     ((eq? name &apos;cons)
      (cons (first vals) (second vals)))
     ((eq? name &apos;car)
      (car (first vals)))
     ((eq? name &apos;cdr)
      (cdr (first vals)))
     ((eq? name &apos;null?)
      (null? (first vals)))
     ((eq? name &apos;eq?)
      (eq? (first vals) (second vals)))
     ((eq? name &apos;atom?)
      (:atom? (first vals)))
     ((eq? name &apos;zero?)
      (zero? (first vals)))
     ((eq? name &apos;add1)
      (add1 (first vals)))
     ((eq? name &apos;sub1)
      (sub1 (first vals)))
     ((eq? name &apos;number?)
      (number? (first vals))))))

(define :atom?
  (lambda (x)
    (cond ((atom? x)
           #t)
          ((null? x)
           #f)
          ((eq? (car x) &apos;primitive)
           #t)
          ((eq? (car x) &apos;non-primitive)
           #t)
          (else
           #f))))

(define apply-closure
  (lambda (closure vals)
    (meaning (body-of closure)
             (extend-table (new-entry (formals-of closure) vals)
                           (table-of closure)))))


;;;; test

;; 對*identifer的測試可以看作對報錯情況的測試
(value &apos;not-const)

;; *const
;; 數字與邏輯值
(value 1)
;; 下面兩個用到*application
(value &apos;(add1 1))
(value &apos;(sub1 1))
(value #t)
(value #f)

;; 基本函數primitive
(value &apos;add1)
(value &apos;car)
(value &apos;atom?)

;; *null
(value &apos;())

;; *quote
(value &apos;(quote a-quoted-string))
(value &apos;(quote (a-quoted-string)))
(value &apos;(quote (lambda (x) (add1 (add1 x)))))

;; *lambda 非基本函數non-primitive
(value &apos;(lambda (x) (add1 (add1 x))))

;; *cond
;; 用到*application
(value &apos;(cond ((eq? 1 2) 123) (else 321)))
(value &apos;(cond ((eq? 1 &apos;kkk) 123) (else 321)))
(value &apos;(cond ((eq? cons car) 123) (else 321)))

;; *application
(value &apos;(cons 1 &apos;()))
(value &apos;((lambda (x) (cons &apos;drink (cons x &apos;())))
         &apos;milk))
(value &apos;((lambda (y) (cond
                      ((eq? y &apos;thirst)
                       ((lambda (x) (cons &apos;drink (cons x &apos;())))
                        &apos;water))
                      ((eq? y &apos;not-thirst)
                       ((lambda (x) (cons &apos;do (cons &apos;not (cons &apos;drink (cons x &apos;())))))
                        &apos;water))
                      (else
                       &apos;what-ever)))
         &apos;thirst))
(value &apos;((lambda (y) (cond
                      ((eq? y &apos;thirst)
                       ((lambda (x) (cons &apos;drink (cons x &apos;())))
                        &apos;water))
                      ((eq? y &apos;not-thirst)
                       ((lambda (x) (cons &apos;do (cons &apos;not (cons &apos;drink (cons x &apos;())))))
                        &apos;water))
                      (else
                       &apos;what-ever)))
         &apos;not-thirst))
;; 這裏用到的是有else保護的cond
(value &apos;((lambda (y) (cond
                      ((eq? y &apos;thirst)
                       ((lambda (x) (cons &apos;drink (cons x &apos;())))
                        &apos;water))
                      ((eq? y &apos;not-thirst)
                       ((lambda (x) (cons &apos;do (cons &apos;not (cons &apos;drink (cons x &apos;())))))
                        &apos;water))
                      (else
                       &apos;what-ever)))
         &apos;do-not-tell-you))

;; 而如果不用else就會報錯
;; 報出的是元解釋器中的(car &apos;())錯誤
;; (value &apos;((lambda (y) (cond
;;                     ((eq? y &apos;thirst)
;;                      ((lambda (x) (cons &apos;drink (cons x &apos;())))
;;                       &apos;water))
;;                     ((eq? y &apos;not-thirst)
;;                      ((lambda (x) (cons &apos;do (cons &apos;not (cons &apos;drink (cons x &apos;())))))
;;                       &apos;water))))
;;        &apos;do-not-tell-you))

;; 測試結果
;; &quot;error: at least one name is unbound&quot;
;; &gt; 1
;; &gt; 2
;; &gt; 0
;; &gt; #t
;; &gt; #f
;; &gt; (primitive add1)
;; &gt; (primitive car)
;; &gt; (primitive atom?)
;; &gt; ()
;; &gt; a-quoted-string
;; &gt; (a-quoted-string)
;; &gt; (lambda (x) (add1 (add1 x)))
;; &gt; (non-primitive (() (x) (add1 (add1 x))))
;; &gt; 321
;; &gt; 321
;; &gt; 321
;; &gt; (1)
;; &gt; (drink milk)
;; &gt; (drink water)
;; &gt; (do not drink water)
;; &gt; what-ever
</pre>
</body>
</html>
