<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>lang/cicada/cicada-type-system.cl</title>
</head>
<body>
<pre>#+TITLE:  cicada type system
#+AUTHOR: 謝宇恆 / XIE Yuheng

* ===================================

* program as proof

** note type as proposition

   * a function returns a type
     can be viewed as [a family of] proposition

** pattern match

   * maybe (type -&gt; type)
     nothing ({type #type} -&gt; :type maybe)
     just ({type #type} :type -&gt; :type maybe)

   * maybe-apply
     ({type #type #type&apos;}
      :type&apos; (:type -&gt; :type&apos;) :type maybe -&gt; :type&apos;)
     * :default :function nothing
     | :default
     * :default :function :value just
     | :value :function apply

** map

   * 在則式中
     當出現
     (...
      (:type -&gt; :type&apos;) #function
      ...) 時
     :function (-&gt; (:type -&gt; :type&apos;))

   * map
     ({type #type #type&apos;}
      (:type -&gt; :type&apos;) #function
       :type list -&gt; :type&apos; list)
     * :function null
     | null
     * :function :car :cdr cons
     | :car :function apply
       :function :cdr map cons

   * list-length? ({type #type} :type list natural -&gt; type)
     list-length?null
     (----------&gt;
      null 0 list-length?)
     list-length?cons
     ({natural #length
       :type #car
       :type list #cdr}
      :cdr :length list-length?
      -------------------------&gt;
      :car :cdr cons :length add1 list-length?)

   * list-length?map
     ({type #type #type&apos;
       (:type -&gt; :type&apos;) #function
       :type list #list natural #length}
      :list :length list-length?
      --------------------------&gt;
      :list :function map :length list-length?)
     * list-length?null
     | list-length?null
     * :inductive-hypothesis list-length?cons
     | :inductive-hypothesis list-length?map list-length?cons

   &lt;&lt; explicit argument &gt;&gt;

   * list-length? ({type #type} :type list natural -&gt; type)
     list-length?null
     (-------------&gt;
      null 0 list-length?)
     list-length?cons
     (natural #length
      :type #car
      :type list #cdr
      :cdr :length list-length?
      -------------------------&gt;
      :car :cdr cons :length add1 list-length?)

   * list-length?map
     ({type #type #type&apos;}
      (:type -&gt; :type&apos;) #function
      :type list #list natural #length
      :list :length list-length?
      --------------------------&gt;
      :list map :function apply :length list-length?)
     * :function null 0
       list-length?null
     | list-length?null
     * :function :car :cdr cons :length add1
       :length
       :car
       :cdr
       :inductive-hypothesis
       list-length?cons
     | :length
       :car :function apply
       :cdr :function map
       :function :cdr :length :inductive-hypothesis list-length?map
       list-length?cons

** red-black-tree

   * red-black-tree
     import
       preliminaries
     assume
       key (-&gt; type)
       compare (key key -&gt; order)
       value (-&gt; type)

   * color (-&gt; type)
     red (-&gt; color)
     black (-&gt; color)

   * tree (-&gt; type)
     empty (-&gt; tree)
     node (tree tree color key value -&gt; tree)

   * balance
     (tree -&gt; tree)
     * :a
       :b red ::x node
                    :c red ::y node
                                 :d black ::z node
     | :a
       :b black ::x node
       :c
       :d black ::z node red ::y node
     *              :a
       :b
       :c red ::y node red ::x node
                                 :d black ::z node
     | :a
       :b black ::x node
       :c
       :d black ::z node red ::y node
     *                           :a
       :b
       :c red ::y node
                    :d red ::z node black ::x node
     | :a
       :b black ::x node
       :c
       :d black ::z node red ::y node
     *                           :a
                    :b
       :c
       :d red ::z node red ::y node black ::x node
     | :a
       :b black ::x node
       :c
       :d black ::z node red ::y node
     * :already-balanced-tree
     | :already-balanced-tree

   * insert,help
     (tree key value -&gt; tree)
     * empty :key :value
     | empty empty
       red :key :value node
     * :left :right
       :color :key :value node
       :key&apos; :value&apos;
     | :key :key&apos; compare
       * equal
       | :left
         :right
         :color :key&apos; :value&apos; node
       * less
       | :left :key&apos; :value&apos; insert,help
         :right
         :color :key :value node balance
       * greater
       | :left
         :right :key&apos; :value&apos; insert,help
         :color :key :value node balance

   * blacken-root
     (tree -&gt; tree)
     * empty
     | empty
     * :left :right :color ::key-value node
     | :left :right black ::key-value node

   * insert
     (tree key value -&gt; tree)
     insert,help
     blacken-root

   * black-high? (tree natural -&gt; type)
     black-high?empty
     (---------------&gt;
      empty 1 black-high?)
     black-high?red
     ({natural #high tree #left #right key value ##key-value}
      :left :high black-high?
      :right :high black-high?
      -----------------------&gt;
      :right :high red ::key-value node :high black-high?)
     black-high?black
     ({natural #high tree #left #right key value ##key-value}
      :left :high black-high?
      :right :high black-high?
      -----------------------&gt;
      :right :high black ::key-value node :high add1 black-high?)

   * black-high?blacken-root
     ({tree #tree natural #high}
      :tree :high black-high?
      ----------------------&gt;
      natural #high&apos;
      :tree blacken-root :high&apos; black-high?)
     * black-high?empty
     | 1 black-high?empty
     * :black-high?left :black-high?right black-high?red
     | _ :black-high?left :black-high?right black-high?black
     * :black-high?left :black-high?right black-high?black
     | _ :black-high?left :black-high?right black-high?black

   * black-high?example
     assume
       k1 (-&gt; key)
       k2 (-&gt; key)
       v1 (-&gt; value)
       v2 (-&gt; value)
     * t (-&gt; tree)
       empty empty red k1 v1 node
                            empty black k2 v2 node

     * black-high?t
       (--------------&gt;
        t 2 black-high?)
       black-high?empty
       black-high?empty
       black-high?red
       black-high?empty
       black-high?black

   * black-high?balance,red
     ({tree #left #right key value ##key-value natural #high}
      :left :high black-high?
      :right :high black-high?
      -----------------------&gt;
      :left :right red ##key-value balance :high add1 black-high?)
     *?
     |?

   * black-high?balance,black
     ({tree #left #right key value ##key-value natural #high}
      :left :high black-high?
      :right :high black-high?
      -----------------------&gt;
      :left :right black ##key-value balance :high add1 black-high?)
     *?
     |?

   * black-high?insert,help
     ({tree #tree key value ##key-value natural #high}
      :tree :high black-high?
      ----------------------&gt;
      :tree ::key-value insert,help :high black-high?)
     * black-high?empty
     |
     *
     |

   * black-high?insert
     ({tree #tree key value ##key-value natural #high}
      :tree :high black-high?
      ----------------------&gt;
      natural #high&apos;
      :tree ::key-value insert :high&apos; black-high?)
     black-high?insert,help
     black-high?blacken-root

** note in &amp; exi

* generic function

** note typeclass &amp; functor

   * 類似 typeclass
     但是相反 描述某些抽象的特性 然後找滿足這些抽象的特性的例子
     此時我們 觀察已有的類型的共同點 然後把這些共同點提取出來

   * 一旦把相似性提取出來之後
     我們就能利用 用以編碼 相似性 的接口函數
     來寫適用於多個類型的函數了 [所謂 generic function]

   * 技巧是 把原本用 子集 描述的東西
     用 映射的值域 來描述
     而 映射的義域 用以勾勒出 值域 做爲子集的範圍
     定義類型 的 構造子 就是用以 用以勾勒出 值域 範圍 的 子集
     同時還要有一個配合這個 所定義的類型的 解釋函數
     * 就像是 指稱語義 一樣
       所以 有一種 DSL[domain specific language] 的感覺
     比如 對於 functor 解釋函數是 functor:apply
     比如 對於 format 解釋函數是 data

** format

** functor

   * functor (-&gt; type1)
     functor:list (functor -&gt; functor)
     functor:identity (-&gt; functor)
     functor:product (functor functor -&gt; functor)
     functor:constant (type -&gt; functor)

   * functor:apply (type functor -&gt; type)
     * :type :functor functor:list
     | :type :functor functor:apply list
     * :type functor:identity
     | :type
     * :type :functor1 :functor2 functor:product
     | :type :functor1 functor:apply
       :type :functor2 functor:apply product
     * :type :constant-type functor:constant
     | :constant-type

   * functor:map
     (functor #functor {type #type1 #type2}
      (:type1 -&gt; :type2) -&gt;
      (:type1 :functor functor:apply -&gt; :type2 :functor functor:apply))
     *
     |
     *
     |
     *
     |
     *
     |

* &gt;&lt; homotopy type theory

* &gt;&lt;&gt;&lt; type class

** equal &amp; order

   * equal-able &lt; type
     equal??
     ({equal-able #value} :value :value -&gt; (true | false))

   * not-equal??
     ({equal-able #value} :value :value -&gt; (true | false))
     equal?? not

   * natural (-&gt; equal-able)
     &gt;&lt;&gt;&lt;&gt;&lt;

   * order-able &lt; equal-able
     ({order-able #value} :value :value -&gt; (less-than | equal | greater-than))

   * sort
     ({order-able #value} :value list -&gt; :value list)
     &gt;&lt;&gt;&lt;&gt;&lt;

** functor

   * map-able &lt; (type -&gt; type) &lt;&lt; have-functor &gt;&gt;

   * function-map
     ({type #type #type&apos;} {map-able #functor}
      (:type -&gt; :type&apos;)
      :type :functor apply -&gt; :type&apos; :functor apply)

   * functor-map
     ({type #type #type&apos;} {map-able #functor}
      (:type -&gt; :type&apos;) -&gt;
      (:type :functor apply -&gt; :type&apos; :functor apply))

   * list (-&gt; map-able)

   * map
     ({(list -&gt; list) #functor}
       (list -&gt; list) list :functor apply -&gt; list :functor apply)
     * :function null
     | null
     * :function :car :cdr cons
     | :car :function apply
       :function :cdr map cons

** &gt;&lt;

   * map-able
     (type -&gt; type) &lt;&lt; have-functor &gt;&gt;

   * function-map
     ({type #type #type&apos;} {map-able #functor}
      (:type -&gt; :type&apos;)
      :type :functor apply -&gt; :type&apos; :functor apply)

   * functor-map
     ({type #type #type&apos;} {map-able #functor}
      (:type -&gt; :type&apos;) -&gt;
      (:type :functor apply -&gt; :type&apos; :functor apply))

   * list (-&gt; map-able)

   * map
     ({(list -&gt; list) #functor}
       (list -&gt; list) list :functor apply -&gt; list :functor apply)
     * :function null
     | null
     * :function :car :cdr cons
     | :car :function apply
       :function :cdr map cons

* ===================================
</pre>
</body>
</html>
