<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>lang/cicada/cicada-language/open/vm.org</title>
</head>
<body>
<pre>* 討論 &lt;2015-10-04&gt;
  - x ::
       所謂 新實現技術所帶來的衝擊
       剛好配合了 類型系統 對用戶接口方面的新性狀的要求
       用戶接口不能再是 簡單的字符串輸入與輸出
       信息必須以相對完整的方式提供給編譯器
       就像 agda 一樣
  - k ::
       新的 vm 的編譯器可以跳過
       用匯編代碼寫 non-primitive-function 的階段
       必須在 host 中寫的 non-primitive-function 可以減少到最少

* 語法擴展機制
  - x ::
       新來的類型系統
       可能要求我們並不能使用非常自由的語法擴展機制
  - k ::
       我們可以總結一下現在語法擴展機制的使用實例
       然後 在想一下 可能還有別的什麼用處
       之後再設計新的語法擴展機制
  - x ::
       首先是 if them else
       它可以被 模式匹配完全取代
       其次是 字符串 的 double-quote
       所有非後綴表達式函數作用的東西都要用語法擴展實現
       但是
       這將帶來一種負擔
       因爲 每擴展一個語法
       就 必須告訴類型檢查器應該 如何處理它
       這絕對是我想要避免的
  - k ::
       這樣看來
       就只有放棄語法擴展機制了
  - x ::
       或者說 我們可以把語法擴展機制實現得更高級
       畢竟 把模式匹配加入到語言的核心性狀之中後
       forth 對 字符串的簡單線性處理 就消失了
       語法解析是儘管很簡單
       但是是必要的了

* org-mode 的啓發
  - x ::
       既然在編譯時期
       我們已經能看到結構相對完整的代碼了
       此時我不光可以利用縮進
       我還應該 使用類 org-mode 的語法
       來設計語言的語法
  - k ::
       這樣的話
       我們就一定要把 org-mode 中我們最需要的部分提取出來
       我們可以利用 js 的 host 來利用瀏覽器的 GUI 實現文本編輯器
       並且改進其不好的地方
       只要在細節上小心設計
       我們就能得到結構化的語法擴展機制
  - x ::
       在語法解析之後
       我們可能還需要以 sexp 爲後端
  - k ::
       還是先看看如何利用 org-mode 所帶來的豐富標記語言吧
  - x ::
       headline as module
       list in headline as definition
       與 org-mode 不同的一點是
       org-mode 中文檔是一個樹
       其中 每個節點可以在包含子節點的同時 還能包含一些內容
       而 在我的語言裏 我要求 每個節點只能包含別的節點
       而不能包含內容 想要包含內容 就用一個特殊的子節點來做
       也就是說 子節點有分類
       首先應該分成兩大類
       框架性的節點 還有 內容性的節點[即葉節點]
  - k ::
       我們應該給 headline 賦以什麼語義呢
       模塊邪
  - x ::
       headline 可以用以聲明命名空間
       如果不聲明的話 就是 匿名的 headline
       儘管 headline 有名字 但是這個名字不與分割命名空間
  - k ::
       也就是說對命名空間的分割可以是任意細的
  - x ::
       這是有必要的
       有的時候 你需要在局部做一些類型檢查實驗
       還有 需要證明一些引理
       等等
       注意 除了模塊系統對名的影響之外
       還有 別的關於類型系統的機制會影響命名
       但是這些我們還沒有設計好
  ----------------------------

* 內存分配 &lt;2015-10-12&gt;
  - x ::
       到底需不需要 string-area 呢
       我們之前需要它 是因爲我們想要整齊的內存來保存 jojo
       之所以需要整齊的 內存來保存 jojo
       是因爲 想要在不知道 jojo 長度的情況下 找到 jojo 的結束位置
       但是現在根本沒有必要了
  - k ::
       但是其實 CPU 會要求地址對齊
       不過我們可以試着在 vm 中
       把這種對齊要求抽象掉
       因爲
       主要需要齊的是函數入口地址
       既然都是間接轉條的了
       image 中並不包含需要轉條到的入口地址
  - x ::
       可以試試
       以儘量把模型變簡單
       這樣我們就可以不要 string-area 了
       把所有的 byte string 都隨處保存在 image 中
       哦 還是需要 string-area
       因爲這樣 jo 這個數據結構才能整齊
</pre>
</body>
</html>
