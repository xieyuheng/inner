<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>lang/cicada/cicada-language/old/dependent-type.org</title>
</head>
<body>
<pre style="white-space: pre-wrap;">* 回顧

  - 此處 關於 子類型 的討論值得總結

  - 其他的話題
    都因沒有實際例子的實驗 而稍顯青澀

* 題解

  - 依賴性

* 散步 &lt;2015-10-06&gt;
  - x ::
       說到 依賴類型論
       類型空間裏有兩個關係
       一是 子類型
       一是 屬於
       我們的類型檢查機制
       在匹配兩個則式左右時
       只用到了 子類型關係
  - k ::
       則式之左右視爲一體 而做比配時
       確實只用到了子類型關係
       但是 則式之左右項 的內部結構 之形成
       用到了 屬於 關係
       通過 編寫 依賴性的命名標籤
       我們可以像連線畫圖一樣 構造出很微妙的類型來
  - x ::
       沒錯
       要想查明
       左右項 之間的 子類型關係
       必須要 觀察 這些內部的妙結構
       同時 這些內部的聯繫與依賴
       還決定了兩個則式複合之後的結果
  - k ::
       回想 同倫類型論說
       這些類型是對同倫等價類的編碼
       如果把 利用命名標籤 所聲明的依賴關係
       用連線表示
       那麼
       從這種連線所獲得的圖像
       已經能看出幾何的端倪了
  - x ::
       我想
       幾何意義不只在於此
       畢竟 在這種類型論中
       類型檢查期間是可以進行計算的
       在 同倫類型論 中
       人們用遞歸定義的類型來表示幾何結構
       考慮遞歸定義時所使用的 構造子
       就知道 某些幾何意義是蘊含與計算中的
       畢竟 構造子 是特殊的函數
  - k ::
       這些所能出現的計算
       把整個類型檢查的過程都變複雜了
       原本只要匹配 然後轉寫 就好
  - x ::
       考慮一下 agda 是怎麼做的
       也許這些計算是利用模式匹配來處理的
       每當 類型中出現 計算
       計算的前面 一定是一個 局部變元
       而局部變元 一定是聲明 它屬於某個之前出現的類型
       屬於關係就利用在這裏了
       也許
       當前面的項 被模式匹配之後
       就能確定這些局部變元 這樣就可以把函數作用掉了
       因爲
       知道了某個 局部變元 的類型
       這個類型的元素 一定是用 某些構造子構造的
       分類討論 構造子就行了
       這樣 這個局部變元 就被具體化了一點
       計算就可以進行了
       要知道 構造子 都是相對平凡的函數
       它們本身就像是數據一樣
       這樣函數自然就能作用於他們了
       要知道
       一個函數 要是能作用於某種類型的元素
       那麼 一定是對這種類型的元素的每個構造子
       都定義了變換規則 才行
       那麼
       結果就是
       模式匹配而得分支結構之後
       計算可以進行一點兒
       匹配則式左右時
       所需要的信息就充分一點兒
       但是注意這種分解過程可能會無限展開
       此時就需要
       遞歸調用所定義的函數來完成證明了
       也就是 數學歸納法
       也就是 定義遞歸函數
  - k ::
       哦
       我發現
       如果我們有個具體的實現來幫助討論
       那麼 對整個理論的理解 會增進很多
  - x ::
       沒錯
       這正是我現在想要做的
       但是
       這次散步還有一個論點沒有總結
       那就是
       我們忘記了一條重要的戒律
       總是這樣
       總是因爲忘記一些重要的戒律
       或忘記一些常識性的真理[真理就是常識]
       而陷入思維的困境
       此處
       我們忘記的蟬語基本戒律是
       沒有數據 只有函數
       沒有函數作用 只有函數複合
       所謂 則式左右的項
       只不過是對函數複合的表示而已
       所謂 計算出現在類型中
       只不過是某個函數插入到函數複合的序列裏而已
       則式左右的項
       之前之所以被認爲是數據
       只不過是因爲 所複合的函數性質平凡而已
       這種平凡性 使得我們把它當作樹狀的數據來處理了
       我們的類型檢查器 就成了這種樹狀數據的解釋器
       也就是說
       如果我們能處理一般的函數複合就好了
       則式左右項 之 匹配
       所需要的是判斷序關係[子類型]
       如果 在一般的函數複合下
       我們也能給出 判斷 這種序關係 的一般方法
       那麼問題就解決了
  - k ::
       哦
       我們之前說的關於模式匹配的話可能不對
       這些東西並不是 依賴類型的特性
       我們上面的話所解決的 不是 聲明依賴性的局部變元 之後的計算無法進行
       我們所解決的是 在函數體中 對類型本身所形成的有限分支的分類處理
       這種模式匹配在 haskell 中也能進行 並不是 依賴類型所特有的
       模式匹配所處理的變元 是函數的參數命名之後了的那些 有名局部變元
       而不是 在則式中 描繪依賴關係所使用的變元
  - x ::
       所以說 類型中出現計算
       或者說 則式左右出現非平凡的函數複合
       纔是依賴類型的特點
       所謂 非平凡 是相對 平凡 而言
       平凡者 可以直接作用於聲明依賴性的局部變元
       即便不知道這個局部變元的值也可以
       但是 非平凡者 則不行
  - k ::
       其實 非平凡者
       知道局部變元的類型了
       至少[有時]需要 把局部變元 在這個類型裏 再按照 構造子 分類
       才能處理它
       這就是我們之前的論點
  - x ::
       考錄對 下面兩個命題的證明
       :n odd?
       :n add1 odd?
       用集合論的術語來說
       add1 其實 類型家族 的變換
       把它插入到那個位置 這個命題所代表的類型家族就變了
       依賴性 就是 參數化
       參數化 就是 類型家族
       所以 依賴性 所帶來的 &apos;計算在類型中出現&apos; 就是 類型家族可變性
       謂詞 形成命題[集合]
       函數 修飾謂詞 從而變化命題[集合]
       重要的是
       如何處理修飾之後 則式左右序關係 的判斷問題
       也許通過 模式匹配 就能完成
       所謂 帶有依賴性的模式匹配
       但是是否如此 就有待我們再仔細觀察了
       注意注意
       :n add1 odd? 可以說是
       對由 :n 參數化 的 類型家族的變化
       也可以說成是
       對 :n 的限制
       :x odd? 這個類型家族的參數的限制
       因爲此時 :x 被限制爲了 add1 值域
       所以說 這裏有一個平凡的 序關係可以判斷的來
       那就是 :n add1 odd? &lt; :x odd?
       而我猜想 一個計算機輔助證明系統 所需要做的
       就是去處理這些平凡的情況
       而把對非平凡情況的分析留給人類
       也就是說 對於 非平凡情況
       是需要在這個 計算機輔助證明系統 中進行證明之後 才能使用的
       比如 又有某個函數叫 idd1
       那麼下面的偏序關係就是需要證明的了
       :n add1 odd? &lt; :n idd1 odd?
       假設我們有對下面命題的證明
       p (:n add1 odd? -&gt; :n idd1 odd?)
       那麼在某次 出現 :n add1 odd?
       而想要代之以 :n idd1 odd?
       的時候
       使用這個證明 p 就可以了
       也就是說 -&gt; 就是偏序關係 &lt;
       或者說 同一個偏序關係
       -&gt; 由人類處理
       &lt; 由機器處理
       這就是 爲什麼說
       有雙射的時候 (A -&gt; B) (B -&gt; A)
       兩個類型就等價了
       因爲 當回歸到集合論裏的時候
       二者只是 同一個偏序關係的兩種表示方式
  - k ::
       但是這種說法也有不足之處
  - x ::
       哦
       我們所說的 類型家族 是錯誤的
       我們上面對這個術語的使用是錯誤的
       :n odd? 是一個類型家族
       家族中的類型 比如有 1 odd?
       對 1 odd? 這個類型的證明 纔是最底層的元素
       然而
       2 add1 odd? 這個命題的證明的集合
       和 2 idd1 odd? 這個命題的證明的集合 可能並沒有包含關係
       而 包含關係 就是我們上面所聲稱 &lt;- 和 &gt; 都爲其特例的關係
       所以說 類型家族 這個術語的使用是錯誤的
       我們上面所實際考慮的是 把 odd? 當作一個謂詞時
       使得這個謂詞爲真的 整數的集合
       當 考慮 add1 odd? 時 這個集合就變化了
       所以說 add1 是集合的變換
       但是
       類型論中 應該使用的
       不是 odd? (integer -&gt; bool)
       而是 odd? (integer -&gt; proportion)
       可以發現
       說集合的包含關係的時候 也就是說 子集的時候
       我們會忽略很多信息
       而說證明的時候信息就豐富了
       到底該不該考慮子類型
       我們又遇到矛盾了
  - k ::
       考慮下面兩種 屬於關係
       1 (-&gt; integer)
       p (... -&gt; :n odd?)
       前者是集合論意義上的
       而後者不是
  - x ::
       考慮
       odd? (integer -&gt; bool)
       odd? (integer -&gt; proportion)
       後者是用推演關係定義的
       而前者是用具體的函數體定義的
       後者說
       給一個 integer #n
       我給你一個命題 :n odd?
       你需要證明這個命題是否成立
       前者說
       給一個 integer #n
       我幫你判斷 所生成的命題 :n odd? 是否成立
       子類型 是一個 關係
       即 一個 二元謂詞
       把對它的判斷 轉化爲對它的證明
       就從 &lt; 變爲了 -&gt;
       要知道 -&gt; 只不過是一個特殊的類型構造子而已
       就是返回類型[命題]的函數
       其特殊性在於 這個函數的參數個數可變
       或者說 其參數是兩個 非齊次 鏈表
       &lt; 可以被處理爲 平凡的 -&gt;
  - k ::
       那麼我們再來看接口問題
       之前說過 子類型 的判斷
       是通過 判斷其接口函數集合之間的包含關係完成的
       這裏把子類型處理爲 -&gt; 之後
       接口函數的意義何在
       A &lt; B 是說
       B 相關的函數 A 也可以用
       i (A -&gt; B) 是說
       子類型關係可以用一個嵌入映射來實現
       之後就可以使用 B 相關的函數了
  - x ::
       之所以需要子類型
       是因爲要處理商空間
       因爲發現商空間可以被處理爲接口函數[等詞]的變化
       那麼 如果 -&gt; 比子類型表達的信息更多
       那麼 對 接口函數 尤其是等詞 的變化 應該如何表達
  - k ::
       但是其實也不同
       因爲子類型是對接口函數的增加
       而商空間是對接口函數的變化
       其共同點都是
       要求用接口函數來定義類型
       或者說 接口函數是類型的本質特徵
  - x ::
       每當用一些底層的東西來實現一個數據結構
       並且暴露出接口來的時候
       是否其實都是在做 商類型
       典型的就是 有理數
       用數對來實現 並且重新定義操作 自然也要重新定義等詞
       商類型關係 就是模塊之間的依賴關係
       或者說 用已有函數和類型 實現新函數和類型
       商 並不是簡單的去掉某些性質
       就等詞而言 等詞是辨別功能減弱了
       但是 接口函數完全不同了
       比如 分數的乘法
       所以把商理解爲 新結構的實現過程 才對
       因爲 做實現的時候 關係可以非常複雜
       相互實現 是一種等價關係
       數對可以實現有理數
       有理數可以實現數對
       鏈表可以實現樹
       樹可以以種方式實現鏈表
       等等
       在某些地方可能要從這個方向來做實現
       在其他地方又要反過來
       因爲 所能得到的 primitive-function 不同
       不同的實現方式的效率也不同
  - k ::
       這也說明了 爲什麼同構的東西不能等同
       因爲 對某個數據結構的實現方式不同 效率可能非常不同
       在我們的語言中
       能不能把對效率的推演也自動化 或者形式話
  - x ::
       至少 商空間 關係所揭示出來的效率是可以被形式化的
       注意 新定義的等詞必須在底層被證明是等價關係 才能用來做商

* 整理 &lt;2015-10-07&gt;

*** 非平凡的匹配關係需要證明
    - 機器並不能處理
      一般的函數複合所形成的則式左右的序關係

*** 則式 就是 模式匹配
    - 我想 說類型是編譯時期 類型檢查器所做的計算
      那麼 定義函數的時候 其類型也就像函數體一樣被定義
      所謂
      類型中有一些沒有確定數據
      就是 類型有些計算做不了
      但是這正是函數體的性質
      函數體中出現的計算 是函數調用時執行的
      而不是函數定義時執行的
      則式 中的有名局部變元
      正如 函數體中的有名局部變元
    - 一個則式
      (... -&gt; ...)
      和 + ... | ...
      這種模式匹配很像
      依賴性就像是在模式中加守衛一樣
    - 則式 之爲模式匹配
      其參數中可以出現有名局部參數
      即 有名局部參數本身做爲參數 這個參數可能沒有綁定值
      即 則式 之爲計算
      其參數中的不確定性可以被傳遞到下一個複合的函數
    - 函數體中的模式匹配
      變元只有抓到了參數之後 計算才能進行
      在類型檢查中 參數的具體值是不確定的[類型是確定的]
      也就是說 匹配項的前項 要能夠做爲參數 而不是做爲匹配
    - 比如
      #+begin_src cicada-language
      ({natural #n} :n list -&gt; :n add1 list)
      #+end_src
      我想我知道如何實現了
      只要把每個 局部有名參數
      都處理爲一個 特殊的 豐富的 數據結構就可以了
    - 匹配之後 這些東西就被入 一個棧
      函數體作用的時候 需要用到這些匹配到的參數的時候
      就從這個棧中把數據取出來
    - 這種過程是可以嵌套的
      就像是函數體中的模式匹配可以嵌套一樣
      利用棧 就能處理命名空間的問題
    - 還需要解決的問題就是基本數據結構的設計
      此處需要注意等詞
      此處使用局部內存

*** 使用局部內存
    - 實在不行就先完全不考慮效率了
      給棧中的所有數據都加上動態類型標籤
    - 這將降低效率
      但是大大豐富語言的特性
      使得動態類型語言的優點都能包括進來
    - 每個數據類型中都要能夠包含 有名局部參數
      這樣類型標籤就是必要的了
    - 之前對於結構化的數據的想法是
      |--------+------------------|
      | field1 | length of field1 |
      |        | ...              |
      |--------+------------------|
      | field2 | length of field2 |
      |        | ...              |
      |--------+------------------|
      | ...    |                  |
      |--------+------------------|
      | null   |                  |
      |--------+------------------|
      有了類型標籤之後
      每個數據佔用棧中的兩個 cell
      結構化的類型
      在 type cell 中
      只保存 類型構造子的名字
    - 在哪裏用到了這些類型標籤
      是類型檢查器所用到的等詞
      如果這個等詞甚至不能分辨棧裏的一個地址或數值
      那麼就根本沒法用以匹配結構化的數據了
    - 還有一個用到的地方是
      交互的用戶接口上
      在 REPL 中調用一個函數的時候可以先檢查棧中參數的類型
      儘管此時對類型的檢查是不可能完備的但是已經夠用了
    - 現在可以着手實現了
      首先是 racket 中的 vm
      需要給 vm 的 argument-stack 和 return-stack
      加上 argument-point 和 return-stack
      更需要先寫一個簡單的 vm 匯編器
      使得可以進行測試

*** local-tag
    - local-tag 做爲 data 的特殊性在於
      它們可以出現在另一個棧中
      而不是單純出現在 argument-stack 中

*** 實現
    - 每個參數在匹配的時候
      不光能夠匹配某個類型的值
      還要能夠匹配某個類型的未被賦值的局部變量
      後者稱爲不確定匹配
    - 匹配到的值 會被放到局部的 local-stack 中
      函數體作用時 可以在其中查找
      這是最簡單的實現方法
    - 當 不確定匹配 出現時
      函數體的作用是 不確定作用
      其效果是 更新不定量中的不確定性
      類型也會跟着更新
    - 不確定性可能隨時成爲確定
      所以 函數體要跟着走
      其實類型檢查只用到了類型

* 函數體中保存 tag-group index 還是保存 sequent
  - tag-group index 比 sequent 慢一次引用
  - 保存 sequent 並不影響對不確定性的更新
    因爲類型是跟着 sequent 走的

* 考慮現在已有的 type
  - fixnum
  - tag
  - tag-group
  - sequent
  - vector with length
    [vector address]
    address :
    |----------------|
    | length         |
    |----------------|
    | type-tag, data |
    | ...            |
    |----------------|
  - string byte vector with length
    [string address]
    address :
    |--------|
    | length |
    |--------|
    | byte   |
    | ...    |
    |--------|
    這樣的 string 顯然不利於某些處理
    length 與 address 分開才有利
    分離的同時還能保持一致的 type-tag data-address 的效果
    爲了維護這種效果 需要再用一層間接
    [string data]
    data :
    | length  |
    | address |
    address :
    | byte |
    | byte |
    | ...  |
  - vector 也是如此
    方便遞增就方便用遞歸函數遍歷
    這樣的 vector 嵌套也方便

* 數據結構回顧
  - 看看現在已有的數據結構
    如何能被新的格式規範化
  - 其實並沒有必要規範化
    只要 在棧中 有 [type-tag data] 這種存在就可以了

* local-point
  - x ::
       local-point 的結構應該如何
  - k ::
       看其功能如何
  - x ::
       功能中最基本的部分
       是局部的名[tag]與值的對應
       這樣就需要有一個 tag 域
       做爲這個 局部變元的名字
  - k ::
       所謂的不定變元是什麼意思
       能舉一個例子嘛
  - x ::
       在類型檢查
       #+begin_src cicada-language
       * list-length?map
         ({type #type #type&apos;
           (:type -&gt; :type&apos;) #function
           :type list #list natural #length}
          :list :length list-length?
          --------------------------&gt;
          :list :function map :length list-length?)
         + list-length?null
         | list-length?null
         + :inductive-hypothesis list-length?cons
         | :inductive-hypothesis list-length?map list-length?cons
       #+end_src
       時
       當如下的不定元入棧時
       {integer #n} :n
       它不在 local-stack 中
       而是在 argument-stack 中
       此時它的類型是 local-tag
       | tag      |
       | type-tag |
       後面的則式可能會去匹配它
       能夠作用於某個類型的函數
       也能夠作用於這個類型的不定元
  - k ::
       其實不是不入 local-stack
       因爲要引入不定元 就必須有命名
       [也許可以有無名機制 但是先假設必須命名]
       而命名者就能多次出現
       所以 local-point 中一定保存了與不定元相關的信息
       使得名字再次出現時
       能夠知道入 argument-stack 的不定元的類型 等等
  - x ::
       而引入
       也就是說 一個類型式子有兩種用法
       一個是用於類型檢查的
       一個是模式匹配的作用
       用於類型檢查時 每個 #name 都將入 local-stack
  - k ::
       我覺得此處有必要好好整理一下之前從 agda 抄來的例子
       因爲此時我們已經基本建立起了具體語義

* typeclass &amp; functor

  - 類似 typeclass
    但是相反 描述某些抽象的特性 然後找滿足這些抽象的特性的例子
    此時我們 觀察已有的類型的共同點 然後把這些共同點提取出來

  - 一旦把相似性提取出來之後
    我們就能利用 用以編碼 相似性 的接口函數
    來寫適用於多個類型的函數了 [所謂 generic function]

  - 技巧是 把原本用 子集 描述的東西
    用 映射的值域 來描述
    而 映射的義域 用以勾勒出 值域 做爲子集的範圍
    定義類型 的 構造子 就是用以 用以勾勒出 值域 範圍 的 子集
    同時還要有一個配合這個 所定義的類型的 解釋函數
    - 就像是 指稱語義 一樣
      所以 有一種 DSL[domain specific language] 的感覺
    比如 對於 functor 解釋函數是 functor:apply
    比如 對於 format 解釋函數是 data

* comtime and runtime
  - x ::
       可以想像區分
       comtime-function-body
       和
       runtime-function-body
       這樣
       每個 function 就有兩個 body
       就回到了古典 forth 的感覺
       一個詞要定義兩遍
       一遍爲 comtime
       一遍爲 runtime
       二者有什麼區別呢
  - k ::
       先不考慮 古典 forth 的語義
       就考察一下現在所設計的類型檢查所造成的 comtime
  - x ::
       我想這是自然的
       所謂
       類型檢查的本質是
       編譯時期對帶有不定元的計算結果的檢查
       這樣
       一個函數名字必定有兩個函數體了
       一個爲運行時的具體計算
       一個爲編譯時的類型檢查
  - k ::
       但是問題是
       可否在 編譯時作用 運行時的函數體
       可否在 運行時作用 編譯時的函數體
  - x ::
       我想是這樣的
       一個函數有兩個函數體
       暫且稱之爲 function-body
       和 type
       看看它們分別有什麼作用
       再看如何實現
       首先是作用
       function-body 的語義應該是最爲清晰和熟悉的
       就是 之前的 jojo 和 參數棧 還有 返回棧
       可以發現 type 的實現方式完全相同
       尤其是考慮到不定元的加入之後
       只是函數的連個函數體的作用時間不同
  - k ::
       所以重要的就是弄清楚
       兩個函數體分別在什麼時候作用
  - x ::
       function-body 的主要作用時間是顯然的
       之所以有別的作用時間就是因爲有 type
       在實現類型系統之前
       根本沒有區分編譯時和運行時
       實現類型系統之後
       類型檢查構成了另外一種作用時間
       它們用到了 參數棧
       當定義一個函數的時候
       首先是把函數體編譯好
       [假設有被編譯好的函數體有足夠的信息來做類型檢查]
       此時函數體還只是存在在 local-memory 中
       只有類型檢查通過之後才把它轉移到詞典中
       [如此就能讓類型檢查變成一種可選性狀
        因爲
        可以在不做類型檢查的情況下
        就把 local-memory 中的函數體複製到詞典中]
       之後就是類型檢查的時間
       類型檢查所構成的函數作用不會有嵌套
       也就不需要返回棧
       只需要一個全局的指針
       就足以記住函數體的位置
  - k ::
       這是一個之前沒有注意到的現象不是嘛
  - x ::
       沒錯
       我們之前甚至都沒有注意到這種特點
       就想統一對 兩種計算時段的處理方式
  - k ::
       這個差別看來使得統一的希望渺茫了
       是否應該使用參數棧也成問題了
  - x ::
       我們再來看一下具體的實現方式
       也許確實不應該使用參數棧
       因爲當類型不匹配時 需要非局部退出
       如果使用額外的棧 非局部退出容易實現多了
       但是
       仍然假設使用 argument-stack 而不用額外的棧
       現在已經有編譯好的函數體了
       需要檢查所聲明的類型是否與函數體的類型相同了
       首先
       所聲明的 則式 的左邊入棧
  - k ::
       我有觀察到一個要點
  - x ::
       我也觀察到了
       那就是
       左邊通常是用於匹配的
       當把它們做爲值入棧時
       就得到不定元了
       這樣
       利用不定元來做匹配
       就不浪費代碼了
       我們來具體看一下如何用不定元做匹配
  - k ::
       我們之前進展緩慢
       不都是因爲每每到關鍵時刻就停下來休息嘛
       正如 都柏林人 中的 精神癱瘓
  - x ::
       沒錯
       這次吸取教訓
       在 argument-stack 中的一個不定元
       就是 [local-point . address in local-stack]
       而這個 local-point 中
       保存這這個 局部變元的
       名字
       不定性
       類型
       值
       這些域還不一定足夠
       [也許當函數作用於不定元時
        不定元會把這個函數吸收]
       所形成的不定元可以先保存在 local-memory 中
       比如 [indeterminate-argument-vector . address]
       然後 用以比較實際參數棧中的 方式 也可以想像了
       比如
       :car :cdr cons
       :car 和 :cdr 會形成兩個新的 local-point
       每個都只有名字甚至連類型都不確定
       當有 cons 作用於它們時
       它們的類型就可以確定了
       [一旦確定一點信息就不能更改
        當發現不匹配時就是類型檢查不通過]
       在虛擬的棧中
       即 在 indeterminate-argument-vector 中
       cons 所入棧的結構化的值是包含兩個不定元的
       也就是包含兩個 local-point 的
  - k ::
       哦
       可以發現應該先在 argument-stack 中生成
       然後再轉移到 indeterminate-argument-vector 中
       這樣就不用更改 cons 的接口了
  - x ::
       沒錯
       當形成了 indeterminate-argument-vector
       並用以匹配棧中真正的 argument-stack 時
       所需要的成功效果是 給 local-point 賦值
       不成功效果是
       在不匹配時 報錯 [類型檢查]
       在不匹配時 報錯 轉移到下一個 pattern [函數作用]
  - k ::
       這樣
       類型檢查時
       所聲明的則式的前項
       就是只在參數棧中做不定元
       而不形成 indeterminate-argument-vector
  - x ::
       這樣我們就還要考慮
       indeterminate-argument-vector 匹配參數棧中不定元的情況
       注意
       所謂匹配所使用的其實是逐項的序關係或者等詞
       當參數中出現不定元時
       只要序關係能夠正常工作就行
       用函數複合來考慮
       只要後面的函數的接口更一般
       就能複合到前面的函數
       所以後面的項的類型要更寬泛才行
       還要注意
       類型檢查的時候
       每個則式退出時
       都會重置 return-point 中的 local-point 這個域
       這個域 其實是 local-stack-pointer
       或者說 local-stack-current-free-address
       [在命名的時候如果都有 &apos;pointer&apos; 後綴
        幹嘛不省略它們呢]
       這種重置的意思就是說
       每個函數體可能對參數棧中的數據做了一些事
       但是之後函數體的效果
       還有函數體在作用時所需要引入的命名
       都消失了
       類型在此與函數體的性質無異
  - k ::
       類型檢查所形成的計算不能嵌套如何解釋
       一個函數的兩個函數體何時得以作用如何確定
       不定元對函數的吸收如何解釋
  - x ::
       首先是
       類型檢查所形成的計算不能嵌套
       這要看說的是哪種意義上的嵌套
       首先
       在調用一個類型檢查的過程中
       不會調用另一個類型檢查
       這可以被稱爲不能嵌套
       其次
       在某個類型的作用過程中
       return-stack 可能會被累積
       這種意義上來說
       類型的作用與一般函數體作用並沒有區別
  - k ::
       其次是
       一個函數的兩個函數體何時得以作用
  - x ::
       兩種函數體的作用方式相同
       但是作用時間不同
       其實
       作用方式也是不同的
       因爲
       類型在作用的時候
       一定是[通常是]類型檢查的時候
       此時一定有返回棧中的異常處理點
       在等待因爲不匹配而出現的非全局退出
       這裏可以看出
       兩種不匹配的情況
       最好能以一致的方式處理
  - k ::
       能否以一致的方式處理尚不確定
       繼續回答
       一個函數的兩個函數體何時得以作用
  - x ::
       顯然兩種函數體各有連個主要作用時間
       一般模式匹配 一般計算
       類型的不定匹配 類型檢查
       所以問題其實是
       一般的計算中能否有類型函數體的作用
       類型檢查中能否有一般函數體的作用
       我想即便是這後兩個問題也是虛的
       其實
       類型函數體的作用是被嚴格限制在類型檢查的語境當中的
       只有在類型檢查的過程當中
       需要作用一個函數時纔會去找它的類型函數體
       而一般的時候都是一般函數體
       所謂 一般的時候
       指兩種
       其一爲 則式後項計算時
       其二爲 則式前項將不定元入棧時
       我想二者中都應該允許 顯式的對某個函數的類型函數體的作用
       當一個函數體作用的時候
       它並不知道自己是哪種函數體
       這也解釋了爲什麼 &apos;不能嵌套&apos;
       也解釋了什麼是 &apos;類型檢查語境&apos;
  - k ::
       還有
       就是
       不定元對函數的吸收如何解釋
  - x ::
       這裏還涉及一個問題
       就是
       我之前誤認爲
       每當作用於不定元時
       就應該使用函數的類型函數體
       那是在不考慮
       對函數的吸收 的情況下所得出的印象
       如果使用 對函數的吸收
       那麼
       每個 local-point 中的數據就更豐富了
       但是 local-point 中的數據是不能被改變的
       那麼所說的 對函數的吸收 又指什麼呢
       這個問題也是虛的嘛
       cons 這種 元素構造子 在作用於不定元的時候
       並不必考慮所謂 &apos;不定元對函數的吸收&apos;
       只不過是 cons 所返回的結構化數據的兩個域中帶有不定元而已
       但是 add 這類函數就不同了
       比如 1 :n add
       之後棧中應該只有一個屬於 fixnum 類型的值
       但是 [fixnum . address in local-memory]
       address
       | 1   |
       | :n  |
       | add |
       也許應該是
       [indeterminate fixnum . address in local-memory]
       否則就與 真正的 fixnum 沒法區分了
       也許應該是
       [indeterminate . address in local-memory]
       address
       | fixnum |
       |--------|
       | 1      |
       | :n     |
       | add    |
       這種東西之存在意義何在還不清楚
       但是
       我們儘量把最多的信息包含進來
       以實現最豐富的性狀
  - k ::
       還有一點就是
       類型的作用因爲不能形成嵌套
       所以根本不用返回結構化的值給父函數
  - x ::
       我不知道這種說法是否準確
       也許 結構化的返回值 值得另行討論

* 結構化的返回值
  - x ::
       結構化的值需要能夠在兩個 相互共軛的 局部內存 之間來回複製
       這種複製是自動完成的
       這種複製是遞歸的
       這種複製是不重複的
       所謂 不重複
       就是當發現某個值已將在 共軛局部內存 中了
       就不要複製它了
       但是
       當它本身在 共軛局部內存 中時
       它的某個域中所引用的東西可能不再 共軛局部內存 中

* 如何設計 function 這個數據結構
  - x ::
       在有 模式匹配 的情形下 function-body
       的結構就要變複雜了
       不是簡單的一個 function 的 vector
       而是一列 pattern match
       [甚至不是整齊的 vector 而要用計算長度來處理遍歷]
  - k ::
       那就像是之間的 branch 和 false?branch 一樣了
  - x ::
       也就是說
       需要實現一些 branch 之類的 特殊指令
       類型檢查想來又有論難了
  - k ::
       我們來仔細觀察一下吧
  - x ::
       這裏涉及運行流程的東西很難設計
       因爲看來有 非局部退出
  - k ::
       也許並沒有難以繞過的 非局部退出
  - x ::
       還記得之前所說的 函數作用的階段嘛
       那就是新的函數語義的實現方式

* 一致性
  - x ::
       先不考慮一致性
       並且
       先在大體上模仿 agda
       之後再更改實現技術和性狀
  - k ::
       這樣就完全依賴遞歸定義了
       在 純粹的 agda 中
       好像沒有數據結構不是遞歸定義而成的

* 反思 &lt;2015-10-27&gt;

  - x ::
       沒有弄清楚類型檢查的最基本概念之間的關係
  - k ::
       我想很多難點來自於 模式匹配
       要知道 此時我們的函數體都是模式匹配了
  - x ::
       所以說
       也許在觀察系統的本質特種的時候
       我們應該從 模式匹配 入手
       並且注意類型本身也是一個模式匹配項
  - k ::
       我想首先就是術語
       則式 也就是 sequent 這個術語又可以被重新拾起來了
       每個模式匹配項就是一個 sequent
  - x ::
       則式 就是 前項 與 後項
       sequent
       antecedent
       succedent
  - k ::
       做爲類型的 則式
       和做爲函數體的 則式
       之間的差異是很明顯的不是嗎
  - x ::
       後者總是多個才能成體
       而前者單獨就能成類型
       前者 前項 的某個元素[類型]
       被分解爲 這個類型的 元素構造子
       每個 元素構造子 都成一個函數體中模式匹配的則式

* 類型檢查

  - 聲明類型
    函數體

  - 聲明類型 的前項入棧
    可能帶有 不定元

  - 函數體有很多則式
    逐個檢查
    注意
    此處還可能添加 完全性檢查

  - 有一函數體則式
    首先
    前項 用 type-body 特化 棧中的 聲明前項
    其次
    後項 每個函數的 type-body
    作用於 棧中被特化了的 聲明前項
    得到結果 與聲明後項 比較
</pre>
</body>
</html>
