<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>note/computer-science/database/postgresql-note.md</title>
</head>
<body>
<pre>---
title: PostgreSQL Note
---

# PostgreSQL Note

## Command line

About database:
- create: `createdb &lt;db_name&gt;`
  like `CREATE DATABASE &lt;db_name&gt;;`
- delete: `dropdb &lt;db_name&gt;`
  like `DROP DATABASE &lt;db_name&gt;`
- list: `psql -l`
  like `SELECT * FROM pg_database;`

## Default databases

- `postgres` for the user `postgres`,
  some programs assume this database exists,
  (such as pgadmin).
- `template1`, whatever you put into it,
  it will be available in a new database
  if you use the following syntax: `create database &lt;db_name&gt;;`
  This can simplify your deployments a lot
  if you rely on pre-installed objects
  for example monitoring or development.
  We also can explicitly specify a db as template
  `CREATE DATABASE &lt;db_name&gt; TEMPLATE &lt;db_name&gt;;`
- `template0` is the only database that has &quot;datallowcon&quot; set to false,
  it is the default unmodifiable database.
  You never should make any changes there.
  In a new pos PostgreSQL instance,
  `template0` and `template1` are exactly the same.
  To recover a new `template1` from `template0`,
  ``` sql
  UPDATE pg_database SET datistemplate = false WHERE datname = &apos;template1&apos;;
  -- you can not drop a database flagged as a template.
  DROP database template1;
  CREATE database template1 TEMPLATE template0;
  UPDATE pg_database SET datistemplate = true WHERE datname = &apos;template1&apos;;
  ```

What about the overhead:
``` sql
SELECT * FROM pg_size_pretty(pg_database_size(&apos;template0&apos;));
SELECT * FROM pg_size_pretty(pg_database_size(&apos;template1&apos;));
SELECT * FROM pg_size_pretty(pg_database_size(&apos;postgres&apos;));
```

# (2001) Postgresql Introduction and Concepts
</pre>
</body>
</html>
