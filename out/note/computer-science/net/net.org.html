<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>note/computer-science/net/net.org</title>
</head>
<body>
<pre>#+title: net

* *links*

  - standard library
    <a href="http://docs.python.org/3/library/">http://docs.python.org/3/library/</a>

  - tutorial
    <a href="https://docs.python.org/3/tutorial/">https://docs.python.org/3/tutorial/</a>

  - full stack python
    <a href="https://www.fullstackpython.com/">https://www.fullstackpython.com/</a>

  - sicp in pyhton
    <a href="http://www-inst.eecs.berkeley.edu/~cs61a/sp12/book/">http://www-inst.eecs.berkeley.edu/~cs61a/sp12/book/</a>
    <a href="https://wizardforcel.gitbooks.io/sicp-in-python/content/1.html">https://wizardforcel.gitbooks.io/sicp-in-python/content/1.html</a>

  - python 3 module of the week
    <a href="https://pymotw.com/3/">https://pymotw.com/3/</a>

  - python package index
    <a href="https://pypi.python.org/">https://pypi.python.org/</a>

* unix network programming -- volume 1 -- the sockets networking api
* tcp/ip illustrated, volume 1: the protocols
* beej&apos;s guide to network programming -- using internet sockets

*** 5. system calls or bust

***** 5.1. getaddrinfo()—Prepare to launch!

      #+begin_src c
      #include &lt;sys/types.h&gt;
      #include &lt;sys/socket.h&gt;
      #include &lt;netdb.h&gt;

      int getaddrinfo(const char *node,     // e.g. &quot;www.example.com&quot; or IP
                      const char *service,  // e.g. &quot;http&quot; or port number
                      const struct addrinfo *hints,
                      struct addrinfo **res);


      struct addrinfo {
        int              ai_flags;     // AI_PASSIVE, AI_CANONNAME, etc.
        int              ai_family;    // AF_INET, AF_INET6, AF_UNSPEC
        int              ai_socktype;  // SOCK_STREAM, SOCK_DGRAM
        int              ai_protocol;  // use 0 for &quot;any&quot;
        size_t           ai_addrlen;   // size of ai_addr in bytes
        struct sockaddr *ai_addr;      // struct sockaddr_in or _in6
        char            *ai_canonname; // full canonical hostname

        struct addrinfo *ai_next;      // linked list, next node
      };


      struct sockaddr {
        unsigned short    sa_family;    // address family, AF_xxx
        char              sa_data[14];  // 14 bytes of protocol address
      };
      #+end_src

      - example :
        server listen on host&apos;s IP address, port 3490.

      #+begin_src c
      int status;
      struct addrinfo hints;
      struct addrinfo *servinfo;  // will point to the results

      memset(&amp;hints, 0, sizeof hints); // make sure the struct is empty
      hints.ai_family = AF_UNSPEC;     // don&apos;t care IPv4 or IPv6
      hints.ai_socktype = SOCK_STREAM; // TCP stream sockets
      hints.ai_flags = AI_PASSIVE;     // fill in my IP for me

      if ((status = getaddrinfo(NULL, &quot;3490&quot;, &amp;hints, &amp;servinfo)) != 0) {
        fprintf(stderr, &quot;getaddrinfo error: %s\n&quot;, gai_strerror(status));
        exit(1);
       }

      // getaddrinfo() returns non-zero on error
      // print it out by gai_strerror(),

      // servinfo now points to a linked list of 1 or more struct addrinfos

      // ... do everything until you don&apos;t need servinfo anymore ....

      freeaddrinfo(servinfo); // free the linked-list
      #+end_src

      - example :
        client connect to a particular server,
        say &quot;www.example.net&quot;
        port 3490.

      #+begin_src c
      int status;
      struct addrinfo hints;
      struct addrinfo *servinfo;  // will point to the results

      memset(&amp;hints, 0, sizeof hints); // make sure the struct is empty
      hints.ai_family = AF_UNSPEC;     // don&apos;t care IPv4 or IPv6
      hints.ai_socktype = SOCK_STREAM; // TCP stream sockets

      // get ready to connect
      status = getaddrinfo(&quot;www.example.net&quot;, &quot;3490&quot;, &amp;hints, &amp;servinfo);

      // servinfo now points to a linked list of 1 or more struct addrinfos

      // etc.
      #+end_src

***** 5.2. socket()—Get the File Descriptor!

      #+begin_src c
      #include &lt;sys/types.h&gt;
      #include &lt;sys/socket.h&gt;

      int socket(int domain, int type, int protocol);
      #+end_src

      - example :

      #+begin_src c
      int s;
      struct addrinfo hints, *res;

      // do the lookup
      // [pretend we already filled out the &quot;hints&quot; struct]
      getaddrinfo(&quot;www.example.com&quot;, &quot;http&quot;, &amp;hints, &amp;res);

      // [again, you should do error-checking on getaddrinfo(), and walk
      // the &quot;res&quot; linked list looking for valid entries instead of just
      // assuming the first one is good (like many of these examples do.)
      // See the section on client/server for real examples.]

      s = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);
      #+end_src

***** 5.3. bind()—What port am I on?

      #+begin_src c
      #include &lt;sys/types.h&gt;
      #include &lt;sys/socket.h&gt;

      int bind(int sockfd, struct sockaddr *my_addr, int addrlen);
      #+end_src

      - example :

      #+begin_src c
      struct addrinfo hints, *res;
      int sockfd;

      // first, load up address structs with getaddrinfo():

      memset(&amp;hints, 0, sizeof hints);
      hints.ai_family = AF_UNSPEC;  // use IPv4 or IPv6, whichever
      hints.ai_socktype = SOCK_STREAM;
      hints.ai_flags = AI_PASSIVE;     // fill in my IP for me

      getaddrinfo(NULL, &quot;3490&quot;, &amp;hints, &amp;res);

      // make a socket:

      sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);

      // bind it to the port we passed in to getaddrinfo():

      bind(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);
      #+end_src

***** 5.4. connect()—Hey, you!

      #+begin_src c
      #include &lt;sys/types.h&gt;
      #include &lt;sys/socket.h&gt;

      int connect(int sockfd, struct sockaddr *serv_addr, int addrlen);
      #+end_src

      - example :
        make a socket connection to &quot;www.example.com&quot;, port 3490

      #+begin_src c
      struct addrinfo hints, *res;
      int sockfd;

      // first, load up address structs with getaddrinfo():

      memset(&amp;hints, 0, sizeof hints);
      hints.ai_family = AF_UNSPEC;
      hints.ai_socktype = SOCK_STREAM;

      getaddrinfo(&quot;www.example.com&quot;, &quot;3490&quot;, &amp;hints, &amp;res);

      // make a socket:

      sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);

      // connect!

      connect(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);
      #+end_src

***** 5.5. listen()—Will somebody please call me?

      #+begin_src c
      int listen(int sockfd, int backlog);
      #+end_src

***** 5.6. accept()—&quot;Thank you for calling port 3490.&quot;

      #+begin_src c
      #include &lt;sys/types.h&gt;
      #include &lt;sys/socket.h&gt;

      int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
      #+end_src

      - example :

      #+begin_src c
      #include &lt;string.h&gt;
      #include &lt;sys/types.h&gt;
      #include &lt;sys/socket.h&gt;
      #include &lt;netinet/in.h&gt;

      #define MYPORT &quot;3490&quot;  // the port users will be connecting to
      #define BACKLOG 10     // how many pending connections queue will hold

      int main(void) {
        struct sockaddr_storage their_addr;
        socklen_t addr_size;
        struct addrinfo hints, *res;
        int sockfd, new_fd;

        // !! don&apos;t forget your error checking for these calls !!

        // first, load up address structs with getaddrinfo():

        memset(&amp;hints, 0, sizeof hints);
        hints.ai_family = AF_UNSPEC;  // use IPv4 or IPv6, whichever
        hints.ai_socktype = SOCK_STREAM;
        hints.ai_flags = AI_PASSIVE;     // fill in my IP for me

        getaddrinfo(NULL, MYPORT, &amp;hints, &amp;res);

        // make a socket, bind it, and listen on it:

        sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);
        bind(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);
        listen(sockfd, BACKLOG);

        // now accept an incoming connection:

        addr_size = sizeof their_addr;
        new_fd = accept(sockfd, (struct sockaddr *)&amp;their_addr, &amp;addr_size);

        // ready to communicate on socket descriptor new_fd!
        // ...
      }
      #+end_src

***** 5.7. send() and recv()—Talk to me, baby!

***** 5.8. sendto() and recvfrom()—Talk to me, DGRAM-style

***** 5.9. close() and shutdown()—Get outta my face!

***** 5.10. getpeername()—Who are you?

***** 5.11. gethostname()—Who am I?

* foundations of python network programming

*** Chapter 1: Introduction to Client-Server Networking

*** Chapter 2: UDP

*** Chapter 3: TCP

*** Chapter 4: Socket Names and DNS

*** Chapter 5: Network Data and Network Errors

*** Chapter 6: TLS/SSL

*** Chapter 7: Server Architecture

*** Chapter 8: Caches and Message Queues

*** Chapter 9: HTTP Clients

*** Chapter 10: HTTP Servers

*** Chapter 11: The World Wide Web

*** Chapter 12: Building and Parsing E-Mail

*** Chapter 13: SMTP

*** Chapter 14: POP

*** Chapter 15: IMAP

*** Chapter 16: Telnet and SSH

*** Chapter 17: FTP

*** Chapter 18: RPC
</pre>
</body>
</html>
