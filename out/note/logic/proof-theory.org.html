<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>note/logic/proof-theory.org</title>
</head>
<body>
<pre>#+title: proof theory

* [todo-stack]

  - one language can use different type systems,
    just as one proof style can be applied to different logics.

  - classical logic and logic programming

  - how different proof styles are correspond to each other?

* plan

  - in sequent calculus style, I will show :
    1. the proof theory of intuitionistic logic
    2. why class logic is not constructive
    3. how to restrict semantics to get linear logic

  - no inductively defined type in this version.

  - no conj, because we have data stack.

  - no duality,
    because the dogma of duality
    is in conflict with the dogma of constructivism.

  - we *do* need disj,
    but literal disj is only used for types, not for values,
    because literal disj of values
    will introduce the concept of non-deterministic.

  - (+) is a type-constructor,
    and hypothetical object of this type
    will be used by (case)

  - objects of disj type can be returned,
    only because of different types are returned
    in different branches of a (case)

  - this is also true for arrow
    we use literal arrow for types,
    but not for values.

  - (-&gt;) is a type-constructor,
    and hypothetical object of this type
    will be used by &apos;apply&apos; and &apos;compose&apos;

* (1975) (gaisi takeuti) proof theory

*** chapter 1 first order predicate logic

*** chapter 2 peano arithmetic

*** chapter 3 second order systems and simple type theory

*** chapter 4 infinitary logic

*** chapter 5 consistency proofs

* (1998) (buss) an introduction to proof theory

*** proof theory of propositional logic

***** intro

      - propositional variable

      - propositional formula formed by a set of connectives

      - inputting true or false
        to a formula&apos;s variables,
        the formula can be viewed as a boolean function.

      - so defined formal language is *complete*,
        if every boolean function can be defined by a formula.

      - a propositional formula is a *tautology*
        or to be (classically) valid
        if its boolean function always return true.

      - a propositional formula is a *satisfiable*
        if its boolean function can return true.

      - if we want to decide whether a formula
        is a tautology,
        we can check if it returns true on all its input.
        this brute-force method is of O(n^2)

      - propositional proof systems provide better methods.

***** frege proof systems

******* one inference rule

        - modus ponens

        #+begin_src jojo
        :a : A, :f : (-&gt; A -- B)
        --------------------------
        :a :f : B
        #+end_src

******* axiom schemes

        #+begin_src jojo
        (+fun * (-&gt; :a1 : :P1 -- (-&gt; :P2 -- :P1))
          {drop :a1})

        (+fun * (-&gt; :f1 : (-&gt; :P1 -- :P2)
                    :f2 : (-&gt; :P1 -- (-&gt; :P2 -- :P3))
                 -- (-&gt; :P1 -- :P3))
          {dup :f1 swap :f2 apply})

        (+fun * (-&gt; :P1 -- (+ :P1 :P2))
          nop)

        (+fun * (-&gt; :P2 -- (+ :P1 :P2))
          nop)

        (+fun *
          (-&gt; :f1 : (-&gt; :P1 -- :P3)
              :f2 : (-&gt; :P2 -- :P3)
           -- (-&gt; (+ :P1 :P2) -- :P3))
          {(case dup
             :P1 :f1
             :P2 :f2)})

        (+fun * (-&gt; :P1 :P2 -- :P1)
          drop)

        (+fun * (-&gt; :P1 :P2 -- :P2)
          swap drop)

        (+fun * (-&gt; :P1 :P2 -- :P1 :P2)
          nop)
        #+end_src

***** the propositional sequent calculus

******* inference rules

        #+begin_src jojo
        (-&gt; X -- (+ Y A))
        (-&gt; A X -- Y)
        ------------------------ cut
        (-&gt; X -- Y)

        (-&gt; A B X -- Y)
        ------------------------ conj-left
        (-&gt; (* A B) X -- Y)

        (-&gt; X -- (+ Y A))
        (-&gt; X -- (+ Y B))
        ------------------------ conj-right
        (-&gt; X -- (+ Y (* A B)))

        (-&gt; A X -- Y)
        (-&gt; B X -- Y)
        ------------------------ disj-left
        (-&gt; (+ A B) X -- Y)

        (-&gt; X -- (+ Y A B))
        ------------------------ disj-right
        (-&gt; X -- (+ Y (+ A B)))

        (-&gt; X -- (+ Y A))
        (-&gt; B X -- Y)
        ------------------------ arrow-left
        (-&gt; (-&gt; A -- B) X -- Y)

        (-&gt; A X -- (+ Y B))
        ------------------------ arrow-right
        (-&gt; X -- Y (-&gt; A -- B))
        #+end_src

******* one axiom scheme

        #+begin_src jojo
        (-&gt; :A -- :A)
        #+end_src

***** propositional resolution refutations

*** proof theory of first-order logic

***** syntax and semantics

      #+begin_src jojo
      (-&gt; :x : A -- :x B)
      [:x : A, :x B]
      #+end_src

***** hilbert-style proof systems

***** the first-order sequent calculus

******* inference rules

        #+begin_src jojo
        (-&gt; t A, X -- Y)
        ------------------------ hypo-left
        (-&gt; (-&gt; :x : :T -- :x A) X -- Y)
        #+end_src

***** cut elimination

***** herbrand&apos;s theorem, interpolation and definability theorem

***** first-order logic and resolution refutations

*** proof theory of other logics  /home/xyh

***** intuitionistic logic

***** linear logic

* (1992) (a. s. troelstra) lectures on linear logic
</pre>
</body>
</html>
