<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>note/mathematics/constructivism/constructivism-computer-and-programming-language.org</title>
</head>
<body>
<pre>#+title: constructivism, computer and programming language

- by XIE Yuheng, 2017

* intro

  1. Digital computers, nowaday, are often viewed as so unhuman.

     While actually, the abstract prototype of digital computer
     -- the Turing machine, is a model based on human computers
     -- people who perform mathematical calculations.

     The purpose of this modeling is to serve Turing&apos;s project,
     which is to inquire the nature of mathematical calculations,
     i.e. to understand computability.

  2. As the art of manufacturing digital computers,
     and the art of programming them, are so developed today,
     a similar project, to inquire the nature of mathematical truth,
     is naturally taken up by mathematicians,
     in a certain computer aided way.

     Since mathematical truth is ensured by deduction,
     the steps of which, being written down, is called proof.
     This time, the model is the type system of programming language,
     with which the deductive rules of mathematics are built in.

     We have type as proposition, function as proof.
     Thus the language game of mathematics is modeled by
     the language game of programming.
     [language game in the sense Wittgenstein]

* bishop&apos;s project

  1. constructivism is not to limit &gt;&lt;&gt;&lt; the way how mathematics are studied,
     [not as early Wittgenstein]

     but to draw a map, a map with rich informations

     [bishop&apos;s project]

     just as Turing had successfully achieved

  2. we extend the construction allowed
     from number to computer program

  3. just as Kant said,
     concepts without percepts are empty,
     percepts without concepts are blind.

  4. 把 bishop&apos;s 的說辭 用程序語言來解釋

* programming language

  1. In Bishop&apos;s age, constructivism against formalism.
     But the language game of programming is so special,
     it is constructivily formal.

  2. We have to always care about how fast a function runs.

  3. the language can be changed,
     the rules we used to implement the language can be revised.
     in practical always under development.
     [a progressing dialectic]

  4. One must always describe how the language is,
     but not try to find a fixed set of axioms and rules
     to deduce the language.

* bishop&apos;s principles

  1. &gt;&lt;&gt;&lt;&gt;&lt;
</pre>
</body>
</html>
